{"meta":{"title":"Flipped205","subtitle":null,"description":null,"author":"Flipped205","url":"http://Flipped205.github.io/BlogCode","root":"/"},"pages":[{"title":"Apple portal弹窗报文","date":"2018-08-02T00:00:00.000Z","updated":"2020-02-24T10:05:02.287Z","comments":true,"path":"工作/Apple_portal弹窗报文.html","permalink":"http://Flipped205.github.io/BlogCode/工作/Apple_portal弹窗报文.html","excerpt":"","text":"1. Portal弹窗是个啥 ？ 简单的说就是当ios或是MacOS连接上需要认证的WiFi的时候系统会弹出一个窗口来进行wifi认证。（请脑补连上机场WIFI之后让你输入手机号码然后才能上网的画面~） The Apple Captive Network Assistant (CNA) feature is an overlay that appears and prompts users automatically to login to the detected captive portal network without the need to explicitly open a web browser. This type of login is useful on mobile devices where many of the common applications are not browser-based and these applications would otherwise fail to connect without the successful browser-based authentication. Examples of these nonbrowser-based applications are email, social networking applications, corporate VPNs, and media streaming. 2. portal弹窗原理是个啥？ The Apple operating systems detect the presence of a network that has captive portal enabled by attempting to request a web page from the Apple public website. This HTTP GET process retrieves a simple success.html file from the Apple web servers and the operating system uses the successful receipt of this file to assume that it is connected to an open network without the requirement for captive portal authentication. If the success.html file is not received, the operating system conversely assumes that a captive portal is in place and presents the CNA automatically to prompt the user to perform a web authentication task. When the web authentication has completed successfully, the CNA window is closed automatically, which prevents the display of any subsequent welcome pages or redirecting of the user to their configured home page. If the user chooses to cancel the CNA, the Wi-Fi connection to the open network is dropped automatically, which prevents any further interaction via the full browser or other applications. 这里提到的web page就是http://captive.apple.com/hotspot-detect.html，当这个page返回success的时候就不会弹窗。 3.抓包抓包环境：Mac-pro， wireshake，K2路由器 3.1 没有portal弹窗配置K2为可以访问http://captive.apple.com/hotspot-detect.html 连接上K2无线后系统会自动启动captive network assistant![](/img/work_01/001.png) captive network assistant会发出一个http请求，访问http://captive.apple.com/hotspot-detect.html![](/img/work_01/002.png) http://captive.apple.com/hotspot-detect.html 返回一个title为Success的网页。Ps，这里Success大小写敏感![](/img/work_01/003.png) 当收到这个返回后，系统会认为不需要portal弹窗。 3.2 portal弹窗将K2恢复出厂设置，然后连接K2 wifi 连接上K2无线后系统会自动启动captive network assistant（同上） captive network assistant会发出一个http请求，访问http://captive.apple.com/hotspot-detect.html（同上） 路由器将DNS请求劫持到192.168.2.1上![](/img/work_01/004.png) 路由器的web服务器对http请求进行重定向![](/img/work_01/005.png) captive network assistant会显示重定向后p.to返回的信息![](/img/work_01/006.png) 效果如下图： ![](/img/work_01/007.png) 这是抓包源文件： no portal.pcapng portal.pcapng"},{"title":"Flash简介","date":"2018-09-04T00:00:00.000Z","updated":"2020-02-24T10:05:02.287Z","comments":true,"path":"工作/Flash简介.html","permalink":"http://Flipped205.github.io/BlogCode/工作/Flash简介.html","excerpt":"","text":"Flash是路由器、手机等手持式电子设备最常用的存储器。像手机用的eMMC、电脑用的SSD，其存储单元还是NAND Flash。 硬件简介 从原理上看，Flash分为NAND和NOR两类。即NOT+AND、NOT+OR，NOT是存储单元的特性、非门，AND/OR是连接方式、串联/并联。 这一点从阵列结构可以看得清楚。 ![](/img/work_08/01.png) 从接口上看，Flash接口通常有并行、串行两种。串行通常为SPI接口。 SPI NOR Flash，引脚少、易布线，应用广泛。 ![](/img/work_08/02.png) Parallel NOR Flash，采用RAM接口，允许随机读取，可以直接供CPU运行代码，而不必拷贝到RAM。 ![](/img/work_08/03.png) SPI NAND Flash，少见，不了解。 Parallel NAND Flash，采用标准接口，8位I/O，复用传输指令、地址、数据等。 ![](/img/work_08/04.png) NAND vs NORFlash有些共通的特点：按块写入，按块擦除，先擦后写。擦除后默认值是0xFF，写入1-&gt;0，0-&gt;1需要擦除。 NAND与NOR对比，有以下主要差异： 访问方式：NOR Flash支持随机读取，NAND必须按页读取； 访问速度：NOR Flash读取稍快，写入和擦除巨慢（2个数量级的差距）； 可靠性：NAND Flash需要坏块处理，除主存储区域，还有OOB（out-of-band）；NOR Flash不需要。 寿命：NOR Flash十万次擦写；NAND Flash百万次擦写。 存储单元的组织结构NAND和NOR Flash都是按阵列结构组织的，但稍有不同。 NAND Flash是Block-Page的阵列结构，最小访问单元是Page，每个Page从512Byte/1K/2K等不同。每个Page对应一块OOB，一般每512Byte对应16Byte的OOB。 ![](/img/work_08/05.png) NOR Flash一般是Block-Sector-Page-Byte的阵列结构，最小访问单元是Byte/Page，允许按Byte读取。 Flash的基本操作Flash有读写擦三个基本操作，Read/Program/Erase，对应型号的datasheet有详细描述。 所有Flash都支持Read ID操作，通过该ID可以判断厂商、芯片型号等，软件可以据此匹配多Flash芯片。该操作可能是厂商自定义的，也可能是JEDEC（JESD216）定义的。 使用注意事项 寿命Flash寿命是有限的，NAND百万次，NOR十万次，应避免对同一地址频繁擦写。举个例子：比如4G流量统计需要15s记录一次，如此计算，NOR Flash 半月损坏，NAND Flash 半年损坏。显然无法满足要求。改善方案： a）使用针对Flash专门设计的FS，比如yaffs、jffs，有擦写均衡。均衡效果一般受剩余空间约束，剩余空间过小时仍需要评估。 b）无FS的情况，高频访问的参数，可以开辟一段空间，轮流写入。比如1Byte的数据，给予256的一个Page，寿命几乎延长256倍。 数据完整性因为不能随机写入、先擦后写等原因，操作不当容易造成数据丢失，需要注意。比如，修改1个字节，至少需要重写一个Page，甚至擦除1个Block，就需要先备份原有数据，然后修改，然后写入。中间人和环节断电，数据会丢失。有几种方式保证完整性，或者出错后纠错： a）yaffs、jffs等系统，一定程度有这方面的考虑。 b）设计备份纠错机制，上电自检恢复。比如K2S nvram做了这方面的改进，nvram分区写之前，先备份到nvram_backup备份分区，上电时检查nvram_backup分区的备份标记，执行回复。 c）应用程序自身做容错设计，可以检错纠错。 参考资料：【Flash存储器简介.ppt】讨论PPT【Benchmarking_Flash_NOR_and_Flash_NAND_memories_for_Code_and_Data Storage.pdf】Flash芯片级原理介绍【GD25Q128C-Rev1.2.pdf】SPI NOR Flash Datasheet【am29lv160.pdf】Parellel NOR Flash Datasheet【K9F2G08U0.pdf】Parellel NAND Flash Dataseet"},{"title":"使用Markdown撰写文档的解决方案","date":"2018-08-03T00:00:00.000Z","updated":"2020-02-24T10:05:02.287Z","comments":true,"path":"工作/markdown.html","permalink":"http://Flipped205.github.io/BlogCode/工作/markdown.html","excerpt":"","text":"1 前言最近看到有些人在用Markdown来写文档，所以这里分享一下我的解决方案。 介绍工具之前，我先谈谈对使用Markdown的优劣的思考： 优势 轻量 使用相对简单。随便打开一个文本编辑器你就可以开始干活了，也不像word有这么多的选项，减少你很多排版的时间。这里加了一个“相对”，原因是如果使用Markdown扩展的话，其实语法逐渐开始有一些复杂了。 由于是纯文本的，有利于查看历史修订，有利于跟版本控制集成，便于维护。 易于部署。除了渲染需要专门的工具，编辑和查看不依赖复杂的工具，甚至你不需要将Markdown渲染成html，也能完全看得懂 由于轻量，让Markdown非常适合跟随代码，作为工程/模块的README 算是一项技能。目前越来越多的地方支持类Markdown的标记语言，例如github、一些主流的RESTful API接口文档撰写工具（API Blueprint、swagger editor）、有道云笔记、锤子笔记以及我们之前用的代码评审工具phabricator等等 劣势 标准Markdown语法太简单，不太好用，导致各种Markdown变体的产生，所以现在最大的问题就是没有标准。记得14年看到过一篇文章《Standard Flavored Markdown》，现在再去看看，发现进展并不是很顺利，看来Markdown离大一统还有很长的路要走orz word和Markdown的学习曲线是刚好颠倒的，Markdown上手前需要了解的一些基础的语法，甚至是一些扩展语法，导致很多人一开始就是排斥的，这也导致Markdown并不适合大团队作为标准的文档格式，因为总有人（特别是非研发岗）用不好甚至是不会写Markdown，那么文档的传承和维护就成了大问题 作图不方便，如果用visio之类的工具转成图片又不利于维护，所以除非你已经非常擅长画ascii图，否则尽量不要用Markdown来写复杂的文档所以现在的我并不十分推崇将Markdown作为整个团队的文档标准，我更倾向于将它用在随代码的README以及一些非正式的文档中 2 vim插件我使用vim作为编辑器，编写Markdown文本时需要一些插件，插件均使用vundle来管理 2.1 gabrielelana/vim-Markdown2.1.1 作用完善了vim的Markdown语法高亮，标准的Markdown的语法高亮早以无法满足大部分扩展Markdown语法，导致你用vim默认的 Markdown syntax 文件查看Markdown文本的时候经常会看到一些错误的高亮内容 ![Markdown Preview](/img/work_06/01.gif) 2.1.2 vim配置 123Bundle 'gabrielelana/vim-Markdown'let g:Markdown_enable_spell_checking = 0let g:Markdown_enable_mappings = 0 2.2 iamcco/Markdown-preview.vim2.2.1 作用能帮助那些初学Markdown的童鞋写文档，但要注意一点，这个工具的Markdown渲染器与我最终要使用的渲染器是不同的，所以语法有细微差别 2.2.2 vim配置 1Bundle 'iamcco/Markdown-preview.vim' 2.3 jszakmeister/Markdown2ctags2.3.1 作用需要配合ctag一起使用，让ctag识别Markdown文本中的标签 2.3.2 vim配置 1234567891011121314151617&quot; MarkdownBundle &apos;jszakmeister/Markdown2ctags&apos;&quot; Add support for Markdown files in tagbar.let g:tagbar_type_Markdown = &#123; \\ &apos;ctagstype&apos;: &apos;Markdown&apos;, \\ &apos;ctagsbin&apos; : &apos;/home/oyxy/.vim/bundle/Markdown2ctags/Markdown2ctags.py&apos;, \\ &apos;ctagsargs&apos; : &apos;-f - --sort=yes&apos;, \\ &apos;kinds&apos; : [ \\ &apos;s:sections&apos;, \\ &apos;i:images&apos; \\ ], \\ &apos;sro&apos; : &apos;|&apos;, \\ &apos;kind2scope&apos; : &#123; \\ &apos;s&apos; : &apos;section&apos;, \\ &#125;, \\ &apos;sort&apos;: 0,\\ &#125; 注意示例配置中的路径要改一下 3 学习 pandoc Markdown 语法 pandoc是什么? pandoc is a universal document converter. pandoc可以渲染很多类型的标记语言文档，Markdown只是其中一种。我看重它的原因有： 它对Markdown的语法支持很全，支持多种主流Markdown变体（Markdown的语法扩展） 开放了很多定制，所以非常灵活，能方便我实现完整的文档渲染方案 支持图片的”self-contained”，能让包含图片的Markdown也能生成单一的html文件，极大地方便了发布 学习pandoc Markdown语法，需要阅读官方手册 4 使用我定制的模板和pandoc命令封装 安装pandoc（附件是ubuntu 64bit的安装包，你也可以从 https://github.com/jgm/pandoc/releases 下载） 【注意】一定不要使用apt-get安装pandoc，因为那个版本太老了，缺失一些重要特性 解压 xpandoc.tgz，并执行install4ubuntu64.sh一键加载环境 5 如何使用假如你的Markdown文件名为a.md，执行命令和结果如下，生成的a.html的文件即为最终文件，如果需要发布pdf的版本，可以直接用浏览器的打印功能 1234$ pandoc_md.sh a.mdconverting a.mdpandoc -f markdown+ignore_line_breaks -t html a.md &gt; a.html -c /home/xiongyi.ouyang/.pandoc/pandoc_css/ie7unnel.css -c /home/xiongyi.ouyang/.pandoc/pandoc_css/nav.css -c /home/xiongyi.ouyang/.pandoc/pandoc_css/tplink_accondion.css --toc --template=phicomm.html --number-sections --highlight-style=haddock --self-containedoutput: create a.html 附件有两个示例文件，其中a.md即为本贴的Markdown源文件，供参考 pandoc_MANUAL.pdf a.tgz 示例2.tgz xpandoc.tgz"},{"title":"ubuntu下录屏＆gif制作教程","date":"2018-08-03T00:00:00.000Z","updated":"2020-02-24T10:05:02.287Z","comments":true,"path":"工作/ubuntu_gif.html","permalink":"http://Flipped205.github.io/BlogCode/工作/ubuntu_gif.html","excerpt":"","text":"安装所需软件 安装屏幕录像器 kazam 1sudo apt-get install kazam 安装mplayer，转换视频文件 1sudo apt-get install mplayer 安装imagemagick 1sudo apt-get install imagemagick 屏幕录制 打开一个shell，执行cazam命令出现如下窗口![](/img/work_07/01.png) 选中“Mouse cursor”，会把鼠标的运动轨迹也记录下来；其他的选项，见名知意，不多赘述 想要录制下敲代码的过程，只希望录制终端窗口 1.选中“Window”选项卡。如：![](/img/work_07/02.png) 出现该画面后，鼠标点击一下terminal终端。那么后边就只会对终端窗口进行录制了。 2.点击capture开始录制，会出现如下倒计时窗口：![](/img/work_07/03.png) 3.倒计时结束后自动进行录制。此时，你在终端下的动作都会被记录下来。 4.当录制完成，想要终止录屏，则点击右上角摄像头图标，出现下拉菜单，选择finish即可。当然，如果选择pause，会暂停录制。![](/img/work_07/04.png) 5.结束录制后，出现如下弹窗![](/img/work_07/05.png) 6.点击continue，将录制的视频保存下来，如:![](/img/work_07/06.png) 把录制下来的视频制作成gif动画 12345678#将视频转换为图片们mplayer -ao null test.avi -vo jpeg:outdir=./pics#将图片们打包为gif,resize代表图片缩放比例convert ./pics/*.jpg -resize 45% test.gif#发现图片太大，压缩图片convert test.gif -fuzz 10% -layers Optimize newTest.gif 这样，整个从录屏到制作gif过程就讲完了。为了简化大家的操作，我写了个脚本，对上述几条命令打了个包。在附件中，欢迎大家下载使用v2gif.sh"},{"title":"vim插件库","date":"2018-09-04T00:00:00.000Z","updated":"2020-02-24T10:05:02.287Z","comments":true,"path":"工作/vim插件库.html","permalink":"http://Flipped205.github.io/BlogCode/工作/vim插件库.html","excerpt":"","text":"你用VIM就不能不知道这个网站（不是很稳定，有时候需要翻墙） http://vimawesome.com/ 这个网站是干什么的？ Vim Awesome is a directory of Vim plugins sourced from GitHub, Vim.org, and user submissions. Plugin usage data is extracted from dotfiles repos on GitHub. 最后记得用vundle来管理你的VIM插件 开发环境的搭建附件中有个压缩包，包含了我自己当前正在使用的开发环境。说白了，就是一些配置文件，如：vimrc的配置，tmux的配置，markdown的配置等等。这些配置也是之前steal from 欧神的，我个人觉得对于提高生产力还是挺有帮助的，有需要的同事可以安装一下，已经做到了比较好的自动化。安装方法： １．随便在home目录下建立一个目录，如：dev_env ２．cd ~/dev_env ３．将dotfiles.tar拷贝到该目录下，tar xvf dotfiles.tar ４．cd dotfiles/ ５．修改git/gitconfig文件如下user部分，替换成自己的名字就可以了 [user] email = ming.xing@feixun.com.cn name = ming.xing 6．sudo apt-get install tmux//如果没有安装tmux，则执行该命令安装一下 7．./setup.sh 执行该文件就OK了 PS.需要注意的是，执行shell的过程中可能会从网上拉一些文件，要求是你的环境能上网，可以执行sudo apt-get install命令。如果环境不能上网，大家可以自己根据shell的内容，自定义安装某些工具。dotfiles.tar 常用快捷键（根据如上配置完成）： vim自身集成的快捷键有很多，在这里也不好一一列举，还是看别人分享的吧：http://www.cnblogs.com/tianyajuanke/archive/2012/04/25/2470002.html 下面有一些根据自己的配置，设置的一些快捷键，想到几个写几个，以后慢慢更新吧…… 如果大家有用到上一个帖子里的配置的话，需要先对系统上的键盘快捷键做些设置如： １．去掉系统自身的ALT快捷键的功能： 点击右上角设置按钮-&gt;打开system settings-&gt;Keyboard-&gt;Shortcuts ![](/img/work_10/01.png) 鼠标移动到Key to show the HUD选项，敲击退格键（backspace)，值会变成Disabled.然后退出即可。 ２．随便打开一个终端，点击左上角Terminal，下拉菜单中选择Preferences,去掉第二项“Enable mnemonics(xxxx……）”，如下图： ![](/img/work_10/02.png) PS.这各选项在不同的ubuntu版本中的位置可能会不一样。 F4:vim随便打开一个Ｃ文件，按下F4，会调出function list，如： ![](/img/work_10/03.png) 跳转到左侧窗口，移动鼠标到相应的function，点击'o'即可跳转到相应的函数定义的地方。 F8:此时，按下F8，会调出当前目录下的目录树，如： ![](/img/work_10/04.png) 将鼠标移动到'▸'上，键盘敲击o打开展开或折叠目录；鼠标移动到文件上，敲击ｏ会打开相应的文件。 CTRL+[h,j,k,l]：各窗口之间切换，[h,j,k,l]分别映射方向键[←，↓，↑，→]。PS.大家要强迫自己慢慢的适应这几个字母，而不是去按“上下左右” VIM复制＆粘贴： 简单的复制和粘贴，通过y和p，以及各种衍生的组合键即可完成。这里介绍一下，如何从vim打开的文件，复制选中的内容到”系统的”剪切板（不是vim内置的buffer哦）： 1.复制：vim随便打开一个文件，通过v或者shift v等快捷键，选中想要复制的内容，按下【’,’ + ‘y’】，即“逗号＋y”组合。此时buffer已经在系统剪切板中了。 2.粘贴：如果想要将系统剪贴板中的内容复制到terminal窗口下，或者其他vim打开的文件中，可以同时按下:CTRL+SHIFT+v组合键；粘贴到其他位置（如搜索引擎），直接CTRL+v即可 如果是实在万不得已，一定要用鼠标选中要复制的内容，也是有办法的：在鼠标选中要复制的内容前，按下shift键不松手就行了。（为什么变得复杂了？答：为了彻底抛弃鼠标！） 阅读代码相关的快捷键： 想要比较方便的在各个函数调用之间来回穿越，离不开cscope工具。 举例：可能会花大量的时间阅读某一块代码，如内核代码。 1：打TAG。进入kernel目录，执行cscope -Rb，完成后该目录下会多出个cscope.out文件 ![](/img/work_10/05.png) 2：打开一个文件，如drivers/gpio/gpio-xrx500.c，阅读到了285行，想要知道pinctrl_xrx500_get_range_size函数是如何实现的。鼠标移动到该函数上，按下CTRL+']'，即可跳转到函数定义处。（跳转到宏定义处，方法相同） ![](/img/work_10/06.png) 跳转回来：CTRL+'t'。 3：如上图第296行，想要知道都有哪些地方调用了该函数。鼠标移动到该函数任意位置—&gt;按下CTRL+’&#39;+c组合键—-&gt;出现函数调用列表—-&gt;选择对应数字即可打开 4：想要打开某个引用的头文件。将光标移动到该头文件的引用处—–&gt;按下按下CTRL+’&#39;+f组合键—–&gt;文件列表 tmux相关： 打开一个terminal，输入tmux命令即可进入tmux的shell环境 ALT + ‘=’：可以创建多个tmux窗口,如上图中最下边的状态栏（中间）１,2,3—6 ALE+E＋’number’：ALE+E是tmux快捷建中的一个“前导键”（tmux默认前导键是CTRL+b，太不人性了，所以才有了上边对keyboard的设置），也就是说，绝大多数的tmux快捷键都要一个ALE+E开头，然后再加上一个功能键 ![](/img/work_10/07.png) ALE+E执行完后，左下角会出现PREFIX（如左图）的阴影。接下来，就可以按下功能键了，如果此时按下”2”，则会打开第二个tmux pannel。 ALE+’w’：向前打开一个window ALE+’q’：向后打开一个window ALT+’&#39;：打开上一次打开的window ALE+’x’:删除当前pannel ALT+’-‘:删除当前window 下边说明tmux快捷键的时候，统统用PRE代指“ALT+E” 在同一个tmux窗口下创建多个pannel的方法： 1.pannel上下分布：PRE+’‘，这里的’‘指下划线 2.pannel左右分布：PRE+’|’ 3. ![](/img/work_10/08.png) 如图：执行了PRE+'_'和PRE+'|'后，会把窗口分割成３各pannel。 跳转：假设当前光标在２号pannel 跳转到１号pannel：PRE+k（↑） 跳转到３号pannel：PRE+l（→） 跳回来则进行相反的操作即可。 如果窗口较多，如： ![](/img/work_10/09.png) 想要从９号调到１号的话，如果利用上面的方法，显然就太拙劣了。tmux提供了自然是提供了更方便的办法： 按下PRE+q后，tmux会对每一个pannel进行编号，此时按下数字几，就会跳转到相应的pannel。 删除当前的pannel：CTRL+d。暂时，我没有找到删掉“除当前pannel之外的其他pannel”的办法，有谁想到了，告诉我…… tmux复制＆粘贴： PRE+’[‘：进入tmux的浏览模式下，此时的光标移动跟打开vim时一样，”↑↓←→“通用。光标移动到”leds-rb532.c“，点击’v’进入visual模式（跟vim一样），选中该字符串，点击’y’。此时会自动退出该浏览模式，字符串已经保存在了tmux相关buffer里。如： ![](/img/work_10/10.png)"},{"title":"笔记","date":"2018-08-02T00:00:00.000Z","updated":"2020-02-24T10:05:02.287Z","comments":true,"path":"工作/笔记.html","permalink":"http://Flipped205.github.io/BlogCode/工作/笔记.html","excerpt":"","text":"一、 linux 处理 Excel 的方法将 excel 另存为逗号分隔符文件（csv），然后在 linux 下， 使用 sed 命令将文件中的逗号换成空格。这样在 C 里面或者 shell 里面，对文件处理起来就比较容易了。 —————————————————————————————————————————————————————————————————————————————————— 二、一个定时器的实现分享定时执行一个动作，是常见的一种功能需求，简单的定时器实现用signal()、setitimer()可以做，但是这样的简易实现，与sleep()会有冲突，因为它们俩都是靠SIG_ALRM来工作的，甚至有些CPU方案+编译器，SIG_ALRM都不支持线程独立。 分享一套比较强大的定时器实现，timer_create()、timer_settime()、timer_delete()** 首先来看timer_create()：** 1int timer_create(clockid_t clock_id, struct sigevent *evp, timer_t *timerid) 它可以创建一个可控制的定时器，并且通过参数timer_t *timerid返回创建的定时器id 12345678910111213141516clockid_t clockid/*记时时钟类型，取值范围：CLOCK_REALTIMEA settable system-wide real-time clock.（相对时间，从1970.1.1到目前的时间，更改系统时间会更改获取的值，它以系统时间为坐标。）CLOCK_MONOTONIC A nonsettable monotonically increasing clock that measures time from some unspecified point in the past that does not change after system startup.（单调时间，表示系统启动后流逝的时间，由变量jiffies来记录的，更改系统时间对它没有影响。）CLOCK_PROCESS_CPUTIME_ID (since Linux 2.6.12)A clock that measures (user and system) CPU time consumed by (all of the threads in) the calling process.（本进程到当前代码，系统CPU花费的时间）CLOCK_THREAD_CPUTIME_ID (since Linux 2.6.12) A clock that measures (user and system) CPU time consumed by the calling thread.（本线程到当前代码，系统CPU花费的时间）*/ 123456789101112131415161718192021struct sigevent&#123; int sigev_notify; /* SIGEV_NONE：定时到期后什么都不发生，只提供通过timer_gettime和timer_getoverrun查询超时信息。 SIGEV_SIGNAL: 当定时器到期，内核将sigev_signo指定的信号传送给进程。 SIGEV_THREAD: 当定时器到期，在此进程范围内，内核会以sigev_notify_attributes为线程属性创建一个线程，并且让它执行sigev_notify_function，传入sigev_value作为一个参数。 */ int sigev_signo; union sigval sigev_value; /* union sigval &#123; int sival_int; 整型数值 void *sival_ptr; 指针（强大就在这） &#125; */ void (*sigev_notify_function) (union sigval); void *sigev_notify_attributes; pid_t sigev_notify_thread_id;&#125; 创建好了定时器，就需要启动它，来看timer_settime() 1int timer_settime(timer_t timerid, int flags, const struct itimerspec *value, struct itimerspect *ovalue) 12345678910111213141516171819202122232425262728flags/*0 或 TIMER_ABSTIME如果flags的值为TIMER_ABSTIME，则value所指定的时间值会被解读成绝对值。比如clockid如果是CLOCK_MONOTONIC，value-&gt;it_value设定为60，意思是系统启动后的绝对60S超时；如果系统启动很久以后（超过60S）才运行程序，会发现这个value-&gt;it_value根本没用，会马上超时。*/const struct itimerspec *value /*用它来控制定时器的各种时间*/struct timespec &#123; /* 又一处强大，支持纳秒精度 */ time_t tv_sec; /* Seconds */ long tv_nsec; /* Nanoseconds */&#125;;struct itimerspec &#123; struct timespec it_interval; /* Timer interval */ struct timespec it_value; /* Initial expiration */ /* it_value用于指定当前的定时器到期时间，当定时器到期，it_value的值会被更新成it_interval的值，从而实现循环定时。 如果it_interval置0，则该定时器只会到期一次，一旦it_value到期就会回到未启动状态。 */&#125;;struct itimerspect *ovalue/*如果ovalue不是NULL，那么之前的定时器到期时间会被存入其所提供的itimerspec。如果定时器处于在未启动状态，则此结构的成员全都会被设定成0。*/ 获得一个活动定时器的剩余时间 1int timer_gettime(timer_t timerid,struct itimerspec *value); 这个就不用解释了，结果通过参数value返回。删除一个定时器： 1int timer_delete (timer_t timerid); 下面来看个例程，定时执行一个函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;signal.h&gt;static void timeout_fn(union sigval v) &#123; time_t t; char p[32]; time(&amp;t); strftime(p, sizeof(p), \"%T\", localtime(&amp;t)); printf(\"%s thread %ul, param is [%s]\\n\", p, pthread_self(), (char*)v.sival_ptr); &#125;int main(void) &#123; struct sigevent evp; struct itimerspec ts; timer_t timer; int ret; char* str = \"TIMER EXAMPLE\"; memset(&amp;evp, 0, sizeof (evp)); evp.sigev_notify = SIGEV_THREAD; /* evp.sigev_signo is useless if SIGEV_THREAD*/ evp.sigev_notify_function = timeout_fn; evp.sigev_value.sival_ptr = str; /* pass str to timeout_fn() */ ret = timer_create(CLOCK_MONOTONIC, &amp;evp, &amp;timer); if (ret) perror(\"timer_create\"); ts.it_interval.tv_sec = 2; ts.it_interval.tv_nsec = 0; ts.it_value.tv_sec = 5; ts.it_value.tv_nsec = 0; ret = timer_settime(timer, 0, &amp;ts, NULL); if (ret) perror(\"timer_settime\"); while(1) &#123; pause(); &#125; return 0;&#125; —————————————————————————————————————————————————————————————————————————————————— 三、有意思的小程序之前在上学的时候学C语言，会被教导说，程序都是从main函数开始执行的，不过后来看书知道其实可以不从main函数开始执行，又在书上找到了这个例子，修改为支持64位Linux的版本，编译方式在后面，跟大家分享，图个乐儿： 1234567891011121314151617181920212223242526// tinyhello_64.cchar *str = \"hello world!\\n\";void print()&#123; asm( \"movq $13,%%rdx \\n\\t\" \"movq %0,%%rcx \\n\\t\" \"movq $0,%%rbx \\n\\t\" \"movq $4,%%rax \\n\\t\" \"int $0x80 \\n\\t\" ::\"r\"(str):\"rdx\",\"rcx\",\"rbx\");&#125;void exit()&#123; asm( \"movq $42,%rbx \\n\\t\" \"movq $1,%rax \\n\\t\" \"int $0x80 \\n\\t\");&#125;void nomain()&#123; print(); exit();&#125; 12gcc -c -fno-builtin tinyhello_64.cld -static -e nomain -o tinyhello_64 tinyhello_64.o ——————————————————————————————————————————————————————————————————————————————————"},{"title":"裁剪libiconv字符转码库","date":"2018-09-04T00:00:00.000Z","updated":"2020-02-24T10:05:02.287Z","comments":true,"path":"工作/裁剪libiconv字符转码库.html","permalink":"http://Flipped205.github.io/BlogCode/工作/裁剪libiconv字符转码库.html","excerpt":"","text":"1.libiconv是啥?libiconv是一个字符转换库，同一个字符在不同的标准下面对应的编码方式不同，比如： ![](/img/work_09/01.png) libiconv就是完成不同编码方式的转换。在K2上面的使用pppoe中文账户名拨号和lighttpd（web界面有关）的moileapp的界面显示时会用到转码功能，需求是将汉字字符由utf-8编码的格式转成gb2312的格式（对应的函数调用代码详见sop/package/network/services/ppp/src/pppd/options.c第411行 和 sop/packgage/feeds/packages/lighthttp/src/src/mod_mobileapp.c第2545行） 2.为啥要裁剪？k2上面的libiconv库采用的是libiconv-full库，编译生成的libiconv.so大小为900多K，这在在K2mini上肯定是不行的（Flash仅为4M） 3，裁剪原理是啥？因为在1中我们提到过，中文转码只需要utf-8和gb2312两种，加上英文，总共应该需要ascII，utf-8，gb2312三种编码方式，libiconv-full提供了多国语言，多种标准的编码方式，所以很大一只，我们可以仅保留这三种让这个库小很多。 4，怎么裁剪的？K2的源码sop/package/libs下面里面有两个libiconv的包，一个是libiconv-stub(简化包)，一个是libiconv-full（前面提到过的），在尝试了对libiconv-stub添加gb2312方式失败的情况下，转而裁剪libiconv-full库。 要裁剪库的话就需要去修改build_dir/target/libiconv/lib目录下源文件： 修改的方法一直接修改源文件，然后修改makefile的make方式，改成本地新建src文件夹make的方式，详见（SOP开发指南 10.3一小节http://172.17.200.152:8080/SOP%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97.html ） 为了省事和沿用之前的make方式，即采用了第二种方法——使用的是make+patch的方式，详见（SOP开发指南第9节），就是基于patch文件对下载解压出来的文件进行修改，然后到build_dir/target/libiconv/目录下编译。 我修改的patch文件是/package/libs/libiconv-full/patches/下面的100-strip_charsets.patch文件，patch文件里的所做的修改对应的是源码lib目录下面的aliases.h 和aliases.gperf 和converters.h和encodings.def四个文件的修改。这里用到了quilt工具方便管理和修改patch文件（详见 Working with patches ），这个工具可做到间接修改patch文件和直接修改对应的源文件这两种方式的灵活结合。 具体所做的修改简单来讲就是在100-strip_charsets.patch的基础上（已经裁掉了包括gb2312在内的大量的编码表），分别在aliases.h 和aliases.gperf 和converters.h和encodings.def四个文件里做相应的添加，添加gb2312相关的内容，修改完成之后重新使用mmm -c libiconv-full命令编译，最终生成的libiconv.so为60多k，满足要求。。。（附件为修改完成之后的裁剪patch文件） 100-strip_charsets.patch"},{"title":"Broadcom NVRAM实现机制与优化","date":"2018-08-02T00:00:00.000Z","updated":"2020-02-24T10:05:02.287Z","comments":true,"path":"工作/Broadcom_NVRAM.html","permalink":"http://Flipped205.github.io/BlogCode/工作/Broadcom_NVRAM.html","excerpt":"","text":"1. NVRAM源码结构1.1 NVRAM概述 本质上，NVRAM是flash中的一块大小为64KB的存储空间。系统boot后，这块存储空间被映射至内存，并依据这段内存构造了一个插入、删除、查找速度极快的数据结构。同时，Broadcom还为该设备提供了mmap()、read()、write()、ioctl()等系统调用接口以实现用户想要的各类型操作，这些操作包括读取/存储系统配置项、读取/存储用户自定义的临时变量、将对NVRAM的改动实际地写入flash等。NVRAM是Broadcom芯片方案中非常重要的一个套件，运行在Broadcom芯片方案上的许多应用程序都会用到NVRAM提供的服务来获取/改变系统的当前状态。 1.2 Broadcom NVRAM源码结构 Broadcom为NVRAM提供了设备驱动程序、动态链接库以及一个简单易用应用程序，应用程序不是我们关心的，不再赘述。动态链接库为应用程序提供了几个关键的API，包括：①用于读取NVRAM变量值的函数nvram_get()；②用于设置NVRAM变量值的函数nvram_set()；③用于将RAM中的变量与值写入flash的函数nvram_commit()等。这三个函数实际上分别通过系统调用read()、write()、ioctl()陷入内核态，进而执行NVRAM的设备驱动程序。 用户态的源代码位于repeater/main/components/router/nvram目录下，名为nvram_linux.c，编译产物为libnvram.so。内核态的源代码被精巧地分为两个部分：位于repeater/main/src/shared目录下的nvram.c，该源文件包含平台无关的代码，数据结构与算法实现也定义在此处；而位于repeater/main/components/opensource/linux/linux-2.6.36/arch/arm/plat-brcm目录下的是平台相关代码，名为nvram_linux.c，该源文件提供了系统调用接口的具体实现以及设备初始化代码；repeater/main/src/shared目录下的nvram_rw.c则包含了CFE阶段初始化NVRAM代码。NVRAM的体系结构如图1所示。 ![图1 NVRAM体系结构](/img/work_04/01.png) 2.NVRAM初始化 NVRAM伴随着CFE的初始化过程，这里简要阐述： 首先，CFE启动代码尝试发现NVRAM。Broadcom解决方案中总是将NRVRAM分区置于flash的最后64KB字节中，这64KB字节分区的头部包含NVRAM的基本信息，头部具有如下所示的格式： ![图2 NVRAM头部信息](/img/work_04/02.png) 每个参数都是4字节的整型，这里只关心magic这个参数。顾名思义，该参数是一个特殊的魔法数，启动代码通过这个魔法数确定是否发现了正确的NVRAM分区；flash总大小总是为2的n次方字节，且至少是128KB。所以，寻找NVRAM的算法就比较简单了，每次都假设flash总字节数为2的n次方，回退64KB并尝试读取魔法数，如果读取得到的magic恰好是预设的魔法数，就认为已经找到了正确的NVRAM分区；否则假设flash总字节数翻倍，然后继续进行尝试。尝试一定次数还未找到NVRAM分区，那么就会使用默认NVRAM变量。默认的NVRAM位于flash一个特定的位置，而且默认NVRAM变量是只读的，因此不存在被破坏的可能，这样就保证了CFE总是能够获取必要的启动信息。特别地，当用户选择恢复出厂时，CFE会直接读取默认NVRAM。之后就调用_nvram_init()，将整个nvram分区拷贝至RAM，调用nvram_rehash()完成初始化，得到一个完整的包含所有NVRAM变量的NVRAM哈希表。发现NVRAM的过程如图3所示： ![图3 发现NVRAM分区的算法](/img/work_04/03.png) 3.数据结构与算法分析 这一节将简要分析NVRAM在内存中的存储结构，以及read()、write()、ioctl()等系统调用在内核空间中的实现机制，以期获得一个完整清晰的模块逻辑。首先简要描述NVRAM的数据结构；然后分别描述执行系统调用read()、write()和ioctl()时的执行流程，其中ioctl()的实现机制是重点分析对象。 3.1 NVRAM的数据结构 假设在此之前已经完成了NVRAM的初始化工作（初始化在CFE阶段就已经完成了），这里将简要分析NVRAM的所有变量与值是如何在内存中进行存储的。为了方便存储，解决方案使用了自定义的结构体struct nvram_tuple，该结构体包含三个数据成员：①char *name，指向NVRAM变量名字符串的指针；②char *value，指向NVRAM值字符串的指针；③struct nvram_tuple *next，指向下一个struct nvram_tuple的指针。如图2所示是NVRAM在内存中的存储结构，主要分成四个部分： 1.首先是名为nvram_hash的哈希表。哈希值由NVRAM变量名字符串计算得出，每个表项都是一个struct tuple的链表。（值得一提的是，“每个表项都是一个struct tuple的链表”的说法并不严格准确。具体地说，在为struct nvram_tuple动态分配存储空间时多分配了一部分内存空间，而这多余的存储空间则用于存储NVRAM变量名字符串。因此，链表中每个节点可能具有各不相同的大小。）由于采用了哈希表存储所有的NVRAM变量，所以理想情况下，查找一个变量的速度可以达到O(1)，这使得NVRAM的操作速度相当快。 2.其次是一个名为nvram_dead的链表，链表中存储所有已经废弃的struct tuple节点。例如，当用户unset某个变量时，该NVRAM变量的节点就被移动至nvram_dead链表中。尚不清楚为什么Broadcom选择存储这些已经废弃的节点。 3.然后是一个名为nvram_buf的64KB缓冲区。该缓冲区将所有的NVRAM变量名-变量值字符串对集中存储。为什么不像NVRAM变量名字符串一样与struct nvram_t0uple节点一起存储？这是因为NVRAM值字符串不像变量字符串一样总是具有固定的长度，一个NVRAM变量的变量名字符串总是不变的，例如get_wan_port_status这个变量名总是表示WAN口状态，因此长度不会有任何变化；相反地，举个例子，一个变量值字符串可以取“yes”和“no”两种取值，因此变量值的长度是可变的。各个nvram_tuple节点的value指针指向该缓冲区的各个字符串。当一个NVRAM变量的值长度发生变化时，若新的值字符串长度不大于原长度，则将值字符串存储在原址；否则就将值字符串存储到未使用的缓冲区中，并使nvram_tuple节点的value指针指向新的值字符串。如此，除非缓冲区nvram_buf被占满，NVRAM值字符串的存储需求总是可以得到满足。 4.最后是一个临时的、大小为64KB的缓冲区header。header缓冲区总是在需要使用的时候动态申请，用完立即销毁，主要用于初始化、写入flash等操作时在内存中构造一个与将要写入flash的内容完全相同的缓冲区。header的头部存储magic number、CRC校验码等重要信息，接下来就是一连串的“name=value”的变量名-变量值对。通过MTD的设备的read()与write()方法，程序可以将flash中NVRAM设备的字节读取到header缓冲区中，也可以将header缓冲区的刷写入flash。 ![图4 NVRAM数据结构](/img/work_04/04.png) 3.2 read()系统调用 应用程序使用nvram_get()获取值字符串，而nvram_get()内部通过系统调用read()获取值字符串，同时将变量名字符串通过read()的参数传递给NVRAM设备驱动。陷入内核态后，read()系统调用将执行dev_nvram_read()函数。如图5所示是dev_nvram_read()函数的基本执行流程，这里忽略了一些必要的出错处理。首先计算变量名字符串的哈希值，在对应的链表中查找从nvram_tuple节点。若找到正确的节点，函数返回对应“name=value”字符串在缓冲区中的偏移量；否则返回0（注意到任何一个“name=value”字符串的偏移量都不可能为0，因为缓冲区一开始是一个16个字节的头部信息）。 ![图5 dev_nvram_read()执行流程](/img/work_04/05.png) 3.3 write()系统调用 应用程序使用nvram_set()设置NVRAM变量时，nvram_set()内部通过系统调用write()设置NVRAM变量。陷入内核态后，write()系统调用将执行dev_nvram_write()函数。如图6所示是dev_nvram_set()的基本执行流程，这里忽略了一些必要的出错处理。首先根据变量名字符串找到NVRAM变量在哈希表中的存储位置；查找该哈希表项，即nvram_tuple链表，若找到该变量名则替换其变量值，否则创建一个新的nvram_tuple节点，为节点各项元素赋以合适的值，这些值通常都是由应用程序员提供的；最后将该节点插入链表头部，完成nvram_set()操作。 ![图4 dev_nvram_write()执行流程](/img/work_04/06.png) ### **3.4 ioctl()系统调用** ### 注意到，无论是系统调用read()还是write()本质上都没有实际执行IO操作，只是在内存中进行了一些存取。不过，一旦应用程序调用nvram_commit()函数，就涉及了真正的IO操作。nvram_commit()通过系统调用ioctl()实现其功能。通过ioctl()陷入内核态后，ioctl()将执行nvram_commit()函数(内核中的nvram_commit()，不同于同名用户态API)，该函数比较复杂，细节的处理较多，如果都详细加以说明反而会导致逻辑不清晰，因此在此忽略了大部分的出错处理。处理步骤简述如下： 1) 申请一块大小为64KB的缓冲区buf，buf的大小与flash中NVRAM设备是一致的； 2) 生成头部信息，头部包括CRC校验码、版本信息等； 3) 遍历哈希表，将表中所有的变量名-变量值对逐一以“name=value”的格式填入该缓冲区，填写buf缓冲区域结束后重新生成哈希表，如果需要的话，在这里会补充一些参数； 4) 整块擦除NVRAM对应的64KB的flash空间，使之能够被重新写入； 5) 完成擦除后，程序便将缓冲区buf的内容写入flash。至此，nvram_commit()的所有工作就都完成了。 4.NVRAM的优化 Broadcom提供的NVRAM机制其本意是用于用户配置项的存储，但是在工程实践中，由于普遍对该工具的用途认识出现了偏差，且Broadcom解决方案中没有为进程间的参数共享提供一个切实有效的通用机制，导致了NVRAM机制的大范围错用与误用。比如说，用一个NVRAM变量（pingcheck）表示当前的网络状态。这种用法程序员是比较方便，但是却不合理。这是由于NVRAM设计之初就是为了存储用户的配置项，所有的用户配置项必须最终必须刷写入flash以使得下次开机时用户配置项依然生效。把容易实时地发生变化的系统状态量写入NVRAM是极不明智的。这里说是NVRAM的缺陷，不如说是对NVRAM的滥用造成的问题。同时，由于可能对sdk不了解，对于某些函数接口也出现了误用，其中最为典型的是nvram_commit()的误用。nvram_commit()如前所述，会实际地将内存中的NVRAM变量写入flash，频繁的nvram_commit()将缩短flash的使用寿命；同时，nvram_commit()进行写入时首先要擦除nvram分区，再进行写入。在擦除开始后到写入完成前断电，那么nvram分区的内容就会丢失。尽管由于Broadcom提供了较为完善的机制避免了系统因此而不能boot，但是用户配置项的丢失却是是实实在在的，用户将不得不重新设置路由器。考虑到现在用户大量使用无线接入路由器，要求用户再次使用有线进行一次配置是用户极不友好的，更普遍的情况是用户会认为路由器已经无法使用，影响用户使用体验、口碑等。 但是，项目进行到此，使用nvram接口函数的应用程序数量庞大，可以说，几乎所有的应用程序都使用了nvram_set()或nvram_get()或nvram_commit()等接口函数，鉴于工程量大，一一对这些应用程序的源代码进行修改是不合时宜的。因此，需要对NVRAM机制进行优化，优化对原厂源代码的影响应当尽可能小： 考虑到存在数量较大不合时宜的nvram_commit()，需要对源代码进行些许改动，以观察究竟有哪些应用程序使用了该接口。所幸，无论是使用应用程序nvram在串口进行设置还是使用动态链接库libnvram.so对nvram设备进行操作，最终都是经过动态链接库应用层的几个系统调用接口对设备进行访问、改动、保存。已经了解到，nvram_commit()或者是在终端输入nvram commit最终都是通过系统调用接口ioctl()生效。如果在调用ioctl()之前添加一段代码，记录应用程序的PID甚至是时间是完全可行的。同时这对于源代码的改动也是较小的。 考虑到系统中存在大量临时的变量，这些临时的变量也会随着nvram_commit()被实际地写入flash。为防止这些临时量被实际地写入flash，考虑提供一个临时nvram变量机制。该机制允许应用程序员使用nvram的接口函数保存一些临时的nvram变量，同时还能使得这些变量只能出现在内存中，而不会被commit进内存。 考虑到nvram_commit()过程中掉电可能会引发用户配置项丢失，需要为nvram分区提供一个用户配置项的恢复方法。这里采用这样一种做法：开辟一个全新的nvram_backup分区，每次nvram_commit()擦除nvram分区之前先将nvram分区的所有内容拷贝到nvram_backup分区，然后才进行nvram分区的擦除与重新写入。在执行nvram_commit()的过程中系统可能掉电而导致nvram分区的系统配置项丢失，在CFE启动阶段添加代码检测这一错误。一旦发现了错误，就将nvram_backup分区的内容覆写至nvram分区，这样用户配置项就得到了保留。 最后，如果看帖子不方便的，可以下载帖子附件中的.doc文档，内容是完全相同的。 附件资料： nvram设备驱动实现机制.doc header.vsdx ioctl.vsdx nvram体系结构.vsdx read.vsdx write.vsdx 发现.vsdx 内存结构.vsdx"},{"title":"HTTPD简介","date":"2018-08-02T00:00:00.000Z","updated":"2020-02-24T10:05:02.287Z","comments":true,"path":"工作/HTTPD简介.html","permalink":"http://Flipped205.github.io/BlogCode/工作/HTTPD简介.html","excerpt":"","text":"1 前言本文档以K2S为例，简要说明Broadcom平台的网络服务器httpd的实现原理，使大家对httpd有个简单的认识，在遇到问题时能够有初步的定位。 2 连接篇2.1 http协议浏览器与服务器之间的通信，遵循的是HTTP协议，HTTP是一种超文本传送协议（HyperText Transfer Protocol）,是一套计算机在网络中通信的一种规则。HTTP协议基于TCP，默认采用80端口，在TCP/IP体系结构中，HTTP属于应用层协议，位于TCP/IP协议的顶层。HTTP是一种无状态的的协议，意思是指 在Web 浏览器（客户端）和 Web 服务器之间不需要建立持久的连接。整个过程就是当一个客户端向服务器端发送一个请求(request)，然后Web服务器返回一个响应 (response),之后连接就关闭了，在服务端此时是没有保留连接的信息。 2.2 连接过程下图为浏览器和httpd在一次请求回复时经历的主要过程: ![](/img/work_05/01.png) httpd进程启动以后，会先进行初始化，包括创建套接字、绑定端口、设置监听等操作，此时httpd会一直被动监听80端口的变化。 客户端的 connect() 函数能为客户端主动连接服务器，建立连接是通过三次握手，而这个连接的过程是由内核完成，不是这个函数完成的，这个函数的作用仅仅是通知 Linux 内核，让 Linux 内核自动完成 TCP 三次握手连接（三次握手详情，请看《浅谈 TCP 三次握手》），最后把连接的结果返回给这个函数的返回值（成功连接为0， 失败为-1）。通常的情况，客户端的 connect() 函数默认会一直阻塞，直到三次握手成功或超时失败才返回（正常的情况，这个过程很快完成）。 之后，httpd的accept()函数从处于 established 状态的连接队列头部取出一个已经完成的连接，如果这个队列没有已经完成的连接，accept()函数就会阻塞，直到取出队列中已完成的用户连接为止。至此，浏览器与httpd的连接建立完成，之后就可以通过IO操作进行请求的读取和发送。 ![](/img/work_05/02.png) 例如，我们在浏览器地址栏中输入192.268.2.1/#/pc/wifiSet，浏览器会与httpd建立连接，并将上图中的请求数据发送给httpd。 HTTP协议的请求和响应都是一段按一定规则组织起来的文本，其请求的头部包括请求行（请求方式method、请求的路径path、协议版本protocol），请求头标（一系列key：value形式组织的文本行，如第二行指出了该请求的目的主机是192.168.2.1），空行（分隔请求头部与数据）和请求数据。httpd处理这段文本的逻辑在下一篇中介绍。httpd处理完成之后，会向浏览器响应数据，响应请求的头部同样是一段按一定规则组织起来的文本，响应的头部包括状态行（HTTP版本protocol,响应代码和响应描述）、响应头标（一系列key：value形式组织的文本行）、空行、响应数据。 ![](/img/work_05/03.png) 之后就是浏览器和httpd各自关闭连接，一次完整的请求完成。 3 逻辑篇3.1 mime_handler想要理解httpd，最重要的是要理解一个结构体即mime_handler 123456789101112struct mime_handler &#123; char *pattern; //用于匹配文件的pattern char *mime_type; char *extra_header; void (*input)(char *path, FILE *stream, int len, char *boundary); void (*output)(char *path, FILE *stream); void (*auth)(char *userid, char *passwd, char *realm);&#125;;struct mime_handler mime_handlers[] = &#123; &#123; \"upgrade.cgi*\", \"text/html\", no_cache, do_upgrade_post, do_upgrade_cgi, do_auth &#125;,&#125;: pattern是用来匹配函数入口的，如果文件名与pattern指定的模式匹配，则通过input和output指定的函数进行处理，支持通过‘?’匹配任意一个字符，‘*’匹配‘/’以外的所有字符，‘**’匹配任意字符； mime_type是HTTP协议中规定的数据类型，指定了HTTP请求和回复需要遵循的格式，HTTP/1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用 extra_header是需要在回复中添加的头部字段，用于一些特殊的操作，上例中的no_cache完整内容如下，指定了客户端的缓存请求： 123\"Cache-Control: no-cache\\r\\n\"\"Pragma: no-cache\\r\\n\"\"Expires: 0\"； input函数指定了在发送响应HTTP头部以前，需要进行的处理，包括将HTTP请求中的内容解析出来，特别是一些关键的参数，并将其保存在哈希表中，上例中do_upgrade_post在这个阶段会持续接收浏览器发过来的升级包； output函数指定了如何进行回复的操作，包括回复以后的操作，上例中do_upgrade_cgi会对接收到的升级包进行检查，无误后将结果返回给浏览器，，同时发送信号给RC完成后续的写flash和重启操作； do_auth函数指定了对该请求的鉴权操作，判断该请求是否经过认证（K2S中采用单独的一套鉴权操作） 3.2 处理过程以http://192.168.2.1/#/wifiConfig为例，下图为整个过程的数据流图和处理流程图 ![](/img/work_05/04.png) 浏览器中输入URL：http://192.168.2.1/#/pc/wifiSet; 前端预加载的routing.js判断浏览器所属的设备是否为移动设备，决定应该加载pc页面还是h5页面，本例在PC上测试，故解析结果为192.168.2.1/pc/wifiConfig.htm; 浏览器生成HTTP请求，并发送出去，其中包括请求的头部和数据内容，本例为页面请求，没有数据内容，故只包含头部； httpd在监听到80端口有变化的情况下，则通过accept、fdopen打开stream进行数据读取和写入； 从HTTP头部的第一行读出请求的文件为/pc/wifiConfig.htm，该路径为相对www的相对路径； 通过匹配Host字段，解析出请求的主机，判断该请求是否是发送到本机的，如果此时需要DNS劫持，则发送重定向将请求定向到路由器的管理页面； 通过匹配mac地址是否经过鉴权，判断是否需要发送未认证响应； 通过pattern匹配找到相应的处理逻辑，{ “**.html”, “text/html”, no_cache, NULL, do_ej, do_auth }, 由于input函数为NULL，无需预处理； send_headers将响应的头部写入stream； output函数为do_ej，该函数会查找wifiConfig.htm文件中的&lt;%%&gt;,并将其中包括的函数用函数执行的结果替换，如将var wirelessChannel2G = ‘&lt;% nvram_get(“pc_show_2_chanspec”); %&gt;’替换为var wirelessChannel2G = “0”，并将该文件写入stream； httpd关闭stream，发送数据； 浏览器结束数据并解析为真正的页面，至此整个请求响应过程结束。 上面的例子是请求一个htm页面的过程，对于cgi请求的过程稍有不同，体现在HTTP请求和input函数上，一个CGI请求一般需要携带一些参数，用于响应的处理，如登录请求为： 1$.sendAjax(\"login.cgi\", \"user_name\":\"admin\",\"Pwd\":\"MTIzNDU2Nzg=\",\"_pageStyle\":\"pc\"&#125;) 响应的HTTP请求头部为： 123456789101112131415161718192021222324252627POST /login.cgi HTTP/1.1Host: 192.168.2.1Connection: keep-aliveContent-Length: 47Accept: */*Origin: http://192.168.2.1X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36Content-Type: application/jsonReferer: http://192.168.2.1/Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4Cookie: td_cookie=1315354745username=admin&amp;Pwd=MTIzNDU2Nzg%3D&amp;_pageStyle=pc 这里除了HTTP头部以外，还有响应的请求数据username=admin&amp;Pwd=MTIzNDU2Nzg%3D&amp;_pageStyle=pc，以key=value的方式组织，并以&amp;连接多个字段；CGI请求的input的函数为do_apply_post会将这些字段和值解析出来并存储在哈希表中，这样在以后的调用中，只需要通过查找哈希表就可以快速定位所需要的字段和值。 4 开发篇这里只是一点小小的提示，更多功能请咨询李光华大师，后续有新的内容也会补充进来。 4.1 PC访问H5页面当前K2S的页面基本和K3一致，依据访问管理页面的设备类型强制选择访问PC页面H5页面，但是在分析H5页面的相关BUG的时候如果通过手机访问，则失去了PC浏览器自带的那些分析手段，不利于分析BUG，可以通过一定的配置使得PC也可以访问H5页面。下面所说的方法适用于chrome浏览器，其他浏览器未研究，但理论上应该是想通的，无非就是通过navigator的值来完成。在chrome浏览器中，通过F12打开调试界面，找到图示的Network conditions，然后去掉Select automatically前面的勾并在下面输入Windows Phone(别忘了后面的分号)；然后刷新页面就可以访问H5页面了。 ![](/img/work_05/05.png) ![](/img/work_05/06.png) 在这种情况下，页面看起来很大，不过不要紧，可以通过下图的按钮模拟移动设备的界面大小，还可以自动配置不同设备的尺寸。 ![](/img/work_05/07.png) ![](/img/work_05/08.png) ## **5 结语** 这篇文档里面的内容是我在移植和修改httpd及页面的过程中的一些积累，拿出来跟大家分享一下，不了解的同志们拿来稍微看下，理解大体过程，了解的大神还望多多指正。"},{"title":"hashlimit 限速模块解析","date":"2018-08-02T00:00:00.000Z","updated":"2020-02-24T10:05:02.287Z","comments":true,"path":"工作/hashlimit 限速模块解析.html","permalink":"http://Flipped205.github.io/BlogCode/工作/hashlimit 限速模块解析.html","excerpt":"","text":"1 hashlimit简介1.1 令牌桶算法hashlimit 的匹配是基于令牌桶 (Token bucket）模型的。令牌桶是一种网络通讯中常见的缓冲区工作原理，它有两个重要的参数，令牌桶容量 n 和令牌产生速率 s。我们可以把令牌当成是门票，而令牌桶则是负责制作和发放门票的管理员，它手里最多有 n 张令牌。一开始，管理员开始手里有 n 张令牌。每当一个数据包到达后，管理员就看看手里是否还有可用的令牌。如果有，就把令牌发给这个数据包，hashlimit 就告诉 iptables，这个数据包被匹配了。而当管理员把手上所有的令牌都发完了，再来的数据包就拿不到令牌了。这时，hashlimit 模块就告诉iptables，这个数据包不能被匹配。除了发放令牌之外，只要令牌桶中的令牌数量少于 n，它就会以速率 s 来产生新的令牌，直到令牌数量到达 n 为止。通过令牌桶机制，即可以有效的控制单位时间内通过（匹配）的数据包数量，又可以容许短时间内突发的大量数据包的通过（只要数据包数量不超过令牌桶n）。 1.2 使用介绍hashlimit 是 iptables 的一个匹配模块，用它结合 iptables 的其它命令可以实现限速的功能。iptables 的基本原理是“匹配–处理”，hashlimit 在这个工作过程中只能起到匹配的作用，它本身是无法对网络数据包进行任何处理的。 1.2.1 命令使用因此，利用hashlimit来限速需要包括两个步骤：1、对符合hashlimit匹配规则包放行，2、丢弃/拒绝未放行的包。下面是一个简单的例子： 123456789#在以字节为单位进行限速的模式iptables -t mangle -w -A limit_chain -d 10.10.10.231/32 -m hashlimit --hashlimit-upto 1mb/s --hashlimit-burst 1mb --hashlimit-mode dstip --hashlimit-name dst_64_51_06_5C_A0_8A -j RETURNiptables -t mangle -w -A limit_chain -d 10.10.10.231/32 -j DROP#在以包为单位进行限速的模式iptables -t mangle -w -A limit_chain -d 10.10.10.125/32 -m hashlimit --hashlimit-name test --hashlimit-upto 16/sec --hashlimit-burst 32 --hashlimit-mode dstip --hashlimit-htable-expire 180000 -j ACCEPTiptables -t mangle -w -A limit_chain -d 10.10.10.125/32 -j DROP #对于两种模式的选择并不需要额外操作，代码会通过解析 --hashlimit-upto/above 参数后的配置值是否包含 b/s 单位，来判断采用哪种模式 使用需要了解以下几个参数:–hashlimit-name：定义这条 hashlimit 规则的名称, 所有的条目（entry）都存放在/proc/net/ipt_hashlimit/{hashlimit-name}里–hashlimit-mode：限制的类型，可以是源地址/源端口/目标地址/目标端口–hashlimit-srcmask：当 mode 设置为 srcip 时, 配置相应的掩码表示一个网段–hashlimit-upto: 允许进来的包最大速率–hashlimit-above：允许进来的包最小速率–hashlimit-burst：允许突发的个数(其实就是令牌桶最大容量)–hashlimit-htable-max：hash 的最大条目数–hashlimit-htable-expire：proc 信息记录时间, 用于老化 proc 信息记录，单位毫秒(milliseconds)–hashlimit-htable-gcinterval：垃圾回收器回收的间隔时间，也是用于老化 proc 信息记录，单位毫秒 1.2.2 查看proc信息在以字节为单位进行限速的模式下，查看 /proc/net/ipt_hashlimit/dst_64_51_06_5C_A0_8A 文件: 12$ cat /proc/net/ipt_hashlimit/dst_64_51_06_5C_A0_8A59 0.0.0.0:0-&gt;10.10.10.231:0 4194304000 1 63999 第一个字段是 expire 倒计时时间(单位是秒), 比如这里设置 60000 毫秒, 即 60s, 如果 60s 内没有再次触发这个规则, 则会一直减到0 (此时删除相关链表节点，该记录为空); 如果触发则再次变为 60. 第二个字段是 dstip:port-&gt;srcip:port, 这里 mode 只设置了 dstip 第三个字段是当前剩余的令牌数，是实时变化 第四个字段是允许数据包突发放行的次数, 是一个定值 第五个字段是每16个字节消耗的令牌数, 是一个定值 在以包为单位进行限速的模式下，查看 /proc/net/ipt_hashlimit/test 文件:查看 /proc/net/ipt_hashlimit/test 文件: 12$ cat /proc/net/ipt_hashlimit/test179 0.0.0.0:0-&gt;10.10.10.125:0 6400 6400 2000 第一个字段是 expire 倒计时时间(单位是秒), 比如这里设置 180000 毫秒, 即 180s, 如果 180s 内没有再次触发这个规则, 则会一直减到 0 (见上面关于 expire 解释); 如果触发则再次变为 180. 第二个字段是 srcip:port-&gt;dstip:port, 这里 mode 只设置了 srcip 第三个字段是当前剩余的令牌数，是实时变化 第四个字段是令牌桶最大容量, 是一个定值 第五个字段是一次触发使用的令牌数, 也是令牌产生速率, 也是一个定值 这些 proc 信息是内核的 hashlimit 模块完成计算写入的，具体算法过程结合了 iptables 和 netfilter 两部对用户配置数据的转换。 1.3 原理总结为了实现限速功能，可以假定令牌桶中的令牌数的产生速率是一定的（即每秒能够获取的令牌数是一定的），设置的限速值越小（即每秒能够通过的字节或者包数目越小），通过令牌消耗量 = 令牌产生量可以推测，每个字节或者包单位所消耗的令牌数就越大。 1.3.1 重要宏定义先说明一下几个重要的宏定义，xt_hashlimit.c文件中，内核实现令牌桶算法时预先定义了如下几个值： 123456#define _POW2_BELOW2(x) ((x)|((x)&gt;&gt;1))#define _POW2_BELOW4(x) (_POW2_BELOW2(x)|_POW2_BELOW2((x)&gt;&gt;2))#define _POW2_BELOW8(x) (_POW2_BELOW4(x)|_POW2_BELOW4((x)&gt;&gt;4))#define _POW2_BELOW16(x) (_POW2_BELOW8(x)|_POW2_BELOW8((x)&gt;&gt;8))#define _POW2_BELOW32(x) (_POW2_BELOW16(x)|_POW2_BELOW16((x)&gt;&gt;16))#define POW2_BELOW32(x) ((_POW2_BELOW32(x)&gt;&gt;1) + 1) 上面 POW2_BELOW32(x) 宏的作用即是保留 x 在二进制形式下的最高位的 1，其余位置为 0 下面需要找到一个信息确定的情况来推算令牌产生速率这个定值。在代码运行的时候，32 位系统的整型数最大值为 0xFFFFFFFF，借此限定了每个字节或者包单位最多能够消耗 0xFFFFFFFF 个令牌，而由前面可知单位消耗量最大时限速值最小。通过该情况下的确定信息可以计算出令牌的消耗速率，也就是相应的令牌产生速率。（当然，如果你能神预感到其它的限速值情况下，相应的单位消耗令牌数，你也可以计算到一个类似的令牌产生速率）。 以包为单位的限速模式下，通过应用层 iptables 工具能够设置的最低限速值为 1/day（即每心跳 1/(HZ×60×60×24) 个包），即每心跳消耗 0xFFFFFFFF/(HZ×60×60×24) 个令牌，将该值设为该模式下的令牌产生速率，宏REDITS_PER_JIFFY 的值为 128(0x1000)。 12#define MAX_CPJ (0xFFFFFFFF / (HZ*60*60*24))#define CREDITS_PER_JIFFY POW2_BELOW32(MAX_CPJ) 以字节为单位的限速模式下，通过应用层 iptables 工具能够设置的最低限速值为 1B/s（即每心跳 1/HZ 个字节），即每心跳消耗 0xFFFFFFFF/HZ 个令牌，将该值设为该模式下的令牌产生速率，宏 CREDITS_PER_JIFFY_BYTES 的值为 16777216(0x1000000)。 12#define MAX_CPJ_BYTES (0xFFFFFFFF / HZ)#define CREDITS_PER_JIFFY_BYTES POW2_BELOW32(MAX_CPJ_BYTES) 1.3.2 结论上面虽然对 hashlimit 模块使用到的令牌桶算法做了简要介绍，但是追踪分析源码能够发现如下结论：对于以字节为单位的限速模式： 令牌的产生速率是一定的，为 0x1000000/心跳 令牌桶的最大容量是一定的，为 0x1000000 * HZ（HZ 为系统每秒心跳数，K2P 路由器配置为 250） 每16个字节消耗的令牌数和用户配置的限速值 rate 成反比关系，为 0x1000000 * HZ / (rate / 16 + 1)。 允许数据包突发放行的次数为 burst / rate 向上取整的结果，突发每产生一次相应的值减 1，该值不会增加。 对于以包为单位的限速模式： 令牌的产生速率也是一定的，为 128/心跳 令牌桶的最大容量是不一定的，为根据用户配置的限速值 rate 和 突发值 burst 决定，(32000 / rate) * burst 每个包消耗的令牌数和用户配置的限速值 rate 也成反比关系，为32000 / rate。 2 源码解析对该模块的探究，最基本的需要了解的是 iptables 是应用层的，其实质仅仅是一个定义规则的配置工具，当中的核心工作，数据包的拦截、转发、修改是在 Netfiler 中实现。 因此，通过追踪用户空间 iptables 的相关源码和内核空间 netfilter 的相关源码来解析 hashlimit 模块功能，hashlimit 模块在限速上提供了两种模式，一种是以包为单位的限速，一种是以字节为单位的限速。本文主要沿着以字节为单位的限速模式进行解析。 2.1 用户空间iptables相关代码解析通过 xtables_register_matches 函数在用户空间的 iptables 中注册一个匹配模块，用户空间的 match 是用 struct xptables_match{} 结构来表示的，所以需要去实例化一个该对象，然后对其关键成员进行初始化赋值。一般情况需要实现 help 函数、print 和 save 函数、x6_fcheck 函数和 x6_parse 函数就可以满足基本要求了。 123456789101112131415161718192021static struct xtables_match hashlimit_mt_reg[] = &#123; &#123; .version = XTABLES_VERSION, .name = \"hashlimit\", .revision = 1, .family = NFPROTO_IPV4, .size = XT_ALIGN(sizeof(struct xt_hashlimit_mtinfo1)), .userspacesize = offsetof(struct xt_hashlimit_mtinfo1, hinfo), .help = hashlimit_mt_help, .init = hashlimit_mt4_init, .x6_parse = hashlimit_mt_parse, .x6_fcheck = hashlimit_mt_check, .print = hashlimit_mt4_print, .save = hashlimit_mt4_save, .x6_options = hashlimit_mt_opts, .udata_size = sizeof(struct hashlimit_mt_udata), &#125;, ... //其他协议类型如NFPROTO_UNSPEC、NFPROTO_IPV6&#125;xtables_register_matches(hashlimit_mt_reg, ARRAY_SIZE(hashlimit_mt_reg)); 模块定义了结构体 hashlimit_cfg1 来保存用户配置的规则参数，规则名保存在 xt_hashlimit_mtinfo1 结构体中的 name 成员中。 123456789101112131415161718192021struct hashlimit_cfg1 &#123; __u32 mode; /* bitmask of XT_HASHLIMIT_HASH_* */ __u32 avg; /* Average secs between packets * scale */ __u32 burst; /* Period multiplier for upper limit. */ /* user specified */ __u32 size; /* how many buckets */ __u32 max; /* max number of entries */ __u32 gc_interval; /* gc interval */ __u32 expire; /* when do entries expire? */ __u8 srcmask, dstmask;&#125;;struct xt_hashlimit_mtinfo1 &#123; char name[HASHLIMIT_NAMESIZE]; struct hashlimit_cfg1 cfg; /* Used internally by the kernel */ struct xt_hashlimit_htable *hinfo __attribute__((aligned(8)));&#125;; hashlimit_mt_help()：当我们在命令行输入 iptables -m hashlimit -h 时，用于显示该模块用法的帮助信息。 hashlimit_mt4_print()：当我们在命令行输入 iptables -L 时，该函数用于打印用户输入参数。往该函数中传入了一个 xt_entry_matc h的结构体，模块自定义的 xt_hashlimit_mtinfo1 数据存在这个结构体的data成员中。 hashlimit_mt4_save() 和 hashlimit_mt4_print() 类似。 hashlimit_mt_parse()：用于解析命令行参数的回调函数。 1234567891011121314151617181920212223242526272829303132333435363738394041static void hashlimit_mt_parse(struct xt_option_call *cb)&#123; struct xt_hashlimit_mtinfo1 *info = cb-&gt;data; xtables_option_parse(cb); switch (cb-&gt;entry-&gt;id) &#123; case O_BURST: #解析--hashlimit-burst参数，进行单位转化和合法性校验，可设置最大为 XT_HASHLIMIT_BURST_MAX b/s，配置 burst 值 info-&gt;cfg.burst = parse_burst(cb-&gt;arg, info); break; case O_UPTO: #解析--hashlimit-upto参数，后文中所述的 rate 值，配置 avg 值 if (cb-&gt;invert) info-&gt;cfg.mode |= XT_HASHLIMIT_INVERT; #进行单位转化，调用bytes_to_cost()函数，info-&gt;cfg.avg = 2^32 / (rate &gt;&gt; 4 + 1)，配置限速模式 if (parse_bytes(cb-&gt;arg, &amp;info-&gt;cfg.avg, cb-&gt;udata)) info-&gt;cfg.mode |= XT_HASHLIMIT_BYTES; #以包为单位限速模式，转化后为 SCALE / rate else if (!parse_rate(cb-&gt;arg, &amp;info-&gt;cfg.avg, cb-&gt;udata)) xtables_param_act(XTF_BAD_VALUE, \"hashlimit\", \"--hashlimit-upto\", cb-&gt;arg); break; case O_ABOVE: #解析--hashlimit-above参数，区别在于对 cb-&gt;invert 判断处理，需要点明的是 cfg.mode 初始化为 0 if (!cb-&gt;invert) info-&gt;cfg.mode |= XT_HASHLIMIT_INVERT; ...... #实现类似于 case O_UPTO case O_MODE: #解析--hashlimit-mode参数，配置匹配模式 if (parse_mode(&amp;info-&gt;cfg.mode, cb-&gt;arg) &lt; 0) xtables_param_act(XTF_BAD_VALUE, \"hashlimit\", \"--hashlimit-mode\", cb-&gt;arg); break; case O_SRCMASK: info-&gt;cfg.srcmask = cb-&gt;val.hlen; break; case O_DSTMASK: info-&gt;cfg.dstmask = cb-&gt;val.hlen; break; &#125;&#125; hashlimit_mt_check()：在调用本模块时，该函数做必须参数的有无校验，同时也对相应的数值范围做校验和转换。如本模块必须设置 –hashlimit-upto 或者 –hashlimit-above，设置的 burst 值一定要大于 avg 值。 123456789101112131415161718192021static void hashlimit_mt_check(struct xt_fcheck_call *cb)&#123; const struct hashlimit_mt_udata *udata = cb-&gt;udata; struct xt_hashlimit_mtinfo1 *info = cb-&gt;data; ...... if (info-&gt;cfg.mode &amp; XT_HASHLIMIT_BYTES) &#123; uint32_t burst = 0; if (cb-&gt;xflags &amp; F_BURST) &#123; ...... #重新配置 burst 值，保存 burst 值为输入 burst 值除输入 avg 值的结果（向上取整） burst = info-&gt;cfg.burst; burst /= cost_to_bytes(info-&gt;cfg.avg); #此处调用 cost_to_bytes 和解析函数中的 bytes_to_cost 有对齐16字节整数倍的效果。 if (info-&gt;cfg.burst % cost_to_bytes(info-&gt;cfg.avg)) burst++; ...... &#125; info-&gt;cfg.burst = burst; &#125; else if (info-&gt;cfg.burst &gt; XT_HASHLIMIT_BURST_MAX) burst_error();&#125; 2.2 内核空间 netfilter 相关代码解析** 2.2.1 初始化模块注册 **内核中用 struct xt_match{} 结构来表示一个 match 模块。开发 match 的内核部分时，也必须去实例化一个 struct xt_match{} 对象，然后对其进行必要的初始化设置，最后通过 xt_register_matchs() 将其注册到 xt[AF_INET].match 全局链表中. 123456789101112131415static struct xt_match hashlimit_mt_reg[] __read_mostly = &#123; &#123; .name = \"hashlimit\", .revision = 1, .family = NFPROTO_IPV4, .match = hashlimit_mt, .matchsize = sizeof(struct xt_hashlimit_mtinfo1), .checkentry = hashlimit_mt_check, .destroy = hashlimit_mt_destroy, .me = THIS_MODULE, &#125;, ......&#125;;err = xt_register_matches(hashlimit_mt_reg, ARRAY_SIZE(hashlimit_mt_reg)); 2.2.2 核心match函数最关键的核心函数 hashlimit_mt()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static boolhashlimit_mt(const struct sk_buff *skb, struct xt_action_param *par)&#123; const struct xt_hashlimit_mtinfo1 *info = par-&gt;matchinfo; struct xt_hashlimit_htable *hinfo = info-&gt;hinfo; unsigned long now = jiffies; struct dsthash_ent *dh; struct dsthash_dst dst; bool race = false; u32 cost; #创建 dsthash_dst 结构体，并根据匹配模式从 skb 中获取源ip或端口号、目的ip或端口号 if (hashlimit_init_dst(hinfo, &amp;dst, skb, par-&gt;thoff) &lt; 0) goto hotdrop; rcu_read_lock_bh(); #根据 ip 地址查找 xt_hashlimit_htable 表中的 dsthash_dst 节点，获取该 ip 的配置信息 dh = dsthash_find(hinfo, &amp;dst); if (dh == NULL) &#123; #表中没有则创建，创建过程中会再次查找，防止其他进程创建，race标记再次查找的结果 dh = dsthash_alloc_init(hinfo, &amp;dst, &amp;race); if (dh == NULL) &#123; rcu_read_unlock_bh(); goto hotdrop; &#125; else if (race) &#123; /* Already got an entry, update expiration timeout */ dh-&gt;expires = now + msecs_to_jiffies(hinfo-&gt;cfg.expire); #其他进程创建的节点，则更新桶中令牌数 rateinfo_recalc(dh, now, hinfo-&gt;cfg.mode); &#125; else &#123; dh-&gt;expires = jiffies + msecs_to_jiffies(hinfo-&gt;cfg.expire); #本次创建的新节点，则初始化桶中令牌数，并根据设置的限速值设定令牌消耗单位 rateinfo_init(dh, hinfo); &#125; &#125; else &#123; /* update expiration timeout */ dh-&gt;expires = now + msecs_to_jiffies(hinfo-&gt;cfg.expire); #已有节点，则更新桶中令牌数 rateinfo_recalc(dh, now, hinfo-&gt;cfg.mode); &#125; if (info-&gt;cfg.mode &amp; XT_HASHLIMIT_BYTES) #计算当前数据包需要消耗的令牌数 cost = hashlimit_byte_cost(skb-&gt;len, dh); else cost = dh-&gt;rateinfo.cost; #如果当前桶中令牌数不少于该包消耗的令牌数则则返回 1，表示匹配成功，执行规则的目标动作 if (dh-&gt;rateinfo.credit &gt;= cost) &#123; /* below the limit */ dh-&gt;rateinfo.credit -= cost; spin_unlock(&amp;dh-&gt;lock); rcu_read_unlock_bh(); return !(info-&gt;cfg.mode &amp; XT_HASHLIMIT_INVERT); &#125; #如果当前桶中令牌数少于该包消耗的令牌数则返回 0，表示匹配不成功，继续匹配下条规则 spin_unlock(&amp;dh-&gt;lock); rcu_read_unlock_bh(); /* default match is underlimit - so over the limit, we need to invert */ return info-&gt;cfg.mode &amp; XT_HASHLIMIT_INVERT; hotdrop: par-&gt;hotdrop = true; return false;&#125; 2.2.3 令牌计算函数 令牌更新函数 12345678910111213141516171819202122232425262728static void rateinfo_recalc(struct dsthash_ent *dh, unsigned long now, u32 mode)&#123; unsigned long delta = now - dh-&gt;rateinfo.prev; u32 cap; if (delta == 0) return; dh-&gt;rateinfo.prev = now; if (mode &amp; XT_HASHLIMIT_BYTES) &#123; u32 tmp = dh-&gt;rateinfo.credit; #更新当前令牌数为剩余的令牌数加上这段时间产生的令牌数 dh-&gt;rateinfo.credit += CREDITS_PER_JIFFY_BYTES * delta; cap = CREDITS_PER_JIFFY_BYTES * HZ; if (tmp &gt;= dh-&gt;rateinfo.credit) &#123;/* overflow */ dh-&gt;rateinfo.credit = cap; return; &#125; &#125; else &#123; #更新当前令牌数为剩余的令牌数加上这段时间产生的令牌数 dh-&gt;rateinfo.credit += delta * CREDITS_PER_JIFFY; cap = dh-&gt;rateinfo.credit_cap; &#125; #桶中最大令牌数限制为 CREDITS_PER_JIFFY_BYTES * HZ 或者 32000 * burst / rate if (dh-&gt;rateinfo.credit &gt; cap) dh-&gt;rateinfo.credit = cap;&#125; 令牌初始化函数 123456789101112131415161718192021static void rateinfo_init(struct dsthash_ent *dh, struct xt_hashlimit_htable *hinfo)&#123; dh-&gt;rateinfo.prev = jiffies; if (hinfo-&gt;cfg.mode &amp; XT_HASHLIMIT_BYTES) &#123; #初始化当前令牌数为桶中最大令牌数，CREDITS_PER_JIFFY_BYTES * HZ，即0x1000000 * 250 dh-&gt;rateinfo.credit = CREDITS_PER_JIFFY_BYTES * HZ; #初始化16个字节的令牌消耗单位为 0x1000000 * 250 / (rate &gt;&gt; 4 + 1)，消耗单位和设置的限速值成反比 dh-&gt;rateinfo.cost = user2credits_byte(hinfo-&gt;cfg.avg); #初始化允许突发次数为 burst(设置的 burst 值除设置的限速值的结果) dh-&gt;rateinfo.credit_cap = hinfo-&gt;cfg.burst; &#125; else &#123; #以包为单位限速模式，转化后为 (SCALE / SCALE_kernel) * (HZ * 128 * burst / rate)，默认为32000 * burst / rate dh-&gt;rateinfo.credit = user2credits(hinfo-&gt;cfg.avg * hinfo-&gt;cfg.burst); #初始化令牌消耗单位为 32000 /rate dh-&gt;rateinfo.cost = user2credits(hinfo-&gt;cfg.avg); #初始化最大令牌数为 32000 * burst / rate dh-&gt;rateinfo.credit_cap = dh-&gt;rateinfo.credit; &#125;&#125; 令牌消耗函数 123456789101112131415161718static u32 hashlimit_byte_cost(unsigned int len, struct dsthash_ent *dh)&#123; #以包为单位来判定去留，计算当前包的16字节长度为 tmp = len &gt;&gt; 4 + 1 u64 tmp = xt_hashlimit_len_to_chunks(len); #计算该包需要消耗的令牌数约为 ( len &gt;&gt; 4 + 1 ) / (rate &gt;&gt; 4 + 1) * 0x1000000 * 250 tmp = tmp * dh-&gt;rateinfo.cost; #如果该包消耗的令牌数大于桶中最大数 if (unlikely(tmp &gt; CREDITS_PER_JIFFY_BYTES * HZ)) #该种处理方法会导致设置低限速值限制不了大包数据的问题，因为 1s 会允许放行一次大包 tmp = CREDITS_PER_JIFFY_BYTES * HZ; #如果该包消耗的令牌数大于桶中当前令牌数，且当前允许突发次数大于 0，则当作突发数据包处理，突发次数减 1 if (dh-&gt;rateinfo.credit &lt; tmp &amp;&amp; dh-&gt;rateinfo.credit_cap) &#123; #以包为单位限速模式， dh-&gt;rateinfo.credit_cap--; dh-&gt;rateinfo.credit = CREDITS_PER_JIFFY_BYTES * HZ; &#125; return (u32) tmp;&#125; 2.2.4 校验check函数123456789101112131415161718192021222324static int hashlimit_mt_check(const struct xt_mtchk_param *par)&#123; struct net *net = par-&gt;net; struct xt_hashlimit_mtinfo1 *info = par-&gt;matchinfo; int ret; ...... if (info-&gt;cfg.mode &amp; XT_HASHLIMIT_BYTES) &#123; #设置的限速值 rate 令牌消耗单位为 0x1000000 * 250 / (rate &gt;&gt; 4 + 1) &lt; 1 时则溢出，该 rate &gt; 0x1000000 * 250 *16 if (user2credits_byte(info-&gt;cfg.avg) == 0) &#123; pr_info(\"overflow, rate too high: %u\\n\", info-&gt;cfg.avg); return -EINVAL; &#125; &#125; else if (info-&gt;cfg.burst == 0 || user2credits(info-&gt;cfg.avg * info-&gt;cfg.burst) &lt; user2credits(info-&gt;cfg.avg)) &#123; #设置的 burst 值要大于 1 pr_info(\"overflow, try lower: %u/%u\\n\", info-&gt;cfg.avg, info-&gt;cfg.burst); return -ERANGE; &#125; ...... #proc文件相关 mutex_unlock(&amp;hashlimit_mutex); return 0;&#125;"}],"posts":[{"title":"奇妙恩典","slug":"心记/20191211心记","date":"2019-12-11T00:00:00.000Z","updated":"2019-12-11T00:00:00.000Z","comments":true,"path":"2019/12/11/心记/20191211心记/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2019/12/11/心记/20191211心记/","excerpt":"","text":"距离上次记录考科三，已经过了近半个月。主要原因是上次科三挂了一次，然后10天后才能预约考试。昨天刚考完科三，过了。很奇妙。 上次科三挂了，具体情况是这样。周一（11.25）早上6点多起床，然后打车60元到驾校，7:30左右去模拟6号线，然后快11点回到驾校。这么长时间的一个原因是车上4人，有一人模拟8号线，中途车没油了，然后下雨，天气特别冷，瑟瑟发抖。然后等了好长时间。早上模拟出错的地方就是转弯一档时间过长，导致扣十分。另外从模拟车的教练口中依稀记得靠边停车应该留10公分，路口实线踩一次刹车，上车后需要1分钟内打火。11点多进入考场。等到1点多钟考试，比预期的时间更长。当时都有点困了。然后考1号线，第一个。第一次机会，紧张，打火后脚一直踩着离合和刹车，左脚一直抖个不停，完成灯光模拟，没走100米提示上传成绩，不知道是啥原因失败。考试结束后才知道，由于公交站踩刹车过早，导致判断说未减速，失败。第二次，因前面已经紧张，灯光模拟扣了5分（远光灯打成远近交替，唯一扣5分的，其他直接扣100分），之后谨慎，路口，车站等多踩刹车。加了三次5档，只剩最后一个靠边停车。当拉起手刹是，上传成绩，考试不合格85分。等待10天，再次约考。 昨天考试，早晨5点10分起床，整晚睡的不怎么好，5:30左右到驾校，直接去模拟8号线，天空黑呜呜一片，雾气弥漫。模拟顺利，6点40左右回到驾校。存包准备排队采指纹。存包时投入一元，竟然显示投币0元，当时大脑闪过去找服务人员理论，大脑又快速想了想，还是算了，有什么证据能证明我投币了，另外和别人理论半天有啥用，安静心情，换一个柜子投币，存包。排队准备采指纹近考场。指纹采集后，等待。所以人都采完之后过了一会，开始近待考区，排在17领取随机数，打印时间07:03:58或07:03:59或其他，反正是07:03，然后一直看着屏幕显示陆续有好多人进来，差不多40多人，后面有进来一些人。差不多70人待考时。快八点钟，然后开始根据报号上车。差不多十几辆车。剩20多个人待考。我依旧待考。然后有进来人，待考人差不多有40多人。时间在过去，内心在紧张，不断祷告，安静自己的心。除去一切骄傲，紧张。一直有感觉似乎要等待着什么，要准备着心态去面对什么，是两次机会，第一次机会没了，还是要第一个考。待考区不断有人进入考试。人数不断减少差不多剩16个左右。这之前一直看着显示器，心理默祷。心很平稳，知道快到自己了。随后自己编号出现了，第三个考，上车看了一下线路7，懵了。然后还在想是不是每个人的线路不一样，随后又有人说7号线，坏了。这下清楚，大家都是7号线。自己从来没跑过这条线，咋办，不断求告神的帮助。安静自己的心。自己不是第三个，既然自己认为自己技术可以，那剩下了就只需要记路线了。接下来，有发生尴尬的事情，第一个也没跑过这条线，然后两下挂了。小伙很失落，说师傅我不上车了，我自己回驾校。安全员说不行，必须一起回去，刚好，仪器上传数据比较慢，安全员说要不我开回去看看啥情况，正好这个时间我问其他人那是公交站，线路如何，大脑有一点印象。但还是不够清楚。有小伙还说现在给你说也没用，我坚决说不一定，因为我知道考试不是靠自己，乃是考万军之耶和华。人的考虑的，所做的都是有不足，智者千虑必有一失。靠着自己不行，但靠着万军之耶和华方能成事。接下来一方面去认真记线路，一方面安静心，除去紧张，除去抱怨。既然自己没跑过，那就当平时训练一下。静静地看着别人，顺便问问身旁的小伙，他也很好，告诉我那块是学校，那块加5档，直行，等等。第二个小伙快到终点时因对面来车，在人行横道掉头，导致停车压斑马线时间长一次机会没了，第二次有因变道忘关转向灯。挂了。整个线路没有完整跑下来。还有两项，超车和靠边停车。自己已经把前面的公交站和人行横道等记得很清楚。接下来就是慢下心来小心操作，靠主得胜。一路慢慢开，遇见公交站踩，人行横道踩。中途误操作挂错档位，迅速停车，调整心态，过学校加5档，直行ok，接下来就是要超车了，过红绿灯，本来在慢车道，因对面有车停在路边（慢车道），只能变道快车道，然后停下来，准备再次回到慢车道，此时系统提醒，驶离快车道，迅速驶离快车道。然后完成超车操作，后面不只在何处掉头。然后就想不管如何先到快车道再说，然后慢慢行驶。此时系统报前面掉头，然后看到路口，一切明白了。刚强壮胆去行。掉头，前行等待靠边停车指令，缓慢进入，停车，然后又调整一下靠边位置，空挡手刹，准备解安全带时，想起好像还要熄火，迅速踩下离合，刹车熄火。解安全带，看反光镜，下车，等待成绩结果，过了一段时间显示成绩合格。顺利过关。 一切并没有结束，幸福来的太突然，就会想是不是真的过了，再想到底是怎么过的，一句话神的恩典和祝福。接下来我还在默默祈祷，为帮助我的小伙子。因为后面是他考试，操作很流畅。然而再公交车站突然熄火，导致一次机会没了，原因是档位与速度问题，发动机熄火各扣10分，重头来。我心里默默祷告神，你帮助他，他虽然不认识你，但是你借着他帮助了你孩子，求你也帮助他。第二次前面公交车顺利通过，然后在中途加5档，因速度未到5档扣10分，我不停的默祷，求神帮助，后面顺利完成。90分通过考试。 整个考试，真的是神的恩典和祝福。没有神的帮助，自己什么也做不了。在神做工的同时，也在考验我们对他的信心。让我们不仅经历他，而且是我们成功。耐心等候，预备道路，不断寻求。祂没有一下子去让我面临7号线，而是熬炼人心。没有一下子告诉我完整路线，而是让我去继续不断寻求他。让我明天是祂帮助我，而不是人帮助，是祂借着人，祂掌管一切。真的感谢主，不仅经历你的大能，而且让你孩子能为你作那美好见证。慢慢的明白第一次考科三，是有神的旨意在，祂是为了让孩子更加经历祂的信实和大能。 var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":3,\"mode\":\"random\",\"music\":[{\"title\":\"你是荣耀的君王\",\"author\":\"David\",\"url\":\"/audio/你是荣耀的君王 - David.mp3\",\"pic\":\"\",\"lrc\":\"/audio/你是荣耀的君王 - David.lrc\"}]}; options.element = document.getElementById(\"aplayer-qtoRcXJG\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","categories":[{"name":"心记","slug":"心记","permalink":"http://Flipped205.github.io/BlogCode/categories/心记/"}],"tags":[]},{"title":"谢耳朵猜想","slug":"心记/20191122发现","date":"2019-11-22T00:00:00.000Z","updated":"2019-11-22T00:00:00.000Z","comments":true,"path":"2019/11/22/心记/20191122发现/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2019/11/22/心记/20191122发现/","excerpt":"","text":"《谢耳朵猜想被证明：No.73最美丽》 《生活大爆炸》中谢耳朵对73数字情有独钟，并且认为这个素数是最优美的;其原因是73是第21个素数，并且7*3=21；不止如此，他还发现素数37是第12个素数。基于谢耳朵特别喜欢73，其穿也印有73； 73的特征有两方面： 73是第21个素数，且 7*3 = 21其镜像对称37刚好是第12个素数。 73（21）《==》（21）37 为什么谢耳朵喜欢73而不是37，其原因是3*7=21 而不是12。 最近有数学家在论文中正式提出“谢耳朵猜想”，并尝试在寻找类似的素数。并将满足该条件的素数，成为希尔顿素数。详细内容:《环球科技》 var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":3,\"mode\":\"random\",\"music\":[{\"title\":\"The Big Bang Theory Theme\",\"author\":\"Barenaked Ladies\",\"url\":\"/audio/The Big Bang Theory Theme - Barenaked Ladies.mp3\",\"pic\":\"/audio/The Big Bang Theory.jpg\",\"lrc\":\"/audio/The Big Bang Theory Theme - Barenaked Ladies.lrc\"}]}; options.element = document.getElementById(\"aplayer-UsXyCbBt\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 随想：看到这篇文章时，突然想我，作为程序猿的自己，密码的设计是不是也得有个特殊的数字。反正我的密码和名字有关。","categories":[{"name":"心记","slug":"心记","permalink":"http://Flipped205.github.io/BlogCode/categories/心记/"}],"tags":[{"name":"文章","slug":"文章","permalink":"http://Flipped205.github.io/BlogCode/tags/文章/"}]},{"title":"前路迷茫，心存希望","slug":"心记/20191121心记","date":"2019-11-21T00:00:00.000Z","updated":"2019-11-21T00:00:00.000Z","comments":true,"path":"2019/11/21/心记/20191121心记/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2019/11/21/心记/20191121心记/","excerpt":"","text":"看到标题，比较清晰，看似清晰，实则模糊。前路迷茫，心存希望，其实应该还有下一句不知所措，浑浑噩噩。其实后半句也不一定是这样的。仿佛自己告诉自己心有余而力不足。何力不足，却又不是，而是太懒。 为什么会出现上面这句话，最近的稍微静了下来，人一静就开始思考，一思考就有压力。前不久读了篇文章。35岁的老员工，被优化，走前是公司小主管。长达120天的求职，缺不知所措。一个大厂没收。小企业对他评头论脚。 看到这个消息，顺便看了评论，有人说，自己能力不行，还嫌弃别人对自己挑剔。也有人同情说，不久自己也会到该年龄，对其怜悯。不管恶语还是同情，值得思考，35岁确实比较尴尬的年龄。或许能力或许环境，等等因素。但终归现实如此。而自己该如何做呢？应该扣心自问。 毕业4年，辗转3家，除去校招，两次经历面试。一个感觉广而不精，非他所需。知道的很多，却没有几样很深，企业不想培养。为什么会出现此现状，恶性循环，廉价劳动力。不通用。没时间挖深。有时大企业的确好，管理培等等。身边都是牛人，随处可学。没有这样环境怎么办。个人规划又当如何。 专攻方向算法，Linux，Python。 算法:leetcode。从头来，锻炼思维。 Linux:往下沉，更深入。 Python:跟上技术发展，多思维模式。 var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":3,\"mode\":\"random\",\"music\":[{\"title\":\"海阔天空\",\"author\":\"beyond\",\"url\":\"/audio/海阔天空 - BEYOND.mp3\",\"pic\":\"/audio/beyond.jpg\",\"lrc\":\"/audio/海阔天空 - BEYOND.lrc\"}]}; options.element = document.getElementById(\"aplayer-ANMoybHB\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","categories":[{"name":"心记","slug":"心记","permalink":"http://Flipped205.github.io/BlogCode/categories/心记/"}],"tags":[]},{"title":"shell脚本","slug":"笔记/10 shell脚本","date":"2019-11-21T00:00:00.000Z","updated":"2020-02-24T10:05:01.783Z","comments":true,"path":"2019/11/21/笔记/10 shell脚本/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2019/11/21/笔记/10 shell脚本/","excerpt":"","text":"shell脚本中切换目录 1234!#/bin/bash/pwdcd ./../pwd 执行脚本 1234567//可执行权限$ chmod a+x 1.sh//执行脚本$ ./1.sh$//查看当前位置$ pwd 之后会发现第二个pwd和第一个pwd，不一样，且第二个明显已经回到上一级目录，但是当前的目录还是没有改变。这种完全没有达到我们想要的目的，该怎么办呢。具体如下: 1234$ source ./1.sh$$$ pwd 通过使用source，发现当前位置已发生改变。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Flipped205.github.io/BlogCode/categories/笔记/"}],"tags":[{"name":"shell脚本","slug":"shell脚本","permalink":"http://Flipped205.github.io/BlogCode/tags/shell脚本/"}]},{"title":"无聊","slug":"心记/20191115心记","date":"2019-11-15T00:00:00.000Z","updated":"2019-11-15T00:00:00.000Z","comments":true,"path":"2019/11/15/心记/20191115心记/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2019/11/15/心记/20191115心记/","excerpt":"","text":"距离上一次更新博客，快四个多月了，这段时间发生了很多事情。大部分都是开心😊的事情，所以中间也有一些麻烦和闹心。但都挺好不管是过程还是结果。都挺愉快。这段时间主要是考科二，结婚，转正。10月4号结婚，结婚前由于我和我老婆两个人把很多事情想的比较简单，导致发生了一些沟通不当导致的不愉快，最后还是顺顺利利，感谢主，感谢弟兄姐妹，还有父母，家人，亲戚，邻里。他们都帮了很多忙。双方父母的操劳，亲戚的忙前忙后。太辛苦他们了。有时真的感觉自己有些不太懂事。不愿意去做，去说。也许这是人需要的一些成长。不擅长人际关系，但往往你在这个生活圈内，你需要去和别人沟通，说话等等。整个婚礼挺完美，一直担心天气等等，感谢主，接完老婆，不久后才下的雨。热热闹闹，非常愉快开心。 可能有一点点小的遗憾就是，我两人没有婚假，导致整个十一紧张而忙碌的度过。没能好好陪她出去旅游，没有一个蜜月旅游。在此应该记录下来，一定要带她出去玩玩。 驾照，距上一次科二失利后，不久又考了一次，顺利通过，十一前科三也学了很久，由于结婚前太多事，就没去考，一直拖到11月才考试练了几次。打算下下周一，顺利通过，求主帮助。不希望在这个事情浪费太多时间和精力。 工作，三个月的适应期已经结束，已经成为正式员工，入职快四个月了，也是上次博客更新时间。这四个月工作不算忙碌，没有太多事情。不太忙碌，感觉有些安逸。这一周突然有很强力的学习欲望。或自我约束，觉得自己不应该这样，应该自我充实一下，练练算法，沉沉底。好好做个学习计划，让自己的脑子动一动。每天进步一点点，循序渐进。前几天看到哥分享一盘文章”给大脑挂个外置硬盘”，既做笔记。记录每天都干了啥。人的遗忘性比较强，它对事情只会记录最触及的一点。一件事情，它只会记录一小段，剩下的就需要外部记录。当回放时大脑却会迅速想起很多细节，很神奇。由于以上的自我刺激和约束。所以又重新开始内心的记录。这次尝试在手机上做心记，因为这样可以随时随地，立刻去写。但是还是不清楚是否便捷方便。就看这篇文章能够发出去不，嘿嘿。最后来一首最近听的比较顺耳的歌曲”你的酒馆对我打了烊”。 var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":3,\"mode\":\"random\",\"music\":[{\"title\":\"你的酒馆对我打了烊\",\"author\":\"陈雪凝\",\"url\":\"/audio/你的酒馆对我打了烊_陈雪凝.mp3\",\"pic\":\"/audio/陈雪凝.png\",\"lrc\":\"/audio/你的酒馆对我打了烊_陈雪凝.lrc\"}]}; options.element = document.getElementById(\"aplayer-fXVHFVxk\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","categories":[{"name":"心记","slug":"心记","permalink":"http://Flipped205.github.io/BlogCode/categories/心记/"}],"tags":[]},{"title":"等待","slug":"心记/20190721心记","date":"2019-07-21T00:00:00.000Z","updated":"2019-07-21T00:00:00.000Z","comments":true,"path":"2019/07/21/心记/20190721心记/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2019/07/21/心记/20190721心记/","excerpt":"","text":"上周，一直在等待之前面试结果，原以为会有自己想去的公司，没想到没任何消息，上周没怎么刷简历，没想到周四学完车之后有两家约面试，然后这周也不想刷简历，周一刚好通知，上周六的面试通过。说是下周三入职，需要走流程，周三发offer。这周就相对比较轻松，休息休息，周五体个检，办张卡。等候入职。周天，丈母娘生日，吃顿了顿烤肉，好久没在外面吃饭了，挺香，滋润，舒坦。 当你放下面子赚钱的时候，说明你已经懂事了。当你用钱赚回面子的时候，说明你已经成功了。当你用面子可以赚钱的时候，说明你已经是人物了。当你还停留在那里喝酒、吹牛，啥也不懂还装懂，只爱所谓的面子的时候，说明你这辈子也就这样了。 var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":3,\"mode\":\"random\",\"music\":[{\"title\":\"农夫渔夫\",\"author\":\"大乔小乔\",\"url\":\"/audio/农夫渔夫-大乔小乔.mp3\",\"pic\":\"/audio/大乔小乔.png\",\"lrc\":\"/audio/农夫渔夫-大乔小乔.txt\"},{\"title\":\"等待戈多\",\"author\":\"林力尧\",\"url\":\"/audio/等待戈多-林力尧.mp3\",\"pic\":\"/audio/林力尧.png\",\"lrc\":\"/audio/等待戈多-林力尧.txt\"}]}; options.element = document.getElementById(\"aplayer-MhbcEJJX\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","categories":[{"name":"心记","slug":"心记","permalink":"http://Flipped205.github.io/BlogCode/categories/心记/"}],"tags":[]},{"title":"求职","slug":"心记/20190714心记","date":"2019-07-14T00:00:00.000Z","updated":"2019-07-14T00:00:00.000Z","comments":true,"path":"2019/07/14/心记/20190714心记/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2019/07/14/心记/20190714心记/","excerpt":"","text":"周一面试了一下想去的这家公司，总体聊的还行，聊下来感觉，就是自己工作这几年一直没有把技术挖深，技术广而不深，知道很多，什么都会一点。但是往深挖一点，就不太行了。可能是之前的工作有关，一直做的比较偏应用，还有自己的原因导致没有去深挖。最近的几次面试觉得，自己两个方向发展：mcu、linux。mcu这块的需要学习的东西，熟悉一些系统，还有一些无线模块（蓝牙，zigbee）。linux这块多了，内存管理，内存分配，系统调用等等。这家面试感觉挺好，hr聊的过程中，有些表达太过了。过于表现自己想来。晚上和老婆聊天，本想说说面试上的一些事情，想听听建议，却闹的情绪不好。她最近也比较累。刚进新的公司，工作比较忙，下班比较晚，没能去陪她，还惹她不开心。哎，心疼。 周二面试，聊下来的感觉就是需要的技术偏向于mcu，个人之前接触的太少，而且接触的都是比较low的芯片，目前很少用，算职位不匹配没事。下午刷了刷简历，感觉没啥好公司，烦躁。刷视频，堕落。周三想着看看书，静静心。早上起来却刷了刷视频。然后把博客重新整理的一下，新增了音乐和视频的内容。 一个人需要追求的品质生活到底是什么？最重要的其实在与一个人对生活的态度，你既要有接受最好的一切的能力，也要有面对最坏的坦然心态。 周三堕落一天，晚上吃完饭，心情不是特别好，然后就是出门瞎溜达，散散心，减减肉。烦躁不安，周四要考科目二，过于紧张不安，工作也没着落，心情不爽。 周四考科目二，一晚上没怎么睡好，很紧张😓，一大早去练了练车，10点结束一直到下午2点半才考试，然后挂了，第一次，倒车入库，直接懵逼，后面无任何心理走完全程，自我感觉良好。第二次，坡道后遛。倒车入库ok，感觉良好，然后过于骄傲，坡道直接后遛。归根结底，就是车不好。下午回家，接到面试通知，周六面试，因周六学车，然后约的2点半面试。 周五醒的很早，然后无意间刷到《明日之子》，有些收益，每个人都去进行一次面试表演，与面试官的交流，有的话多，有的紧张，该说的和不该说的，都去说。让自己感觉之前的面试就有些话痨，太过于暴露自己，应该三思二后行。下午两点多，突然说是有面试，不到两小时的地铁，冒雨去面试，坐汽车仪表盘，算是跨行业，需要学的东西比较多。技术和hr面试还行。 周六面试，技术面感觉一般，面试官打断自我介绍，纠结无关紧要的东西，然后还在玩手机。hr面试聊了很多。一周下来，工作没有着落，车也没过，但是心理有些释放。一年的难处一天当，不必为明天担忧，你无法去决定明天会发生什么，也无妨预料，何必给自己那么大的压力。 var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":3,\"mode\":\"random\",\"music\":[{\"title\":\"凡事都有神的美意\",\"author\":\"属天音乐事工\",\"url\":\"/audio/凡事都有神的美意-属天音乐事工.mp3\",\"pic\":\"/audio/属天音乐事工.png\",\"lrc\":\"/audio/凡事都有神的美意-属天音乐事工.lrc\"}]}; options.element = document.getElementById(\"aplayer-oNVltVtg\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","categories":[{"name":"心记","slug":"心记","permalink":"http://Flipped205.github.io/BlogCode/categories/心记/"}],"tags":[]},{"title":"失业调整","slug":"心记/20190707心记","date":"2019-07-07T00:00:00.000Z","updated":"2019-07-07T00:00:00.000Z","comments":true,"path":"2019/07/07/心记/20190707心记/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2019/07/07/心记/20190707心记/","excerpt":"","text":"最近离职，突然有个想法，近一年的工作，自己一直是比较安逸，自从上次博客更新，这一年内都没怎么更新，一直让自己的心静不下来，总是觉得自己脑子很累，不想去思考任何事，好不容易最近空闲下来，想着自己可以好好写点东西，让自己的生活不这么混乱。有个新的打算，开始每周的一个心记，记录一周中自己的想法，遇见的人，遇见的事，生活等等。正好今天有空，睡了半天，感觉自己有些无聊，闲着也是闲着，就写来玩玩。 上周五被告知离职，周五匆忙收拾了东西，整理了一下电脑，自己的东西带走走人，因一些手续没有办完，所以这周又去了一天半，周二处理完离职手续，中午回来在家睡了一觉，傍晚起来吃了点饭，刷刷视频，刷刷工作，收到个面试通知，想着第二天看看书，因为这一年来，一直做的是mcu这块的东西，linux相关忘的差不多了，而且面试这家，大部分和linux相关，周三起来，收拾了厨房，因为长时间偶尔在老婆家，陪老婆，时不时回来一次就是吃饭，睡觉。因此房间一直很乱，没时间收拾，正好这段时间收拾收拾。下午看了会技术书，比较烦躁，就想着写点东西。 这周面试三家公司，第一家面试感觉下来，linux的一些专业知识有些忘记了，socket和dhcp交互过程，tcp/ip等。技术面试感觉一般，hr面试觉得本人不太愿意加班。第二家笔试题简单，面试官技术一般，hr没怎么聊。第三家，由于是外包公司，主要是技术面，就大题介绍了一下个人的工作经历，总体感觉还行。hr由于忙，未聊，说是电话联系谈薪资。下周一有家面试，有些想去。所以最近一直没怎么刷简历。 周末学车，模拟了一下场地，感觉还行，正好最近比较空闲，想着下周四考科目二，希望能一次过。周末感觉还是过的比较忙，去老婆家陪陪她，感觉挺放松的，就是回来比较累。早上在老婆家看了本书《生活需要仪式感》原本以为这本书是讲的如何去享受生活，让平凡普通的生活过的不平凡。然后却不是，而是一种真正的去对待生活。做一件事情认真去做，不要让自己懒惰下来。不要总是说自己很忙，脑子很乱，心里压力很大。去看个电影，吃顿好吃的，放松一下。其实自己应该学会约束自己。需要动起来，去看书，做事情，整理家务。而不是自以为的放松，其实那种更累，心脑更加混乱。 专心做一件事，无论干什么，都应该全身心的去投入其中。 一些的开始，从点滴做起。凡事都是很简单，只是你愿不愿意，让其形成一种习惯。做正确有意（有益）的事，你就不会感觉自己很累。不会拖延。 var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":3,\"mode\":\"random\",\"music\":[{\"title\":\"静下来\",\"author\":\"大乔小乔\",\"url\":\"/audio/静下来-大乔小乔.mp3\",\"pic\":\"/audio/大乔小乔.png\",\"lrc\":\"/audio/静下来-大乔小乔.txt\"}]}; options.element = document.getElementById(\"aplayer-KZFMVkkx\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","categories":[{"name":"心记","slug":"心记","permalink":"http://Flipped205.github.io/BlogCode/categories/心记/"}],"tags":[]},{"title":"Linux系统开发环境搭建","slug":"笔记/0aLinux开发环境搭建","date":"2019-06-18T00:00:00.000Z","updated":"2019-06-18T00:00:00.000Z","comments":true,"path":"2019/06/18/笔记/0aLinux开发环境搭建/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2019/06/18/笔记/0aLinux开发环境搭建/","excerpt":"","text":"&emsp;&emsp;经常使用linux系统(Ubuntu),默认都会安装一些软件，方便开发。记录一下常用的一些软件配置和开发环境搭建。包括samba,ssh,tmux等 一、PS1修改PS1 1vi ~/.bashrc 添加以下内容 1PS1=\"╔║$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[1;35m\\]\\w\\[\\033[00m\\]\\n╚═&gt;&gt;\" 二.vim,bundle1234sudo apt-get install vimsudo apt-get install gitsudo apt-get install ctagsgit clone https://github.com/gmarik/vundle.git ~/.vim/bundle/Vundle.vim 新建文件.vimrc 1vim ~/.vimrc 添加以下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153set nuset ts=4set noexpandtab%retab!set listset listchars=tab:&gt;-,trail:-set listchars=tab:&gt;-,trail:-set tags=tags;\" 定义快捷键的前缀，即&lt;Leader&gt;let mapleader=\";\"\" 开启文件类型侦测filetype on\" 根据侦测到不同类型加载对应插件filetype plugin on\" 定义快捷键到行首和行尾nmap LB 0nmap LE $\" 设置快捷将选中文本块复制到系统剪贴板vnoremap &lt;Leader&gt;y \"+y\" 设置快捷键将系统剪贴板内容粘贴至vimnmap &lt;Leader&gt;p \"+p\" 定义快捷键关闭当前分割窗口nmap &lt;Leader&gt;q :q&lt;CR&gt;\" 定义快捷键保存当前窗口内容nmap &lt;Leader&gt;w :w&lt;CR&gt;\" 定义快捷键保存所有窗口内容并退出vimnmap &lt;Leader&gt;WQ :wa&lt;CR&gt;:q&lt;CR&gt;\" 不做任何保存，直接退出nmap &lt;Leader&gt;Q :qa!&lt;CR&gt;\" 依次遍历子窗口nnoremap nw &lt;C-W&gt;&lt;C-W&gt;\" 跳转至右方窗口nnoremap &lt;Leader&gt;lw &lt;C-W&gt;l\" 跳转至左方窗口nnoremap &lt;Leader&gt;hw &lt;C-W&gt;h\" 跳转至上方窗口nnoremap &lt;Leader&gt;kw &lt;C-W&gt;k\" 跳转至下方窗口nnoremap &lt;Leader&gt;jw &lt;C-W&gt;j\" 定义快捷键在结对符之间跳转nmap &lt;Leader&gt;M %\" 开启实时搜索功能set incsearch\" 搜索时大小写不敏感set ignorecase\" 关闭兼容模式set nocompatible\" vim 自身命令行模式智能补全set wildmenu\" 将外部命令 wmctrl 控制窗口最大化的命令行参数封装成一个 vim 的函数fun! ToggleFullscreen() call system(\"wmctrl -ir \" . v:windowid . \" -b toggle,fullscreen\")endf\" 全屏开/关快捷键map &lt;silent&gt; &lt;F11&gt; :call ToggleFullscreen()&lt;CR&gt;\" 启动 vim 时自动全屏autocmd VimEnter * call ToggleFullscreen()\"总是显示状态栏set laststatus=2\" 显示光标当前位置set ruler\" 高亮当前行/列set cursorline\"set cursorcolumn\" 高亮显示搜索结果set hlsearch\" 禁止折行set nowrap\" 开启语法高亮功能syntax enable\" 允许用指定语法高亮配色方案替换默认方案syntax on\" 自适应不同语言的只能缩进filetype indent on\" vundle 环境设置filetype offset rtp+=~/.vim/bundle/Vundle.vim\" vundle管理的插件列表必须位于vundle#begin()和vundle#end()之间call vundle#begin()Plugin 'taglist.vim'Bundle 'majutsushi/tagbar'Plugin 'OmniCppComplete'Plugin 'AutoComplPop'Plugin 'a.vim'Bundle 'gabrielelana/vim-Markdown'Bundle 'iamcco/Markdown-preview.vim'\" MarkdownBundle 'jszakmeister/Markdown2ctags'\" Add support for Markdown files in tagbar.let g:tagbar_type_Markdown = &#123; \\ 'ctagstype': 'Markdown', \\ 'ctagsbin' : '/home/***/.vim/bundle/Markdown2ctags/Markdown2ctags.py', \\ 'ctagsargs' : '-f - --sort=yes', \\ 'kinds' : [ \\ 's:sections', \\ 'i:images' \\ ], \\ 'sro' : '|', \\ 'kind2scope' : &#123; \\ 's' : 'section', \\ &#125;, \\ 'sort': 0,\\ &#125;let g:Markdown_enable_spell_cheking=0let g:Markdown_enable_mappings=0\" 插件列表结束call vundle#end()filetype plugin indent onlet Tlist_Show_One_File=1let Tlist_Exit_OnlyWindow=1\" 设置tagbar使用的ctags的插件，必须要设置对let g:tagbar_ctags_bin='/usr/bin/ctags'\" 设置tagbar的窗口宽度let g:tagbar_width=30\" 设置tagbar的窗口显示的位置，为右边let g:tagbar_left=1\" 打开文件自动 打开tagbarautocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc,*.cxx call tagbar#autoopen()set nocompatibleset backspace=indent,eol,startset completeopt=longest,menu\" 头文件/源文件切换 nnoremap &lt;silent&gt; &lt;F12&gt; :A&lt;CR&gt;\" 切换至光标所在文件nnoremap &lt;silent&gt; &lt;F11&gt; :IHV&lt;CR&gt; autocmd BufWritePost $MYVIMRC source $MYVIMRCset nopasteset noautoindentset nosmartindent 随后使用安装插件 12vim:BundleInstall 三、tmux12sudo apt-get install tmuxvim ~/.tmux.conf 添加以下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105####################### general######################set -g xterm-keys onset -g display-panes-time 3000set -g base-index 1set -g pane-base-index 1set -g mouse-resize-pane onset -g mouse-select-pane onset -g mouse-select-window onset -g pane-active-border-fg whiteset -g pane-active-border-bg whiteset -g pane-border-fg blueset -g pane-border-bg blacksetw -g mode-mouse onbind r source-file ~/.tmux.conf \\; display-message \"Config reloaded...\"set -g renumber-windows onset -g history-limit 20000# it is terrible for using vimset -g escape-time 0####################### status bar######################set -g status-position bottomset -g status onset -g status-bg colour103set -g status-fg colour232set -g status-key viset -g status-interval 1set -g status-utf8 onset -g status-justify \"centre\"set -g status-left-length 60set -g status-right-length 90set -g status-left \"#(~/.tmux-pl-src/powerline.sh left)\"'#&#123;?client_prefix, #[reverse bold] PREFIX , &#125;'set -g status-right \"#(~/.tmux-pl-src/powerline.sh right)\"setw -g window-status-current-bg colour15setw -g window-status-current-fg colour124setw -g window-status-current-attr italics,boldsetw -g window-status-current-format ' #I 'setw -g window-status-format ' #I '####################### vim######################setw -g mode-keys vibind -t vi-copy v begin-selectionbind -t vi-copy y copy-selectionbind -t vi-copy = end-of-linebind -t vi-copy - start-of-line####################### general key map######################set -g repeat-time 1500set -g prefix M-eunbind-key C-bbind M-e send-prefixbind -n M-2 display-panesbind -n M-3 command-prompt \"select-window -t :'%%'\"bind -n M-Right next-windowbind -n M-Left previous-windowbind -n M-\\ last-windowbind -n M-= new-window -c \"#&#123;pane_current_path&#125;\"bind -n M-- kill-windowbind -n M-x kill-panebind -n M-c copy-modebind -n M-] paste-bufferbind c new-windows -c \"#&#123;pane_current_path&#125;\"bind _ split-window -v -c \"#&#123;pane_current_path&#125;\"bind | split-window -h -c \"#&#123;pane_current_path&#125;\"bind '\"' select-layout tiledbind -r h select-layout main-horizontal \\; swap-pane -Dbind -r v select-layout main-vertical \\; swap-pane -Dbind -n F1 save-buffer -b 0 ~/.sdbuf \\; run \"cat ~/.sdbuf | sdcv\"bind k select-pane -U #选择上窗口bind j select-pane -D #选择下窗口bind h select-pane -L #选择左窗口bind l select-pane -R #选择右窗口# rename windowsetw -g automatic-rename onset-window-option -g window-status-format '#[dim]#I:#[default]#W#[fg=grev,dim]'set-window-option -g window-status-current-format '#[fg=red,bold]#I#[fg=red]:#[fg=red]#W#[fg=dim]'#List of pluginsset -g @plugin 'tmux-plugins/tpm'set -g @plugin 'tmux-plugins/tmux-sensible'set -g @plugin 'tmux-plugins/tmux-resurrect'# tmux-resurrectset -g @resurrect-save-bash-history 'on'set -g @resurrect-capture-pane-contents 'on'set -g @resurrect-strategy-vim 'session'set -g @resurrect-save 'S'set -g @resurrect-restore 'R'#Initialize TMUX plugin manager (keep this line at the bottom)bind K kill-serverrun '~/.tmux/plugins/tpm/tpm' tmux常用操作 123456789alt+e #快捷前缀 prefixprefix new #新建会话prefix s #列出会话，切换会话prefix $ #重命名会话prefix | #分割窗口prefix c #新建窗口prefix num #切换窗口prefix , #重命名窗口exit #退出 其他快捷键，查看配置 四、samba,ssh12sudo apt-get install samba samba-commonsudo vim /etc/samba/smb.conf 添加以下内容 123456[test] path = /home/test valid users = test browseable = yes writable = yes public = no 为此用户test设置密码 1sudo smbpasswd -a test 重启服务器 1sudo /etc/init.d/samba restart","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Flipped205.github.io/BlogCode/categories/笔记/"}],"tags":[{"name":"samba","slug":"samba","permalink":"http://Flipped205.github.io/BlogCode/tags/samba/"},{"name":"ssh","slug":"ssh","permalink":"http://Flipped205.github.io/BlogCode/tags/ssh/"},{"name":"tmux","slug":"tmux","permalink":"http://Flipped205.github.io/BlogCode/tags/tmux/"}]},{"title":"Gerrit服务器的搭建与使用","slug":"笔记/08Gerrit服务器搭建","date":"2019-05-31T00:00:00.000Z","updated":"2019-05-31T00:00:00.000Z","comments":true,"path":"2019/05/31/笔记/08Gerrit服务器搭建/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2019/05/31/笔记/08Gerrit服务器搭建/","excerpt":"","text":"一、前期准备1、java12345sudo add-apt-repository ppa:openjdk-r/ppasudo apt-get updatesudo apt-get install openjdk-8-jdk 2、git1sudo apt-get install git 3、apache2123sudo apt-get install apache2sudo /etc/init.d/apach2 start #是否可正常启动 4、下载gerritgerrit.2.15.2百度盘 提取码：otlq官方下载地址 二、搭建Gerrit1、新建用户使用独立的账户，来配置gerrit 1sudo adduser gerrit 将gerrit加入到sudo权限 12sudo chmod 777 /etc/sudoerssudo vim /etc/sudoers 添加下面一句 1gerrit ALL=(ALL:ALL)ALL 切换用户为gerrit 1su gerrit 2、安装gerrit1java -jar gerrit.2.15.2.war init --batch --dev -d ~/gerrittest 出现Starting Gerrit Code Review: OK，表示Gerrit服务正在运行。 3、反向代理3.1、修改gerrit配置vim gerrittest/etc/gerrit.config:修改为以下内容192.168.40.130为本机ip地址，通过ifconfig可查看 1234567891011121314151617181920212223242526272829303132[gerrit] basePath = git serverId = c5447167-daf0-49e2-a79f-e154d0841461 canonicalWebUrl = http://192.168.40.130:8081/ # 修改为ip:8081[database] type = h2 database = /home/gerrittest/gerrit/db/ReviewDB[noteDb \"changes\"] disableReviewDb = true primaryStorage = note db read = true sequence = true write = true[index] type = LUCENE[auth] type = HTTP #DEVELOPMENT_BECOME_ANY_ACCOUNT # 修改为HTTP[receive] enableSignedPush = false[sendemail] smtpServer = localhost[container] user = gerrittest javaHome = /usr/lib/jvm/java-8-oracle/jre[sshd] listenAddress = *:29418[httpd] listenUrl = proxy-http://192.168.40.130:8081/ # 修改proxy-http://ip:8081[cache] directory = cache[plugins] allowRemoteAdmin = true 3.2 Apacge2配置需要使能必要的Apache2模块： 123a2enmod proxy_httpa2dissite 000-defaulta2enmod ssl ; # 可选，HTTPS或SSL需要 sudo vim /etc/apache2/apache2.conf最后面，添加一下内容： 123456789101112131415161718192021222324&lt;VirtualHost *:8080&gt; ServerName 192.168.40.130 ProxyRequests Off ProxyVia Off ProxyPreserveHost On &lt;Proxy *&gt; Require all granted &lt;/Proxy&gt; &lt;Location \"/\"&gt; AuthType Basic AuthName \"Gerrit Code Review\" Require valid-user AuthBasicProvider file AuthUserFile /etc/apache2/passwords &lt;/Location&gt; AllowEncodedSlashes On ProxyPass / http://192.168.40.130:8081/ nocanon ProxyPassReverse / http://192.168.40.130:8081/ nocanon ErrorLog /var/log/apache2/gerrit.error.log CustomLog /var/log/apache2/gerrit.access.log combined&lt;/VirtualHost&gt; sudo vim /etc/apache2/ports.conf添加： 1Listen 8080 3.3 设置Gerrit账户和密码123sudo touch /etc/apache2/passwordssudo htpasswd -b /etc/apache2/passwords admin 123456 # administratorsudo htpasswd -b /etc/apache2/passwords gerrit1 123456 # general usr 启动gerrit &amp; apache2 12sudo ~/gerrittest/bin/gerrit.sh restartsudo /etc/init.d/apache2 restart 4、使用Gerrit使用浏览器登录http:192.168.40.130:8080登录admin 登录成功后，该用户为管理员 1、SSH登录123cd ssh-keygen -t rsa #生成ssk key cat ~/.ssh/id_rsa.pub #查看ssh key 1ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDBlBpZtMRBI/O077EM0fqrhUrzCRP7yxLMrSfKXMO2BK5pb5ITnnyiEMdurxo31iD9uaF3y/+Yr/H8K4IRtBdHM4ZQseAqmz9Z/X7Q97PkrI8rwocIbs4BUSYap2j/lUzHGcRdzYGR/8XpXCSIwO4OFjsBJZluOKpuNNJUq8o5ZAS7NTQTi83JwgiKQrByuUYPpVqzgf6RGEI0lmesLxRNIbA5FMxfDuKyPIGPvuz4BRayREcwdkeBrJyKVgQf16lPlvJxzCOgnY01xsdCMXEF5Ri2MLYfysYlhehs+UCabLwmTi+Xpe3ioDOe6YnYx7QQzvi/YuXXew8SYwRGKxod gerrit@ubuntu 使用其他浏览器登录gerrit1账户 验证ssh key是否配置成功 1ssh gerrit1@192.168.40.130 -p 29418 出现下面内容表示成功： 12345678910 **** Welcome to Gerrit Code Review **** Hi gerrit1, you have successfully connected over SSH. Unfortunately, interactive shells are disabled. To clone a hosted Git repository, use: git clone ssh://gerrit1@192.168.40.130:29418/REPOSITORY_NAME.gitConnection to 192.168.40.130 closed. 2、添加项目使用admin账户，在gerrit管理页面进行添加账户 3、代码修改拉取代码 123mkdir codecd codegit clone ssh://gerrit1@192.168.40.130:29418/demo 更新git hooks 1gitdir=$(git rev-parse --git-dir); scp -p -P 29418 gerrit1@192.168.40.130:hooks/commit-msg $&#123;gitdir&#125;/hooks/ 123echo \"init code\"&gt;ReadMe.txt # 创建新文件git add ReadMe.txt # 添加新文件git commit -m \"init code commit\" git commit出错，提示需要设置user.email,user.name这里需要注意，先设置gerrit.config的sendemail 1vim ~/gerrittest/etc/gerrit.config 修改sendemail 123456789[sendemail] enable = true smtpServer = smtp.163.com smtpServerPort = 465 smtpEncryption = ssl smtpUser = 【邮箱账号】 smtpPass = 【授权密码】 #授权密码 sslVerify = false from = 【邮箱账号】 1vim ~/gerrittest/etc/secure.config 添加sendemail 12[sendemail] smtpPass = 【授权密码】 之后重启gerrit，apache 12~/gerrittest/bin/gerrit.sh restart/etc/init.d/apache2 restart 随后设置gerrit1的user.email,user.name 12git config --global user.email \"gerrit205@163.com\"git config --global user.name \"gerrit1\" 12git commitgit push origin HEAD:refs/for/master git push出现错误,这里需要gerrit1登录gerrit管理页面，设置name和email 随后会收到通过gerrit.config中添加的邮箱发送的邮件，复制收到的链接，在gerrit1所登录的浏览器，进行验证。随后就可看到上图中显示的邮箱。 随后通过admin将gerrit1添加到Administrators组: 之后重新git push 1git push origin HEAD:refs/for/master 成功如下： 12345678910Counting objects: 3, done.Writing objects: 100% (3/3), 284 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)remote: Processing changes: new: 1, done remote: remote: New Changes:remote: http://192.168.40.130:8081/#/c/demo/+/21 init code commitremote: To ssh://gerrit1@192.168.40.130:29418/demo * [new branch] HEAD -&gt; refs/for/master 通过gerrit1进入gerrit管理页面 添加Reviewers gerrit1整个代码就提交完成了，剩下的就是Reviewers人员进行代码评审和入库。这里是admin用户进行入库 整个代码就入库完成。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Flipped205.github.io/BlogCode/categories/笔记/"}],"tags":[{"name":"Gerrit","slug":"Gerrit","permalink":"http://Flipped205.github.io/BlogCode/tags/Gerrit/"}]},{"title":"Gerrit服务器的搭建与使用","slug":"笔记/09Gerrit服务器搭建","date":"2019-05-31T00:00:00.000Z","updated":"2019-05-31T00:00:00.000Z","comments":true,"path":"2019/05/31/笔记/09Gerrit服务器搭建/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2019/05/31/笔记/09Gerrit服务器搭建/","excerpt":"","text":"一、前期准备1、java12345sudo add-apt-repository ppa:openjdk-r/ppasudo apt-get updatesudo apt-get install openjdk-8-jdk 2、git1sudo apt-get install git 3、apache2123sudo apt-get install apache2sudo /etc/init.d/apach2 start #是否可正常启动 4、下载gerritgerrit.2.15.2百度盘 提取码：otlq官方下载地址 二、搭建Gerrit1、新建用户使用独立的账户，来配置gerrit 1sudo adduser gerrit 将gerrit加入到sudo权限 12sudo chmod 777 /etc/sudoerssudo vim /etc/sudoers 添加下面一句 1gerrit ALL=(ALL:ALL)ALL 切换用户为gerrit 1su gerrit 2、安装gerrit1java -jar gerrit.2.15.2.war init --batch --dev -d ~/gerrittest 出现Starting Gerrit Code Review: OK，表示Gerrit服务正在运行。 3、反向代理3.1、修改gerrit配置vim gerrittest/etc/gerrit.config:修改为以下内容192.168.40.130为本机ip地址，通过ifconfig可查看 1234567891011121314151617181920212223242526272829303132[gerrit] basePath = git serverId = c5447167-daf0-49e2-a79f-e154d0841461 canonicalWebUrl = http://192.168.40.130:8081/ # 修改为ip:8081[database] type = h2 database = /home/gerrittest/gerrit/db/ReviewDB[noteDb \"changes\"] disableReviewDb = true primaryStorage = note db read = true sequence = true write = true[index] type = LUCENE[auth] type = HTTP #DEVELOPMENT_BECOME_ANY_ACCOUNT # 修改为HTTP[receive] enableSignedPush = false[sendemail] smtpServer = localhost[container] user = gerrittest javaHome = /usr/lib/jvm/java-8-oracle/jre[sshd] listenAddress = *:29418[httpd] listenUrl = proxy-http://192.168.40.130:8081/ # 修改proxy-http://ip:8081[cache] directory = cache[plugins] allowRemoteAdmin = true 3.2 Apacge2配置需要使能必要的Apache2模块： 123a2enmod proxy_httpa2dissite 000-defaulta2enmod ssl ; # 可选，HTTPS或SSL需要 sudo vim /etc/apache2/apache2.conf最后面，添加一下内容： 123456789101112131415161718192021222324&lt;VirtualHost *:8080&gt; ServerName 192.168.40.130 ProxyRequests Off ProxyVia Off ProxyPreserveHost On &lt;Proxy *&gt; Require all granted &lt;/Proxy&gt; &lt;Location \"/\"&gt; AuthType Basic AuthName \"Gerrit Code Review\" Require valid-user AuthBasicProvider file AuthUserFile /etc/apache2/passwords &lt;/Location&gt; AllowEncodedSlashes On ProxyPass / http://192.168.40.130:8081/ nocanon ProxyPassReverse / http://192.168.40.130:8081/ nocanon ErrorLog /var/log/apache2/gerrit.error.log CustomLog /var/log/apache2/gerrit.access.log combined&lt;/VirtualHost&gt; sudo vim /etc/apache2/ports.conf添加： 1Listen 8080 3.3 设置Gerrit账户和密码123sudo touch /etc/apache2/passwordssudo htpasswd -b /etc/apache2/passwords admin 123456 # administratorsudo htpasswd -b /etc/apache2/passwords gerrit1 123456 # general usr 启动gerrit &amp; apache2 12sudo ~/gerrittest/bin/gerrit.sh restartsudo /etc/init.d/apache2 restart 4、使用Gerrit使用浏览器登录http:192.168.40.130:8080登录admin 登录成功后，该用户为管理员 1、SSH登录123cd ssh-keygen -t rsa #生成ssk key cat ~/.ssh/id_rsa.pub #查看ssh key 1ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDBlBpZtMRBI/O077EM0fqrhUrzCRP7yxLMrSfKXMO2BK5pb5ITnnyiEMdurxo31iD9uaF3y/+Yr/H8K4IRtBdHM4ZQseAqmz9Z/X7Q97PkrI8rwocIbs4BUSYap2j/lUzHGcRdzYGR/8XpXCSIwO4OFjsBJZluOKpuNNJUq8o5ZAS7NTQTi83JwgiKQrByuUYPpVqzgf6RGEI0lmesLxRNIbA5FMxfDuKyPIGPvuz4BRayREcwdkeBrJyKVgQf16lPlvJxzCOgnY01xsdCMXEF5Ri2MLYfysYlhehs+UCabLwmTi+Xpe3ioDOe6YnYx7QQzvi/YuXXew8SYwRGKxod gerrit@ubuntu 使用其他浏览器登录gerrit1账户 验证ssh key是否配置成功 1ssh gerrit1@192.168.40.130 -p 29418 出现下面内容表示成功： 12345678910 **** Welcome to Gerrit Code Review **** Hi gerrit1, you have successfully connected over SSH. Unfortunately, interactive shells are disabled. To clone a hosted Git repository, use: git clone ssh://gerrit1@192.168.40.130:29418/REPOSITORY_NAME.gitConnection to 192.168.40.130 closed. 2、添加项目使用admin账户，在gerrit管理页面进行添加账户 3、代码修改拉取代码 123mkdir codecd codegit clone ssh://gerrit1@192.168.40.130:29418/demo 更新git hooks 1gitdir=$(git rev-parse --git-dir); scp -p -P 29418 gerrit1@192.168.40.130:hooks/commit-msg $&#123;gitdir&#125;/hooks/ 123echo \"init code\"&gt;ReadMe.txt # 创建新文件git add ReadMe.txt # 添加新文件git commit -m \"init code commit\" git commit出错，提示需要设置user.email,user.name这里需要注意，先设置gerrit.config的sendemail 1vim ~/gerrittest/etc/gerrit.config 修改sendemail 123456789[sendemail] enable = true smtpServer = smtp.163.com smtpServerPort = 465 smtpEncryption = ssl smtpUser = 【邮箱账号】 smtpPass = 【授权密码】 #授权密码 sslVerify = false from = 【邮箱账号】 1vim ~/gerrittest/etc/secure.config 添加sendemail 12[sendemail] smtpPass = 【授权密码】 之后重启gerrit，apache 12~/gerrittest/bin/gerrit.sh restart/etc/init.d/apache2 restart 随后设置gerrit1的user.email,user.name 12git config --global user.email \"gerrit205@163.com\"git config --global user.name \"gerrit1\" 12git commitgit push origin HEAD:refs/for/master git push出现错误,这里需要gerrit1登录gerrit管理页面，设置name和email 随后会收到通过gerrit.config中添加的邮箱发送的邮件，复制收到的链接，在gerrit1所登录的浏览器，进行验证。随后就可看到上图中显示的邮箱。 随后通过admin将gerrit1添加到Administrators组: 之后重新git push 1git push origin HEAD:refs/for/master 成功如下： 12345678910Counting objects: 3, done.Writing objects: 100% (3/3), 284 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)remote: Processing changes: new: 1, done remote: remote: New Changes:remote: http://192.168.40.130:8081/#/c/demo/+/21 init code commitremote: To ssh://gerrit1@192.168.40.130:29418/demo * [new branch] HEAD -&gt; refs/for/master 通过gerrit1进入gerrit管理页面 添加Reviewers gerrit1整个代码就提交完成了，剩下的就是Reviewers人员进行代码评审和入库。这里是admin用户进行入库 整个代码就入库完成。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Flipped205.github.io/BlogCode/categories/笔记/"}],"tags":[{"name":"Gerrit","slug":"Gerrit","permalink":"http://Flipped205.github.io/BlogCode/tags/Gerrit/"}]},{"title":"进程","slug":"笔记/09进程","date":"2018-09-03T00:00:00.000Z","updated":"2020-02-24T10:05:01.783Z","comments":true,"path":"2018/09/03/笔记/09进程/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/09/03/笔记/09进程/","excerpt":"","text":"ID为0的进程通常是调用进程，常被称为交换进程。还进程是内核的一部分，不执行任何磁盘上的程序，因此称为系统进行。ID为1通常是init进程，在自举过程结束时由内核调用。ID为2时页守护进程，负责虚拟存储器系统的分页操作 子进程继承父进程的属性： 共享文件： 父进程的所有打开文件描述符都被复制到子进程中 实际用户ID、实际组ID、有效用户ID、有效组ID 附属组ID 进程组ID 会话ID 设备用户ID标志和设备组ID标志 当前工作目录 根目录 文件模式创建屏蔽字 信号屏蔽和安排 对任一打开文件描述符的执行时关闭（close-on-exec）标志 环境 连接的共享存储段 存储映射 资源限制 子进程和父进程的区别： fork的返回值不同 进程ID不同 两个进程的父进程ID不同：子进程的父进程ID时创建它的进程ID，而父进程的的父进程ID则不变 子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0 子进程不继承父进程设置的文件锁 子进程的未处理闹钟被清楚。 子进程的未处理信号集设备为空寂。 fork的两种用法：-（1）、父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中时常用的–父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求。-（2）、一个进程要执行一个不同的程序。这对shell是常见的情况。在这种情况下，子进程从fork返回后立即调用exec 某些操作系统将第2中用法的两个操作（fork之后执行exec）组合成一个操作，吃呢各位spawn。unix系统将这两个操作分析，因为在很多场合需要单独使用fork，其后并不是跟随exec。另外，将这两个操作分开，使得子进程在fork和exec之间可以更改自己的属性，如I/O重定向，用户ID、信号安排等。 vforkexit_exit 当一个进程正常或异常终止时，内核就会想起父进程发生SIGCHLD信号。因为子进程终止是异步事件（这可以在父进程允许的任何时候发生） exec","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Flipped205.github.io/BlogCode/categories/笔记/"}],"tags":[{"name":"进程控制","slug":"进程控制","permalink":"http://Flipped205.github.io/BlogCode/tags/进程控制/"}]},{"title":"线程","slug":"笔记/07线程","date":"2018-08-22T00:00:00.000Z","updated":"2018-08-22T00:00:00.000Z","comments":true,"path":"2018/08/22/笔记/07线程/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/08/22/笔记/07线程/","excerpt":"","text":"线程同步 互斥量：确保同一时间只有一个线程访问数据 读写锁：同一时间只有一个线程写数据，允许多个线程同时读数据 条件变量：确保线程的先后顺序 自旋锁：用于cpu的占用较少 屏障 如何使用多个控制线程在单独环境中执行多个任务。一个进程中的所有线程都可以访问该进程的组成部件（文件描述符和内存）。 1、简化处理异步事件的code,每个线程在进程事件处理时可以采用同步编程模式。2、多个线程自动地可以访问相同地址的存储地址空间就和文件描述符。3、问题分解从而提高程序的吞吐量。多线程任务交叉进行。4、交互的程序同样可以通过使用多线程来改善想要时间，多线程可以吧程序中处理用户输入输出的部分与其他部分分开。 每个线程都包含有表示执行环境所必须的信息，其中包括进程中表示线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序代码、程序的全局内存和堆内存、栈以及文件描述符。 线程ID线程ID。pthread_t数据类型表示。不能把它作为整数处理。必须使用函数来对两个线程ID进行比较 1234#include &lt;pthread.h&gt;int pthread_equal(pthread_t tid1, pthread_t tid2);// 返回值：若相等，返回非0数值；否则，返回。 线程中通过调用pthread_self函数获取自身的线程ID 1234#include &lt;pthread.h&gt;pthread_t pthread_self(void);//返回值：调用线程的线程ID 线程创建每一个进程只有一个控制线程。新增的线程可以通过调用pthread_cerate函数创建 12345#include &lt;pthread.h&gt;int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg );// 返回值：若成功，返回0,；否则，返回错误编号 当pthread_create成功返回时，新创建线程的线程ID会被设备成tidp指向的内存单元。attr参数用于定制各种不同的线程属性。当前可设置为NULL,创建一个具有默认属性的线程。新创建的线程从start_rtn函数的地址开始运行，该函数只有一个屋类型指针参数arg,如果需要向start_rtn函数传递的参数有一个以上，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为arg参数传入。 线程创建时并不能保证那个线程会先运行：是新创建的线程，还是调用线程。先创建的线程可以访问进程的地址空间，并且集成调用线程的浮点环境和信号屏蔽字，但是该线程的挂起信号集会被消除。pthread函数在调用失败时通常会返回错误码errno，每个线程都会提供errno的副本。 例子： 打印线程ID： 进程ID、新线程的线程ID以及出事线程的线程ID. 123456789101112131415161718192021222324252627282930313233343536373839// pthread_test1.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;pthread_t ntid;void printids(const char *s)&#123; pid_t pid; pthread_t tid; pid = getpid(); tid = pthread_self(); printf(\"%s pid %lu tid %lu (0x%lx)\\n\",s,(unsigned long)pid, (unsigned long)tid, (unsigned long)tid);&#125;void *thr_fn(void *agr)&#123; printids(\"new thread:\"); return ((void *)0);&#125;int main(void)&#123; int err; err = pthread_create(&amp;ntid, NULL,thr_fn, NULL); if(err!=0) &#123; printf(\"can't create thread,err:%d\\n\",err); &#125; printids(\"main thread:\"); sleep(1); exit(0);&#125; 12gcc pthread_test1.c -l pthread./a.out 线程终止如果进程中任意线程调用exit、_Exit和_exit，那么整个进程就会终止。单个进程可以通过3中方式退出，因此可以在不终止整个进程的情况下，停止它的控制流：（1）、线程可以简单地从启动例程中返回，返回值是线程的退出码。（2）、线程可以被同一进程中的其他线程取消。（3）、线程调用pthread_exit 12#include &lt;pthread.h&gt;void pthread_exit(void *rval_ptr) rval_ptr参数是一个无类型指针，与传给启动例程的单个参数类似。进程中其他线程也可以通过调用pthread_join函数访问到这个指针。 1234#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **rval_ptr);//返回值：若成功，返回0；否则，返回错误编号 调用线程将会一直阻塞，直到指定的线程调用pthread_exit、从启动例程中返回或者被取消。如果线程简单地从它的启动例程返回，rval_ptr就包含返回码。如果线程被取消，由rval_ptr指定的内存单元就设备为PTHREAD_CANCELED。调用pthread_join自动把线程置于分离状态，这样资源就可以恢复。如果线程已经处于分离状态，pthread_join调用就会失败，返回EINVAL。如果对线程的返回值不感兴趣，可以把rval_ptr设置为NULL。这种情况调用pthread_join函数可以等待指定的线程终止，但并不获取线程的终止状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;void *thr_fn1(void *agr)&#123; printf(\"thread 1 returning\\n\"); return ((void *)1);&#125;void *thr_fn2(void *agr)&#123; printf(\"thread 2 exiting\\n\"); pthread_exit((void *)2);&#125;int main(void)&#123; int err; pthread_t tid1,tid2; void *tret; err = pthread_create(&amp;tid1, NULL, thr_fn1, NULL); if(err!=0) printf(\"can't create thread 1\\n\"); err = pthread_create(&amp;tid2, NULL, thr_fn2, NULL); if(err!=0) printf(\"can't create thread 2\\n\"); err = pthread_join(tid1, &amp;tret); if(err!=0) printf(\"can't join with thread 1\\n\"); printf(\"thread 1 exit code %ld\\n\",(long)tret); err = pthread_join(tid2, &amp;tret); if(err!=0) printf(\"can't join with thread 2\\n\"); printf(\"thread 2 exit code %ld\\n\",(long)tret); exit(0);&#125; 以下程序给出了用自动变量（分配在栈上）作为pthread_exit的参数时出现问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;struct foo&#123; int a,b,c,d;&#125;;void printfoo(const char *s,const struct foo *fp)&#123; printf(\"%s\", s); printf(\" structure at 0x%lx\\n\",(unsigned long)fp); printf(\" foo.a = %d\\n\", fp-&gt;a); printf(\" foo.b = %d\\n\", fp-&gt;b); printf(\" foo.c = %d\\n\", fp-&gt;c); printf(\" foo.d = %d\\n\", fp-&gt;d);&#125;void *thr_fn1(void *agr)&#123; struct foo foo=&#123;1,2,3,4&#125;; printfoo(\"thread 1:\\n\", &amp;foo); pthread_exit((void *)&amp;foo);&#125;void *thr_fn2(void *agr)&#123; printf(\"thread 2 ID is %lu\\n\", (unsigned long)pthread_self()); pthread_exit((void *)0);&#125;int main(void)&#123; int err; pthread_t tid1,tid2; struct foo *fp; err = pthread_create(&amp;tid1, NULL, thr_fn1, NULL); if(err!=0) printf(\"can't create thread 1\\n\"); err = pthread_join(tid1, (void *)&amp;fp); if(err!=0) printf(\"can't join with thread 1\\n\"); sleep(1); printf(\"parent starting second thread\\n\"); err = pthread_create(&amp;tid2, NULL, thr_fn2, NULL); if(err!=0) printf(\"can't create thread 2\\n\"); sleep(1); printfoo(\"parent:\\n\",fp); exit(0);&#125; 线程可以通过pthread_cancel函数来请求取消同一进程中的其他线程。 1234#include &lt;pthread.h&gt;int pthread_cancel(pthread_t tid);//返回值：如成功，返回0；否则，返回错误编码。 注意：pthead_cancel并不等待线程终止，它仅仅提出请求。线程可以安排它退出时需要调用的函数，这样的函数称为线程清理处理程序（thread cleanup handler）。一个线程可以建立朵儿清理处理程序。处理程序记录在栈中，也就是说，它们的执行顺序与它们注册时相反。 1234#include &lt;pthread.h&gt;void pthread_cleanup_push(void (*rtn)(void *), void *arg);void pthread_cleanup_pop(int execute); 线程同步两个或多个线程在同一时间修改同一变量时，也需要进行同步，增量操作通常分解为以下3步：（1）、从内存单元读入寄存器。（2）、在寄存器中对变量做增量操作。（3）、把新的值写回内存单元。 1、互斥量（mutex）本质上为一把锁。互斥变量是用pthead_nutex_t数据类型表示的。在使用互斥变量以前，必须首先对它进行初始化，可以把它设置为常量PTHREAD_MUTEX_INITIALIZER(只适用于静态分配的互斥量)。也可以通过调用pthread_mutex_init函数进行初始化。如果是动态分配互斥量（例如：malloc函数），在是否内存前需要调用pthread_mutex_destory。 123456#include &lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restict attr);int pthread_mutex_destroy(pthread_mutex_t *mutex);//两个函数的返回值：若成功，返回0；否则，返回错误编号 使用默认的属性初始化互斥量，只需把attr设为NULL。 对互斥量进行加锁。需要调用pthread_mutex_lock。如果互斥量已经上锁，调用线程将阻塞直到互斥量被解锁。对互斥量解锁，需要调用pthread_mutex_unlock. 123456789#include &lt;pthread.h&gt;int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex);// 所有函数的返回值：若成功，返回0；否则，返回错误编号 如果线程不希望被阻塞，它可以使用pthread_mutex_trylock尝试对互斥量进行加锁。如果调用pthread_mutex_trylock时互斥量处于未锁定状态，那么pthread_mutex_trylock将锁住互斥量，不会出现阻塞直接返回0，否则pthread_mutex_trylock就会失败，不能锁住互斥量，返回EBUSY。 避免死锁使用多个互斥量时导致死锁。需要以相同顺序加锁，这样可以避免死锁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#define NHASH 29#define HASH(id) (((unsigned long)id)%NHASH)struct foo *fh[NHASH];pthread_mutex_t hashlock = PTHREAD_MUTEX_INITIALIZER;struct foo&#123; int f_count; pthread_mutex_t f_lock; int f_id; struct foo *f_next;&#125;;struct foo *foo_malloc(int id)&#123; struct foo *fp; int idx; if ((fp = malloc(sizeof(struct foo)))!= NULL)&#123; fp-&gt;f_count = 1; fp-&gt;f_id = id; if(pthread_mutex_init(&amp;fp-&gt;f_lock, NULL)!=0)&#123; free(fp); return (NULL); &#125; idx = HASH(id); pthread_muext_lock(&amp;hashlock); fp-&gt;f_next = fh[idx]; fh[idx] = fp; pthread_mutex_lock(&amp;fp-&gt;f_lock); pthread_mutex_unlock(&amp;hashlock); pthread_mutex_unlock(&amp;fp-&gt;f_lock); &#125; return fp;&#125;void foo_hold(struct foo *fp) /* add a reference to the object */&#123; pthread_mutex_lock(&amp;fp-&gt;f_lock); fp-&gt;f_count++; pthread_mutex_unlock(&amp;fp-&gt;f_lock);&#125;struct foo *foo_find(int id)&#123; struct foo *fp; pthread_mutex_lock(&amp;hashlock); for (fp=fh[HASH(id)]; fp!=NULL; fp=fp-&gt;f_next)&#123; if (fp-&gt;f_id = id)&#123; foo_hold(fp); break; &#125; &#125; pthread_mutex_unlock(&amp;hashlock); return(fp);&#125; 上述例子看出,分配函数现在锁住了散列列表锁，把心得结构添加到看散列通中，而且在对散列列表的锁解锁之前，先锁定了新结构中的互斥量。因为新的结构是放在全局列表中的，其他线程可以找到它，所以在初始化完成之后，需要阻塞其他线程尝试访问心机构。foo_find函数锁住散列列表锁，然后所有被请求的结构，如果找到了就增加其引用计数，并返回指向该结构的指针。注意：加锁顺序，先在foo_find函数中锁定散列列表锁，然后再在foo_hole函数中锁定foo结构中的f_lock互斥量。 12345678910111213141516171819202122232425262728293031323334353637void foo_rele(struct foo *fp)&#123; struct foo *tfp; int idx; pthread_mutex_lock(&amp;fp-&gt;f_lock); if (fp-&gt;f_count == 1) &#123; pthread_mutex_unlock(&amp;fp-&gt;f_lock); pthread_mutex_lock(&amp;hashlock); pthread_mutex_lock(&amp;fp-&gt;f_lock); /* need to recheck the condition */ if (fp-&gt;f_count !=1)&#123; fp-&gt;f_count--; pthread_mutex_unlock(&amp;fp-&gt;f_lock); pthread_mutex_unlock(&amp;hashlock); return ; &#125; /*remove from list */ idx = HASH(fp-&gt;f_id); tfp = fh[idx]; if(tfp == fp)&#123; fh[idx] = fp-&gt;f_next; &#125;else&#123; while (tfp-&gt;f_next!=fp) tfp = tfp-&gt;f_next; tfp-&gt;f_next = fp-&gt;f_next; &#125; pthread_mutex_unlock(&amp;hashlock); pthread_mutex_unlock(&amp;fp-&gt;f_lock); pthread_mutex_destory(&amp;fp-&gt;f_lock); free(fp); &#125;else&#123; fp-&gt;fcount--; pthread_mutex_unlock(&amp;fp-&gt;f_lock); &#125;&#125; foo_rele函数就变得更加复杂，如果是最后一个引用，就需要对这个机构互斥量进行解锁，因为需要从散列表中删除这个结构，这样才可以获取散列表列表锁，然后重新获取结构互斥领。从上一次获取结构互斥量以来我们可能被阻塞着，所以需要重新检查条件，判断是佛还需要释放这个结构。如果另一个线程在我们为满足锁顺序而阻塞时发现了这个结构并对其引用计数+1，那么只需简单地对整个引用计数-1，对所有的东西解锁，然后返回。 上述锁的方式很复杂，需要重新设计，可以使用散列列表锁来保护结构引用计数，是事情大大简化。结构互斥量可以用于保护foo结构中的其他任何东西。如下： 123456789101112131415161718192021222324void foo_rele(struct foo *fp)&#123; struct foo *tfp; int idx; pthread_mutex_lock(&amp;hasklock); if(--fp-&gt;f_count==0)&#123; idx = HASH(fp-&gt;f_id); tfp = fh[idx]; if(tfp == fp)&#123; fh[idx]=fp-&gt;f_next; &#125; else &#123; while(tfp-&gt;f_next!=fp) tfp = tfp-&gt;f_next; tfp-&gt;f_next = fp-&gt;f_next; &#125; pthread_mutex_unlock(&amp;hashlock); pthread_mutex_destroy(&amp;fp-&gt;f_lock); free(fp); &#125;else &#123; pthread_mutex_unlock(&amp;hashlock); &#125;&#125; 3、函数pthread_mutex_timedlock当线程师徒获取一个已加锁的互斥量时，pthread_mutex_timedlock互斥量原语允许绑定线程阻塞时间。pthread_mutex_timedlock函数与pthread_mutex_lock时基本等就按的，但是在达到超时时间值时，pthread_mutex_timedlock不会对互斥量进行加锁，而是返回错误码ETIMEDOUT。 1234567#include &lt;pthread.h&gt;#include &lt;time.h&gt;int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict tsptr);// 返回值：若成功，返回0；否则，返回错误编号 4、读写锁读写锁（reader-writer lock）与互斥量类似，不过读写锁允许更高的并行性。互斥锁要么锁住状态、要么不加锁状态。而且一次只有一个线程可以对其加锁。读写锁可以有3种状态：读模式下加锁状态、写模式下加锁状态、不加锁状态。一次只有一个线程可以占有写模式下的读写锁，但是多个线程可以同时占有读模式的读写锁。读写锁，适用于读次数远大于写模式的情况。读写锁也叫共享互斥锁(shared-exclusiv lock) 1234567#include &lt;pthread.h&gt;int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);//函数返回值：若成功，返回0；否则，返回错误编号。 希望读写锁由默认的属性，可以传一个null指针给attr。 1234567#include &lt;pthread.h&gt;int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); //读模式下锁定读写锁int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); //写模式下锁定读写锁int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); //解锁//返回值：如成功,返回0; 否则，返回错误编号 5、带有超时的读写锁12345678910#include &lt;pthread.h&gt;#include &lt;time.h&gt;int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr);int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict tsptr);// 返回值：若成功，返回0；否则，返回错误编号 6、条件变量条件变量时线程可用的另一种同步机制。使用条件变量之前，必先对它进行初始化。由pthread_cond_t数据类型表示条件变量。两种方式初始化：1、把常量PTHREAD_COND_INITIALIZER赋给静态分配的条件变量。2、使用pthread_cond_init函数出事哈动态分配的条件变量。使用pthread_cond_destory函数对条件变量进行反初始化（deinitialize） 1234567#include &lt;pthread.h&gt;int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);int pthread_cond_destory(pthread_cond_t *cond);//返回值：若成功，返回0；否则，返回错误编号。 默认attr可以NULL。使用pthread_cond_wait等待条件变真。 123456789#include &lt;pthread.h&gt;int pthread_crond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);int pthread_crond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex const struct timespec *restrict tsptr);//返回值：若成功，返回0；否则，返回错误编号 获取超时的绝对值时间，可以使用以下函数： 12345678910111213#include &lt;sys/time.h&gt;#include &lt;stdlib.h&gt;void maketimeout(struct timespec *tsp, long minutes)&#123; struct timeval now; /* get the current time */ gettimeofday(&amp;now, NULL); tsp-&gt;tv_sec = now.tv_sec; tsp-&gt;tv_nesc = now.tv_usec*1000; // usec to nsec /* add the offset to get timeout value */ tsp-&gt;tv_esc += minutes *60;&#125; 超时到期时时间还没有出现，pthread_cond_timewait将重新获取互斥量，然后返回错误ETIMEDOUT。从pthread_cond_wait或pthread_cond_timedwait调用成功时，现充需要重新计算条件，因为另一个线程可能运行并改变了条件。 有两个函数可以用于通知线程条件已经满足。pthread_cond_signal函数至少能唤醒一个等待该条件的线程，而pthread_cond_broadcast函数则能唤醒等待该条件的所有线程。 12345#include &lt;pthread.h&gt;int pthread_cond_signal(pthrad_cond_t *crond);int pthread_cond_broadcast(pthrad_cond_t *cond);// 返回值：若成功，返回0；否则，返回错误编号。 以上函数为给线程或条件发信号。注意：一定要在改变条件状态以后再给线程发信号。 结合使用条件变量和互斥量对想成进行同步 12345678910111213141516171819202122232425262728293031#include &lt;pthread.h&gt;struct msg&#123; struct msg *next; /* ... more stuff here ... */&#125;struct msg *workq;pthread_cond_t qready = PTHREAD_COND_INITIALIZER;pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER;void process_msg(void)&#123; struct msg *mp; for(;;)&#123; pthread_mutex_lock(&amp;qlock); while(workq == NULL) pthread_cond_wait(&amp;qready, &amp;qlock); mp = workq; workq = mp-&gt;m_next; pthread_mutex_unlock(&amp;qlock); /* now process the message mp */ &#125;&#125;void enqueue_msg(struct msg *mp)&#123; pthread_mutex_lock(&amp;qlock); mp-&gt;m_next = workq; workq = mp; pthread_mutex_unlock(&amp;qlock); pthread_cond_signal(&amp;qready);&#125; 7、自旋锁获取锁之前一直处于忙等（自旋）阻塞状态。自旋锁用于以下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多的成本。初始化和反初始化 123456#include &lt;pthread.h&gt;int pthread_spin_init(pthread_spilock_t *lock, int pshared);int pthread_spin_destroy(pthread_spilock_t *lock);//返回值：若成功，返回0；否则，返回错误编号。 使用pthread_spin_lock或pthread_spin_trylock对自旋锁进行加锁，前者在获取锁之前一直咨询啊，后者如果不能获取锁，就会立即返回EBUSY错误，注意,pthread_spin_trylock不能自旋。不管以何种方式加锁，自旋锁都可以调用pthread_spin_unlock函数解锁。 123456#include &lt;pthread.h&gt;int pthread_spin_lock(pthread_spinlock_t *lock);int pthread_spin_trylock(pthread_spinlock_t *lock);int pthread_spin_unlock(pthread_spinlock_t *lock);返回值：若成功，返回0；否则，返回错误编号。 8、屏障屏障(barrier)时用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，知道所有的合作线程都到达某一点，然后从该点继续执行。pthread_join函数就是一种屏障，允许一个线程等待，直到另一个线程退出。但是屏障允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出。所有线程达到屏障后可以继续工作。 123456#include &lt;pthread.h&gt;int pthread_barrier_init(pthread_barrier_t *restrict barrier, const pthread_barrierattr_t *restrict attr, unsigned int count); // 为分配资源int pthread_barrier_destroy(pthread_barrier_t *barrier);// 返回值：若成功，返回0；否则，返回错误编号。 count指定允许所有线程运行之前，必须到达屏障的线程数目。attr参数指定屏障对象的属性。默认为NULL。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Flipped205.github.io/BlogCode/categories/笔记/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://Flipped205.github.io/BlogCode/tags/线程/"}]},{"title":"网站收藏","slug":"杂读/02网站收藏","date":"2018-08-01T00:00:00.000Z","updated":"2018-08-01T00:00:00.000Z","comments":true,"path":"2018/08/01/杂读/02网站收藏/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/08/01/杂读/02网站收藏/","excerpt":"","text":"转 视频网站慕课网 极客学院 前端开发手册菜鸟教程 w3school css参考手册 cssAnimate动画库 ie默认css htmlHTML5中国 HTML5基地 5+App JavaScriptMDN(JavaScript) JavaScript 秘密花园 JavaScript资源大全 JavaScript库JQuery Zepto AngularJS KISSYKISSY ExtJS JQueryjQuery中文文档 JQuery插件库 JQuery之家 jQuery Transit 动画库 JQueryFuns FullPage.js 移动框架Ionic]Ionic JQueryMobile 5+App Framework7 FrozenUI Mobile Angular UI 响应式框架Bootstrap Material-UI UIkit AmazeUI 博客社区社区W3Cfuns CSDN 博客园 伯乐在线 开源中国 图灵社区 异步社区 V2EX 博客阮一峰 张鑫旭 标点符 TG LP’s Blog 老左博客 小吴同学 大刘子 千思网 应用侠 工具在线工具开源在线编辑器推荐 Linux工具Windows工具IDM Sublime Text 龙卷风 文件合并助手 文件合并助手 IPOP4.1 WinSCP XCOM Chrome插件谷歌访问助手2.1.9 收趣 OneTab ColorZilla FeHelper Charset IDM ColorZilla 暴力猴 其他工具Synergy1.8.2 openzaly 电子书专业书籍看云 爱思源 脚本之家 其他书籍其他书伴 常用APP藏书馆 一个木函 时光相册 ES文件浏览器 夸克浏览器 不要音乐 AirDroid UBhind 流体手势 应用控制器 常用网站恩山无线论坛 21ic 移动叔叔","categories":[{"name":"杂读","slug":"杂读","permalink":"http://Flipped205.github.io/BlogCode/categories/杂读/"}],"tags":[{"name":"网站","slug":"网站","permalink":"http://Flipped205.github.io/BlogCode/tags/网站/"},{"name":"转载","slug":"转载","permalink":"http://Flipped205.github.io/BlogCode/tags/转载/"}]},{"title":"Linux 锁","slug":"笔记/0dLinux锁","date":"2018-07-20T00:00:00.000Z","updated":"2018-07-20T00:00:00.000Z","comments":true,"path":"2018/07/20/笔记/0dLinux锁/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/07/20/笔记/0dLinux锁/","excerpt":"","text":"记录锁（fcntl） 两个进程同时对文件进行操作：当一个进程正在读或者修改文件的某个部分时，使用记录锁可以阻止其他进程修改同一文件区。另一术语字节范围锁。fcntl函数原型 12#include &lt;fcntl.h&gt;int fcntl(int fd,int cmd, .../*struct flock *flockptr */); // 返回值：若成功，依赖于cmd,否则，返回-1 对于记录锁，cmd是F_GETLK,F_SETLK或F_SETLKW。第三个参数（我们将调用flockptr）是一个指向flock结构的指针。 1234567struct flock&#123; short l_type; /* F_RDLCK, F_WRLCK, or F_UNLCK */ short l_whence; /* SEEK_SET, SEEK_CUR or SEEK_END */ short l_start; /* offset in bytes, relative to l_whence */ short l_len; /* length, in bytes, 0 means lock to EOF */ short l_pid; /* returned with F_GETLK */&#125; flock结构说明如下： 锁类型：F_RDLCK(共享读锁)、F_WRLCK(独占性写锁)或F_UNLCK(解锁一个区域) 要加锁或解锁区域的起始字节偏移量(l_start和l_whence) 区域字节长度(l_len) 进程ID(l_pid)持有的锁能阻塞当前进程(仅由F_GETLK)返回 关于锁区域说明： 区域起始偏移量的两个元素与lseek函数中最后的两个参数类似。l_whence可选的值是SEEK_SET、SEEK_CUR和SEEK_END。 锁可以在文件尾端处开始或越过尾端处开始，但不能在文章起始位置之前开始。 如l_len=0，则表示锁的范围可以扩展到最大可能的偏移量。这意味着不管向该文件追加多少数据。它们都可以处于锁的范围内。 为了对整个文件加锁，我们设置l_start和l_whence指向文件的起始位置，并指定l_len=0。（常用的指定文件起始位置，l_start=0,l_whence为SEEK_SET）。 两种锁类型：共享读锁（L_RDLCK）和独占性写锁（L_WRLCK）。不同进程下，不同类型锁彼此之间的兼容性： 共享读锁和独占性写锁的原则：多个进程，如果在一个给定字节上有一个或多个读锁时，则不能在该字节上加写锁；如果在一个字节上已经有一把独占性写锁，则不能再对它加任意读锁。 以上情况只针对于多个进程。如果一个进程中对一个文件区域有一把锁，后来进程又企图在同一文件再加一把锁，那么新锁将替换已有锁。 加读锁时，该描述符必须是读打开。加锁时，该描述符必须是写打开。 fcntl的3个命令： F_GETLK: 是否存在一把锁。如存在，则将现有锁信息重写flockptr指向的信息。如果不存在，则除了l_type设置为F_UNLCK之外，其他信息保存不变。 F_SETLK: 设置由flockptr所描述的锁。获取一把读锁（l_type=F_RDLCK）或者写锁（l_type=F_WRLCK）。而兼容性规则，阻止系统给出这把锁，那么fcntl就会立即出错返回。此时errno设置为EACCES和EAGAIN（一般不能满足，都返回该值）。此命令也可用于清除由flockptr指定锁（l_type=F_UNLCK）。 F_SETLKW: 是F_SETLK的阻塞版本，（W=wait）。所以在请求的读锁或写锁因另一个进程当前已经对请求区域的某个部分进行加锁而不能授予，那么调用就会被置为休眠。如果请求创建的锁已经可用，或者休眠由信号中断，则该进程被唤醒。 demo:通用头部代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 通用code#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len)&#123; struct flock lock; lock.l_type = type; lock.l_start = offset; lock.l_whence = whence; lock.l_len = len; return (fcntl(fd, cmd, &amp;lock));&#125;#define read_lock(fd, offset, whence, len) \\ lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))#define readw_lock(fd, offset, whence, len) \\ lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))#define write_lock(fd, offset, whence, len) \\ lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))#define writew_lock(fd, offset, whence, len) \\ lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))#define un_lock(fd, offset, whence, len) \\ lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))char* getRandomString(int length)&#123; int j, i; char* string; char tmp[4]=\"Aa0\"; srand((unsigned) time(NULL )); if ((string = (char*) malloc( sizeof(char)*length)) == NULL ) &#123; printf(\"%d,malloc error\\n\",__LINE__); return \" \"; &#125; for (i = 0; i &lt; length - 1; i++) &#123; j = rand() % 3; string[i] = tmp[j] + rand()%10; if (j!=2)&#123; string[i] += rand()%16; &#125; &#125; string[length - 1] = '\\0'; printf(\"%d,write_buf: %s\\n\",__LINE__, string ); return string;&#125; 写文件 a.c 123456789101112131415161718192021222324252627// a.c 写文件void main(void)&#123; int fd = -1; int len = 0; int i=0; while(1)&#123; srand(time(0)); sleep(10); printf(\"start\\n\"); fd = open(\"./a.txt\", O_WRONLY | O_CREAT | O_TRUNC, S_IWUSR | S_IRUSR | S_IWGRP| S_IRUSR | S_IWOTH | S_IROTH); if (fd != -1) &#123; if (write_lock(fd, 0, SEEK_SET, 0))&#123; printf(\"%d,%d,%s\\n\",__LINE__,errno,(char *)strerror(errno)); close(fd); continue; &#125; len = rand()%200 + 50; if (len == write(fd, getRandomString(len), len)) &#123; printf(\"%d,write success\\n\", __LINE__); &#125;else &#123; printf(\"%d,write fail\\n\", __LINE__); &#125; close(fd); &#125; &#125;&#125; 读文件 b.c 12345678910111213141516171819202122232425262728// b.c 读文件void main(void)&#123; int fd = -1; int len = -1; char buf[256]=&#123;0&#125;; int i=0; while(1)&#123; sleep(5); printf(\"start\\n\"); fd = open(\"./a.txt\", O_RDONLY); if (fd != -1) &#123; if (read_lock(fd, 0, SEEK_SET, 0))&#123; printf(\"%d,%d,%s\\n\",__LINE__,errno,(char *)strerror(errno)); close(fd); continue; &#125; len = read(fd, buf, 256); if (-1 == len)&#123; printf(\"%d,read failed\\n\", __LINE__); &#125;else&#123; printf(\"%d,read success\\n\",__LINE__); printf(\"%d,%s\\n\\n\",__LINE__, buf); &#125; close(fd); &#125; &#125;&#125; 文件描述符open 函数 12345678//函数头文件#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;//函数原型int open(const char *pathname, int flags); /* 打开现有文件 */int open(const char *pathname, int flags, mode_t mode); /* 打开的文件不存在，则先创建它 */ 返回-1,则出错。成功，则返回文件描述符 参数说明： flags 含义 O_RDONLY 以只读方式打开文件 O_WRONLY 以只写方式打开文件 O_RDWR 以读写方式打开文件 O_CREAT 若所打开文件不存在则创建此文件。使用此选项时，需同时使用第三个参数mode说明该新文件的存取许可权位。 O_EXCL 如果同时指定了O_CREATE,而文件已经存在，则导致调用出错 O_TRUNC 如果文件存在，而且为只读或只写方式打开，则将其长度截短为0 O_NOCTTY 如果pathname指定的是终端设备(tty)，则不将此设备分配作为进程的控制终端 O_APPEND 每次写时都加到文件的尾端 O_NONBLOCK 如果pathname指定的是一个FIFO、一个块特殊文件或一个字符特殊文件，则此选择项为此文件的本次打开操作和后续的I/O操作设备为非阻塞方式 O_NONELAY O_NONBLOCK O_SYNC 只在数据被写入外存或其他设备之后操作才返回 mode取值 对应八进制数 含义 S_SVTX 01000 粘贴位 S_IRUSR 00400 文件所有者的读权限位 S_IWUSR 00200 文件所有者的写权限位 S_IXUSR 00100 文件所有者的执行权限位 S_IRGRP 00040 所有者同组用户的读权限位 S_IWGRP 00020 所有者同组用户的写权限位 S_IXGRP 00010 所有者同组用户的执行权限位 S_IROTH 00004 其他组用户的读权限位 S_IWOTH 00002 其他组用户的写权限位 S_IXOTH 00001 其他组用户的执行权限位 文件流fopen 函数 12345//头文件#include &lt;stdio.h&gt;//函数原型FILE *fopen(const char *path, const char *mode); 返回值：失败返回NULL mode取值 说明 r 以只读方式打开文件，该文件必须存在。 r+ 以读/写方式打开文件，该文件必须存在。 rb+ 以读/写方式打开一个二进制文件，只允许读/写数据。 rt+ 以读/写方式打开一个文本文件，允许读和写。 w 打开只写文件，若文件存在则长度清为 0，即该文件内容消失，若不存在则创建该文件。 w+ 打开可读/写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。 a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留（EOF 符保留）。 a+ 以附加方式打开可读/写的文件。若文件不存在，则会建立该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（原来的 EOF 符不保留）。 wb 以只写方式打开或新建一个二进制文件，只允许写数据。 wb+ 以读/写方式打开或建立一个二进制文件，允许读和写。 wt+ 以读/写方式打开或建立一个文本文件，允许读写。 at+ 以读/写方式打开一个文本文件，允许读或在文本末追加数据。 ab+ 以读/写方式打开一个二进制文件，允许读或在文件末追加数据。 12345//获取某个文件流的文件描述符int i_fp = -1;FILE *fp = fopen(\"/tmp/test.txt\",\"r+\");i_fp = fileno(fp);fclose(fp);","categories":[{"name":"Linux","slug":"Linux","permalink":"http://Flipped205.github.io/BlogCode/categories/Linux/"}],"tags":[{"name":"锁","slug":"锁","permalink":"http://Flipped205.github.io/BlogCode/tags/锁/"},{"name":"文件","slug":"文件","permalink":"http://Flipped205.github.io/BlogCode/tags/文件/"}]},{"title":"前端小工具","slug":"前端/02前端小工具","date":"2018-07-19T00:00:00.000Z","updated":"2018-07-19T00:00:00.000Z","comments":true,"path":"2018/07/19/前端/02前端小工具/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/07/19/前端/02前端小工具/","excerpt":"","text":"时钟(Clock Shop) CSS 12345678#clock &#123; max-height: 900px; background-color: #000;&#125;#clock canvas&#123; margin: 0 auto; display: block;&#125; JS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498$(document).ready(function () &#123; /** * @constructor */ var Clock = function () &#123; /** * @type &#123;Clock&#125; */ var me = this; var config = &#123; starCount: 500, showFps: true, drawDigital: true, star: &#123; minOpacity: 0.1, fade: true, fadeSpeed: 0.02, color: '#0a0' &#125;, hour: &#123; foreground: '#aaa', background: '#000', width: 3, &#125;, minute: &#123; foreground: '#aaa', background: '#000', width: 3, &#125;, second: &#123; foreground: '#aaa', background: '#000', width: 3, &#125;, milli: &#123; foreground: 'rgba(0,0,0,0.1)', background: '#000', width: 3, &#125; &#125; /** * @type &#123;Element&#125; */ var canvas = document.createElement('canvas'); /** * @type &#123;CanvasRenderingContext2D&#125; */ var engine = canvas.getContext('2d'); /** * requestor * @type &#123;*|Function&#125; */ var frame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function ( cb) &#123; return setTimeout(cb, 30) &#125;; /** * @type &#123;&#123;&#125;&#125; */ var star = []; /** * * @type &#123;number&#125; */ var size = 0.9; /** * @type &#123;number&#125; */ var radius = size / 2; /** * @type &#123;Date&#125; */ var current = null; /** * @type &#123;&#123;refresh: number, tick: number, start: Date&#125;&#125; */ var fps = &#123; val: 0, refresh: 50, tick: 0, start: new Date() &#125;; /** * @type &#123;&#123;width: number, height: number, size: number, radius: number, middle: number&#125;&#125; */ var meta = &#123; width: 0, height: 0, size: 0, radius: 0, middle: 0 &#125;; /** * init */ this.run = function () &#123; generateStar(); document.body.appendChild(canvas); canvas.setAttribute('width', window.innerWidth); canvas.setAttribute('height', window.innerHeight); frame(tick); &#125;; /** * render frame */ var tick = function () &#123; current = new Date(); solveMeta(); engine.fillStyle = '#000'; engine.clearRect(0, 0, meta.width, meta.height); engine.fillRect(0, 0, meta.width, meta.height); //draw part drawFps(); drawStar(); drawBackgroundTime(); drawPattern(); drawForegroundTime(); drawDigital(); frame(tick); &#125;; /** * draw digital watch */ var drawDigital = function () &#123; if (config.drawDigital) &#123; var time = [ n(current.getHours()), current.getSeconds() % 2 ? ':' : ' ', n(current.getMinutes()) ].join(''); var size = 30; var padding = 10; engine.font = size + 'px Arial'; var m = engine.measureText(time); //engine.fillStyle = 'rgba(0,0,0,0.5)'; //engine.fillRect( // meta.middle.x - m.width / 2 - padding, // meta.middle.y - size / 2 - padding, // m.width + padding * 2, // size + padding * 2 //); engine.fillStyle = '#fff'; engine.fillText( time, meta.middle.x - m.width / 2, meta.middle.y + size / 2); &#125; &#125;; /** * @param ne * @returns &#123;*&#125; */ var n = function (ne) &#123; if (ne &lt; 10) &#123; return '0' + ne; &#125; return ne; &#125;; /** * draw lines for evers hour and minute */ var drawPattern = function () &#123; //#1 engine.strokeStyle = 'rgba(255,255,255,0.2)'; engine.lineWidth = 2; engine.beginPath(); engine.arc(meta.middle.x, meta.middle.y, meta.radius * 0.8 - meta.radius / 12, 0, Math.PI * 2); engine.stroke(); engine.closePath(); //#1.5 engine.strokeStyle = 'rgba(255,255,255,0.2)'; engine.beginPath(); engine.arc(meta.middle.x, meta.middle.y, meta.radius * 0.8 + meta.radius / 12, 0, Math.PI * 2); engine.stroke(); engine.closePath(); //#2 engine.strokeStyle = 'rgba(0,0,0,0.5)'; engine.lineWidth = meta.radius / 6; engine.beginPath(); engine.arc(meta.middle.x, meta.middle.y, meta.radius * 0.8, 0, Math.PI * 2); engine.stroke(); engine.closePath(); var angleWidth = Math.PI * 2 / 60; var seconds = current.getSeconds() + current.getMilliseconds() / 1000; for (var i = 0; i &lt; 60; i++) &#123; var angleMid = i * angleWidth - 0.5 * Math.PI; var startAngle = angleMid - Math.PI / 500; var endAngle = angleMid + Math.PI / 500; //var opa = (60 - seconds + i - 1) % 60; // //engine.strokeStyle = 'rgba(' + [255, 255, 255, opa / 60].join(',') + ')'; if (i === parseInt(seconds)) &#123; engine.strokeStyle = '#0a0'; &#125; else &#123; var opa = 1 - Math.min( Math.abs(i - 60 - seconds), Math.abs(i - seconds), Math.abs(i + 60 - seconds)) / 15; engine.strokeStyle = 'rgba(' + [255, 255, 255, opa].join(',') + ')'; &#125; engine.lineWidth = meta.radius / 20; engine.beginPath(); engine.arc(meta.middle.x, meta.middle.y, meta.radius * 0.8, startAngle, endAngle); engine.stroke(); engine.closePath(); &#125; angleWidth = Math.PI * 2 / 12; for (var i = 0; i &lt; 12; i++) &#123; var angleMid = i * angleWidth - 0.5 * Math.PI; var startAngle = angleMid - Math.PI / 200; var endAngle = angleMid + Math.PI / 200; engine.strokeStyle = 'rgba(255,255,255,0.6)'; engine.lineWidth = meta.radius / 7; engine.beginPath(); engine.arc(meta.middle.x, meta.middle.y, meta.radius * 0.75, startAngle, endAngle); engine.stroke(); engine.closePath(); &#125; &#125; /** * draw background clock */ var drawBackgroundTime = function () &#123; drawBackgroundTimePart(meta.radius / 3 + 20, current.getHours() + current.getMinutes() / 60, 12, config.hour); drawBackgroundTimePart(meta.radius * 0.65 + 20, current.getMinutes() + current.getSeconds() / 60, 60, config.minute); drawBackgroundTimePart(meta.radius + 20, current.getSeconds() + current.getMilliseconds() / 1000, 60, config.second); &#125;; /** * draw foreground clock */ var drawForegroundTime = function () &#123; drawTimePart(meta.radius / 3, current.getHours() + current.getMinutes() / 60, 12, config.hour); drawTimePart(meta.radius * 0.65, current.getMinutes() + current.getSeconds() / 60, 60, config.minute); drawTimePart(meta.radius, current.getSeconds() + current.getMilliseconds() / 1000, 60, config.second); drawTimePart(meta.radius / 15, current.getMilliseconds(), 1000, config.milli, true); drawTimePart(meta.radius / 15, current.getMilliseconds() + 250, 1000, config.milli, true); drawTimePart(meta.radius / 15, current.getMilliseconds() + 500, 1000, config.milli, true); drawTimePart(meta.radius / 15, current.getMilliseconds() + 750, 1000, config.milli, true); &#125;; /** * draw bg time part * * @param &#123;number&#125; radius * @param &#123;number&#125; time * @param &#123;number&#125; maxTime * @param &#123;&#123;&#125;&#125; config */ var drawBackgroundTimePart = function (radius, time, maxTime, config) &#123; engine.globalAlpha = 0.5; var angleWidth = Math.PI * 2 / maxTime; var angleMid = time * angleWidth - 0.5 * Math.PI; var startAngle = angleMid - Math.PI / 1.5; var endAngle = angleMid + Math.PI / 1.5; engine.fillStyle = config.background; //### 1 var grd = engine.createRadialGradient(meta.middle.x, meta.middle.y, radius / 2, meta.middle.x, meta.middle.y, radius); grd.addColorStop(0, 'rgba(0,0,0,0)'); grd.addColorStop(1, config.background); engine.fillStyle = grd; engine.beginPath(); engine.moveTo(meta.middle.x, meta.middle.y); engine.arc(meta.middle.x, meta.middle.y, radius, startAngle, endAngle); engine.fill(); engine.closePath(); //### 2 grd = engine.createRadialGradient(meta.middle.x, meta.middle.y, radius / 2, meta.middle.x, meta.middle.y, radius); grd.addColorStop(0, 'rgba(0,0,0,0)'); grd.addColorStop(1, 'rgba(0,200,0,0.5)'); engine.fillStyle = grd; engine.beginPath(); engine.moveTo(meta.middle.x, meta.middle.y); engine.arc(meta.middle.x, meta.middle.y, radius, startAngle + Math.PI / 2, endAngle - Math.PI / 2); engine.fill(); engine.closePath(); engine.globalAlpha = 1; &#125; /** * draw time part * * @param &#123;number&#125; radius * @param &#123;number&#125; time * @param &#123;number&#125; maxTime * @param &#123;&#123;&#125;&#125; config */ var drawTimePart = function (radius, time, maxTime, config, anti) &#123; var angleWidth = Math.PI * 2 / maxTime; var angleMid = time * angleWidth - 0.5 * Math.PI; var length = 8; if (anti) &#123; angleMid = 0 - angleMid; length = 8; &#125; var startAngle = angleMid - Math.PI / length; var endAngle = angleMid + Math.PI / length; engine.strokeStyle = config.foreground; engine.lineWidth = config.width; engine.beginPath(); engine.arc(meta.middle.x, meta.middle.y, radius - config.width, startAngle, endAngle); engine.stroke(); engine.closePath(); if (!anti) &#123; engine.strokeStyle = '#fff'; engine.lineWidth = 20; engine.beginPath(); engine.arc(meta.middle.x, meta.middle.y, radius, angleMid - 0.01, angleMid + 0.01); engine.stroke(); engine.closePath(); &#125; &#125; /** * solve and render fps */ var drawFps = function () &#123; if (config.showFps) &#123; fps.tick--; if (fps.tick &lt;= 0) &#123; var diffTime = (new Date() - fps.start) / 1000; fps.val = parseInt(fps.refresh / diffTime * 10) / 10; fps.start = new Date(); fps.tick = fps.refresh; &#125; engine.font = '10px Arial'; engine.fillStyle = '#fff'; engine.fillText(fps.val + ' fps | ' + [ n(current.getHours()), current.getSeconds() % 2 ? ':' : ' ', n(current.getMinutes()), current.getSeconds() % 2 ? ':' : ' ', n(current.getSeconds()) ].join(''), 5, meta.height - 5); &#125; &#125; /** * generate Star line setup */ var generateStar = function () &#123; for (var i = 0; i &lt; config.starCount; i++) &#123; star.push(&#123; width: Math.random(), deg: Math.random() * 360, color: Math.random(), colorDir: Math.random() &lt; 0.5 ? config.star.fadeSpeed : -config.star.fadeSpeed &#125;); &#125; &#125; /** * height of canvas * @returns &#123;string&#125; */ var width = function () &#123; return canvas.getAttribute('width'); &#125; /** * height of canvas * @returns &#123;string&#125; */ var height = function () &#123; return canvas.getAttribute('height'); &#125; /** * get mid coords from the clock * @returns &#123;&#123;x: number, y: number&#125;&#125; */ var middle = function () &#123; return &#123; x: width() / 2, y: height() / 2 &#125;; &#125; /** * cache size properties */ var solveMeta = function () &#123; meta.width = width(); meta.height = height(); meta.radius = Math.min(meta.width, meta.height) * radius; meta.size = Math.min(meta.width, meta.height); meta.middle = middle(); &#125; /** * draw clock star lines */ var drawStar = function () &#123; engine.strokeStyle = config.star.color; for (var i = 0; i &lt; star.length; i++) &#123; var starLine = star[i]; var relX = Math.sin(starLine.deg / 360 * Math.PI * 2); var relY = Math.cos(starLine.deg / 360 * Math.PI * 2); engine.beginPath(); engine.moveTo( meta.middle.x, meta.middle.y); engine.lineTo( meta.middle.x + relX * starLine.width * meta.radius, meta.middle.y + relY * starLine.width * meta.radius); engine.lineWidth = parseInt((1 - starLine.width) * 5); if (config.star.fade) &#123; engine.globalAlpha = config.star.minOpacity + (1 - config.star.minOpacity) * starLine.color; starLine.color += starLine.colorDir; if (starLine.color &gt;= 1 || starLine.color &lt;= 0) &#123; starLine.color = starLine.color | 0; starLine.colorDir = -starLine.colorDir; &#125; &#125; engine.stroke(); engine.closePath(); &#125; engine.globalAlpha = 1; &#125; &#125;; var c = new Clock(); c.run();&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"http://Flipped205.github.io/BlogCode/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://Flipped205.github.io/BlogCode/tags/前端/"}]},{"title":"电影收藏","slug":"杂读/01电影","date":"2018-07-06T00:00:00.000Z","updated":"2018-07-06T00:00:00.000Z","comments":true,"path":"2018/07/06/杂读/01电影/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/07/06/杂读/01电影/","excerpt":"","text":"动画片 《千与千寻》 《哈尔移动的城堡》 《狮子王》 《龙猫》 《机器人总动员》 《疯狂动物城》 《天空之城》 《飞屋环游记》 《大圣归来》 《侧耳倾听》 《玩具总动员》 《你的名字。》 《冰雪奇缘》 《秒速五厘米》 《萤火之森》 《鬼妈妈》 《幽灵公主》 《神偷奶爸》 《驯龙高手》 《小倩》","categories":[{"name":"杂读","slug":"杂读","permalink":"http://Flipped205.github.io/BlogCode/categories/杂读/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://Flipped205.github.io/BlogCode/tags/电影/"}]},{"title":"PING原理","slug":"笔记/01ping原理","date":"2018-07-05T00:00:00.000Z","updated":"2018-07-05T00:00:00.000Z","comments":true,"path":"2018/07/05/笔记/01ping原理/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/07/05/笔记/01ping原理/","excerpt":"","text":"&emsp;&emsp;由上面的执行结果可以看到，ping命令执行后显示出被测试系统的主机名和相应IP，返回给当前主机的ICMP报文序列号（seq）,生存时间（ttl）,和往返时间（time单位是毫秒，即千分之一秒）。模拟ping命令，这些信息非常重要。要真正了解ping命令的实现原理，就要了解ping命令所使用到的TCP/IP协议。 ping命令介绍&emsp;&emsp;PING(Packet Internet Groper)，因特网包探索其，用于测试网络连接量的程序。Ping发出一个ICMP(Internet Control Messages Protocol)即因特网信报控制协议；回声请求消息给目的地并报告是否收到所希望的ICMP echo(ICMP回声应答)。它是用来检查网络是否通畅或者网络连速度的命令。它所利用的原理是这样的：利用网络上机器IP得治的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。&emsp;&emsp;其中关键在于发送ICMP数据包，然后对接收到的包进行一定的处理。不可避免，我们要发送ICMP包，必须自己来构建一个包出来。再来回顾一下ICMP:&emsp;&emsp;ICMP(Internet Control Message Protocol)Internet控制保温协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。ICMP是面向无连接的协议。&emsp;&emsp;ping命令值使用众多ICMP报文中的两种：“请求回送(ICMP_ECHO)”和“请求回应(ICMP_ECHOREPLY)”。这两种报文的报头格式如下： 类型(TYPE)编码(CODE)校验和(CHECKSUM)标识符(ID)顺序号(SEQ)&emsp;&emsp;当TYPE字段为`ICMP_ECHO`,CODE字段为0时，代表PING请求报文;TYPE字段为`ICMP_ECHOREPLY`,CODE字段为`0`时，代表PING应答报文/ icmp结构体 // netinet/ip_icmp.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465struct icmp&#123; u_int8_t icmp_type; /* type of message, see below */ u_int8_t icmp_code; /* type sub code */ u_int16_t icmp_cksum; /* ones complement checksum of struct */ union &#123; u_char ih_pptr; /* ICMP_PARAMPROB */ struct in_addr ih_gwaddr; /* gateway address */ struct ih_idseq /* echo datagram */ &#123; u_int16_t icd_id; u_int16_t icd_seq; &#125; ih_idseq; u_int32_t ih_void; /* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */ struct ih_pmtu &#123; u_int16_t ipm_void; u_int16_t ipm_nextmtu; &#125; ih_pmtu; struct ih_rtradv &#123; u_int8_t irt_num_addrs; u_int8_t irt_wpa; u_int16_t irt_lifetime; &#125; ih_rtradv; &#125; icmp_hun;#define icmp_pptr icmp_hun.ih_pptr#define icmp_gwaddr icmp_hun.ih_gwaddr#define icmp_id icmp_hun.ih_idseq.icd_id#define icmp_seq icmp_hun.ih_idseq.icd_seq#define icmp_void icmp_hun.ih_void#define icmp_pmvoid icmp_hun.ih_pmtu.ipm_void#define icmp_nextmtu icmp_hun.ih_pmtu.ipm_nextmtu#define icmp_num_addrs icmp_hun.ih_rtradv.irt_num_addrs#define icmp_wpa icmp_hun.ih_rtradv.irt_wpa#define icmp_lifetime icmp_hun.ih_rtradv.irt_lifetime union &#123; struct &#123; u_int32_t its_otime; u_int32_t its_rtime; u_int32_t its_ttime; &#125; id_ts; struct &#123; struct ip idi_ip; /* options and then 64 bits of data */ &#125; id_ip; struct icmp_ra_addr id_radv; u_int32_t id_mask; u_int8_t id_data[1]; &#125; icmp_dun;#define icmp_otime icmp_dun.id_ts.its_otime#define icmp_rtime icmp_dun.id_ts.its_rtime#define icmp_ttime icmp_dun.id_ts.its_ttime#define icmp_ip icmp_dun.id_ip.idi_ip#define icmp_radv icmp_dun.id_radv#define icmp_mask icmp_dun.id_mask#define icmp_data icmp_dun.id_data&#125;; &emsp;&emsp;使用宏定义表达更简洁，其中ICMP报文为8字节，数据报长度最大为64K字节。 &emsp;&emsp;校验和算法：这一算法称为网际校验和算法，把校验的数据16位进行累加，然后取反码，若数据字节长度为奇数，则数据尾部补一个字节的0以凑成偶数。此算法适用于IPv4、ICMPv4、ICMPv6、UDP和TCP校验和，校验和字段为上述ICMP数据结构的icmp_cksum变量。&emsp;&emsp;标识符：用于唯一标识ICMP报文，为上述ICMP数据结构的icmp_id宏定义指的变量。&emsp;&emsp;顺序号：ping命令的icmp_seq便由这里读出，代表ICMP报文的发送顺序，为上述ICMP数据结构的icmp_seq宏所指的变量。 ICMP封包后：ICMP报头ICMP报文&emsp;&emsp;ICMP是为网管和目标主机二提供的一种差错控制机制，使它们在遇到差错时能把错误报告给报文源发方。ICMP协议是IP层的一个协议，但是由于差错报告在发送给报文源发方时可能也要经过若干子网，因此牵扯到路由选择等问题，所以ICMP报文通过IP协议来发送。ICMP数据报的数据发送前需要两级封装：首先添加ICMP报头形成ICMP报文，再添加IP报头形成IP数据报。因此我们还需知道IP报文的格式。 &emsp;&emsp;IP报文格式：整个ICMP报文作为IP报文的数据部分，再给ICMP报文加个IP头部： IP头部ICMP头部ICMP数据 注: ip头部的考虑，在发送ICMP报文时不需要考虑IP头部，只需要组建一个完整测ICMP发送报文即TYPE为ICMP_ECHO、CODE为0的PING报文。在PING应答报文中对接收数据分析时，必须考虑IP头部，先去除IP头部后，进行对ICMP报文处理。&emsp;&emsp;PING请求（发送）报文不考虑IP头部，PING应答（接收）报文考虑去除IP头部。 ip结构体 123456789101112131415161718192021222324// netinet/ip.hstruct ip&#123;#if __BYTE_ORDER == __LITTLE_ENDIAN unsigned int ip_hl:4; /* header length */ unsigned int ip_v:4; /* version */#endif#if __BYTE_ORDER == __BIG_ENDIAN unsigned int ip_v:4; /* version */ unsigned int ip_hl:4; /* header length */#endif u_int8_t ip_tos; /* type of service */ u_short ip_len; /* total length */ u_short ip_id; /* identification */ u_short ip_off; /* fragment offset field */#define IP_RF 0x8000 /* reserved fragment flag */#define IP_DF 0x4000 /* dont fragment flag */#define IP_MF 0x2000 /* more fragments flag */#define IP_OFFMASK 0x1fff /* mask for fragmenting bits */ u_int8_t ip_ttl; /* time to live */ u_int8_t ip_p; /* protocol */ u_short ip_sum; /* checksum */ struct in_addr ip_src, ip_dst; /* source and dest address */&#125;; PING程序中主要使用以下数据： IP报文头部长度IHL(Internet Header Length),以4字节为单位记录IP头部长度（ip_hl）。 生命周期(TTL)以秒为单位，指出IP数据报能在网络上停留的最长时间，其值由发送方设定，并在经过路由的每一个节点时建议，当该值为0时，数据报被丢弃（ip_ttl）。 ping程序代码流程： 1、参数合法性检查，获取（转换）目标地址 2、发送报文 3、接收报文 4、打印PING信息 1、参数合法性检查 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162int main(int argc,char *argv[])&#123; in_addr_t inaddr; struct sockaddr_in dest_addr; int socket_fd; int size = 50 *1024; struct hostent *p_host; int n_send = 1; if(argc &lt; 2)&#123; printf(\"Usgae: %s [hostname/ip address]\\n\",argv[0]); &#125; /* * 创建socket套接字 AF_INET ipv4 IPPROTO_ICMP icmp协议 */ socket_fd = socket(AF_INET,SOCK_RAW,IPPROTO_ICMP); if(socket_fd &lt; 0)&#123; perror(\"fail socket\"); exit(EXIT_FAILURE); &#125; /* * setsockopt 这里使用主要是设置接收数据包缓冲区，避免了send(),recv()不断的循环收发 */ if(setsockopt(socket_fd,SOL_SOCKET,SO_RCVBUF,&amp;size,sizeof(size)) &lt; 0 )&#123; perror(\"fail setsocketopt\"); exit(EXIT_FAILURE); &#125; bzero(&amp;dest_addr,sizeof(dest_addr)); dest_addr.sin_family = AF_INET; inaddr = inet_addr(argv[1]); // 将点分十进制ip地址转换为网络字节序 if(inaddr == INADDR_NONE)&#123; p_host = gethostbyname2_block_proc(argv[1],12); //gethostbyname2 防止阻塞处理 if(NULL == p_host)&#123; printf(\"unknow host:%s\\n\",argv[1]); exit(EXIT_FAILURE); &#125; memcpy((char *)&amp;dest_addr.sin_addr,p_host-&gt;h_addr,p_host-&gt;h_length); &#125;else&#123; dest_addr.sin_addr.s_addr = inaddr; &#125; if(NULL != p_host)&#123; printf(\"PING %s\",p_host-&gt;h_name); &#125;else&#123; printf(\"PING %s\",argv[1]); &#125; printf(\"(%s) %d bytes of data.\\n\",inet_ntoa(dest_addr.sin_addr),ICMP_LEN); signal(SIGINT,statistics); pHost = p_host; // pHost statisticsd 打印信息使用 IP = argv[1]; // IP statistics打印信息使用 SocketICMP = socket_fd; //SocketICMP statistics()函数close套接字使用 while(n_send &lt; SEND_NUM )&#123; send_packet(socket_fd,&amp;dest_addr,n_send); recv_packet(socket_fd,&amp;dest_addr); sleep(1); n_send++; nSend = n_send; // nSend statistics打印信息使用 &#125; statistics();&#125; 2、发送数据发送数据主要包括组建ICMP报文，发送报文；组建ICMP报文时需要计算校验和 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253u_int16_t compute_cksum(u_int16_t *p_data,int data_len)&#123; u_int16_t *p_tmp_data = p_data; int len = data_len; u_int32_t sum = 0; // sum 必须为 u_int32_t 不能为 u_int16_t while(len &gt; 1)&#123; sum += *p_tmp_data++; len -= 2; &#125; if(1 == len)&#123; u_int16_t tmp = *p_tmp_data; tmp &amp;= 0xff00; sum += tmp; &#125; while(sum &gt;&gt; 16)&#123; sum = (sum &gt;&gt; 16) + (sum &amp; 0x0000ffff); &#125; sum = ~sum; return sum;&#125;/* * 组建ICMP报文 */void set_icmp(char *p_send_buffer,u_int16_t seq)&#123; struct icmp *p_icmp; struct timeval *p_time; p_icmp = (struct icmp *)p_send_buffer; p_icmp-&gt;icmp_type = ICMP_ECHO; p_icmp-&gt;icmp_code = 0; p_icmp-&gt;icmp_cksum = 0; p_icmp-&gt;icmp_seq = seq; p_icmp-&gt;icmp_id = getpid(); p_time = (struct timeval *)p_icmp-&gt;icmp_data; gettimeofday(p_time,NULL); p_icmp-&gt;icmp_cksum = compute_cksum((u_int16_t *)p_icmp,ICMP_LEN); if(seq == 1)&#123; FirstSendTime = *p_time; &#125; &#125;int send_packet(int socket_fd,struct sockaddr_in *p_dest_addr,int n_send)&#123; char send_buffer[BUFFER_LEN]; set_icmp(send_buffer,n_send); if(sendto(socket_fd,send_buffer,ICMP_LEN,0,( struct sockaddr *)p_dest_addr,sizeof(struct sockaddr_in))&lt;0)&#123; perror(\"sendto\"); return 0; &#125;&#125; 3、接收数据接收数据包括接收数据和数据分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int unpack(char *p_recv_buffer,struct timeval *p_recv_time)&#123; struct ip *p_ip = (struct ip *)p_recv_buffer; struct icmp *p_icmp ; int ip_head_len; double rtt=0.0; ip_head_len = p_ip-&gt;ip_hl &lt;&lt; 2; p_icmp = (struct icmp *)(p_recv_buffer + ip_head_len); if(p_icmp-&gt;icmp_type == ICMP_ECHOREPLY &amp;&amp; p_icmp-&gt;icmp_id == getpid())&#123; struct timeval *p_send_time = (struct timeval *)p_icmp-&gt;icmp_data; rtt = get_rtt(p_recv_time,p_send_time); printf(\"%u bytes from %s:icmp_seq=%u ttl=%u time=%.1f ms\\n\", ntohs(p_ip-&gt;ip_len),inet_ntoa(p_ip-&gt;ip_src),p_icmp-&gt;icmp_seq, p_ip-&gt;ip_ttl,rtt); if(rtt &lt; min || 0 == min)&#123; min = rtt; &#125; if(rtt &gt; max)&#123; max = rtt; &#125; avg += rtt; mdev += rtt*rtt; return 0; &#125; return -1;&#125;int recv_packet(int socket_fd,struct sockaddr_in *p_dest_addr)&#123; int recv_bytes = 0; int addrlen = sizeof(struct sockaddr_in); char recv_buffer[BUFFER_LEN]; struct timeval recv_time; signal(SIGALRM,statistics); alarm(WAIT_TIME); recv_bytes = recvfrom(socket_fd,recv_buffer,BUFFER_LEN,0, (struct sockaddr *)p_dest_addr,&amp;addrlen); if(recv_bytes &lt; 0)&#123; perror(\"recvfrom\"); return 0; &#125; gettimeofday(&amp;recv_time,NULL); LastRecvTime = recv_time; if(unpack(recv_buffer,&amp;recv_time) == -1)&#123; return -1; &#125; nRecv++;&#125; 123456789101112double get_rtt(struct timeval *p_recv_time,struct timeval *p_send_time)&#123; struct timeval tmp_time = *p_recv_time; tmp_time.tv_usec -= p_send_time-&gt;tv_usec; if(tmp_time.tv_usec &lt; 0)&#123; --(tmp_time.tv_sec); tmp_time.tv_usec += 1000000; &#125; tmp_time.tv_sec -= p_send_time-&gt;tv_sec; return (tmp_time.tv_sec *1000.0) + (tmp_time.tv_usec / 1000.0);&#125; 4、打印数据统计数据 123456789101112131415161718void statistics()&#123; double tmp; avg /= nRecv; tmp = mdev/nRecv - avg * avg; mdev = sqrt(tmp); if(NULL != pHost)&#123; printf(\"--- %s ping statistics ---\\n\",pHost-&gt;h_name); &#125;else&#123; printf(\"--- %s ping statistics ---\\n\",IP); &#125; printf(\"%d packets transmitted, %d received, %d%% packet loss, time %dms\\n\", nSend,nRecv,(nSend-nRecv)/nSend *100,(int)get_rtt(&amp;LastRecvTime,&amp;FirstSendTime)); printf(\"rtt min/avg/max/dev = %.3f/%.3f/%.3f/%.3f ms\\n\",min,avg,max,mdev); close(SocketICMP); exit(0);&#125; 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;netdb.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;string.h&gt;#include &lt;netinet/ip_icmp.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;signal.h&gt;#include &lt;math.h&gt;#include &lt;setjmp.h&gt;#define SEND_NUM 100#define BUFFER_LEN 128#define ICMP_HEAD_LEN 8#define ICMP_DATA_LEN 56#define ICMP_LEN (ICMP_HEAD_LEN + ICMP_DATA_LEN)//char SendBuffer[BUFFER_LEN];//char RecvBuffer[BUFFER_LEN];struct hostent *pHost;char *IP;int nRecv = 0;int nSend = 0;double min=0.0;double avg=0.0;double max=0.0;double mdev =0.0;struct timeval FirstSendTime;struct timeval LastRecvTime;#define WAIT_TIME 5int SocketICMP;u_int16_t compute_cksum(u_int16_t *p_data,int data_len)&#123; u_int16_t *p_tmp_data = p_data; int len = data_len; u_int32_t sum = 0; // sum 必须为 u_int32_t 不能为 u_int16_t while(len &gt; 1)&#123; sum += *p_tmp_data++; len -= 2; &#125; if(1 == len)&#123; u_int16_t tmp = *p_tmp_data; tmp &amp;= 0xff00; sum += tmp; &#125; while(sum &gt;&gt; 16)&#123; sum = (sum &gt;&gt; 16) + (sum &amp; 0x0000ffff); &#125; sum = ~sum; return sum;&#125;void set_icmp(char *p_send_buffer,u_int16_t seq)&#123; struct icmp *p_icmp; struct timeval *p_time; p_icmp = (struct icmp *)p_send_buffer; p_icmp-&gt;icmp_type = ICMP_ECHO; p_icmp-&gt;icmp_code = 0; p_icmp-&gt;icmp_cksum = 0; p_icmp-&gt;icmp_seq = seq; p_icmp-&gt;icmp_id = getpid(); p_time = (struct timeval *)p_icmp-&gt;icmp_data; gettimeofday(p_time,NULL); p_icmp-&gt;icmp_cksum = compute_cksum((u_int16_t *)p_icmp,ICMP_LEN); if(seq == 1)&#123; FirstSendTime = *p_time; &#125; &#125;int send_packet(int socket_fd,struct sockaddr_in *p_dest_addr,int n_send)&#123; char send_buffer[BUFFER_LEN]; set_icmp(send_buffer,n_send); if(sendto(socket_fd,send_buffer,ICMP_LEN,0,( struct sockaddr *)p_dest_addr,sizeof(struct sockaddr_in))&lt;0)&#123; perror(\"sendto\"); return 0; &#125;&#125;double get_rtt(struct timeval *p_recv_time,struct timeval *p_send_time)&#123; struct timeval tmp_time = *p_recv_time; tmp_time.tv_usec -= p_send_time-&gt;tv_usec; if(tmp_time.tv_usec &lt; 0)&#123; --(tmp_time.tv_sec); tmp_time.tv_usec += 1000000; &#125; tmp_time.tv_sec -= p_send_time-&gt;tv_sec; return (tmp_time.tv_sec *1000.0) + (tmp_time.tv_usec / 1000.0);&#125;void statistics()&#123; double tmp; avg /= nRecv; tmp = mdev/nRecv - avg * avg; mdev = sqrt(tmp); if(NULL != pHost)&#123; printf(\"--- %s ping statistics ---\\n\",pHost-&gt;h_name); &#125;else&#123; printf(\"--- %s ping statistics ---\\n\",IP); &#125; printf(\"%d packets transmitted, %d received, %d%% packet loss, time %dms\\n\", nSend,nRecv,(nSend-nRecv)/nSend *100,(int)get_rtt(&amp;LastRecvTime,&amp;FirstSendTime)); printf(\"rtt min/avg/max/dev = %.3f/%.3f/%.3f/%.3f ms\\n\",min,avg,max,mdev); close(SocketICMP); exit(0);&#125;int unpack(char *p_recv_buffer,struct timeval *p_recv_time)&#123; struct ip *p_ip = (struct ip *)p_recv_buffer; struct icmp *p_icmp ; int ip_head_len; double rtt=0.0; ip_head_len = p_ip-&gt;ip_hl &lt;&lt; 2; p_icmp = (struct icmp *)(p_recv_buffer + ip_head_len); if(p_icmp-&gt;icmp_type == ICMP_ECHOREPLY &amp;&amp; p_icmp-&gt;icmp_id == getpid())&#123; struct timeval *p_send_time = (struct timeval *)p_icmp-&gt;icmp_data; rtt = get_rtt(p_recv_time,p_send_time); printf(\"%u bytes from %s:icmp_seq=%u ttl=%u time=%.1f ms\\n\", ntohs(p_ip-&gt;ip_len),inet_ntoa(p_ip-&gt;ip_src),p_icmp-&gt;icmp_seq, p_ip-&gt;ip_ttl,rtt); if(rtt &lt; min || 0 == min)&#123; min = rtt; &#125; if(rtt &gt; max)&#123; max = rtt; &#125; avg += rtt; mdev += rtt*rtt; return 0; &#125; return -1;&#125;int recv_packet(int socket_fd,struct sockaddr_in *p_dest_addr)&#123; int recv_bytes = 0; int addrlen = sizeof(struct sockaddr_in); char recv_buffer[BUFFER_LEN]; struct timeval recv_time; signal(SIGALRM,statistics); alarm(WAIT_TIME); recv_bytes = recvfrom(socket_fd,recv_buffer,BUFFER_LEN,0, (struct sockaddr *)p_dest_addr,&amp;addrlen); if(recv_bytes &lt; 0)&#123; perror(\"recvfrom\"); return 0; &#125; gettimeofday(&amp;recv_time,NULL); LastRecvTime = recv_time; if(unpack(recv_buffer,&amp;recv_time) == -1)&#123; return -1; &#125; nRecv++;&#125;static sigjmp_buf jmpbuf;static void alarm_func()&#123; siglongjmp(jmpbuf, 1);&#125;static struct hostent * gethostbyname2_block_proc(char *p_hostname,int timeout)&#123; struct hostent *p_ret_hostent; signal(SIGALRM, alarm_func); if(sigsetjmp(jmpbuf, 1) != 0) &#123; alarm(0); /* 取消闹钟 */ signal(SIGALRM, SIG_IGN); return NULL; &#125; alarm(timeout); /* 设置超时时间 */ p_ret_hostent = gethostbyname2(p_hostname,AF_INET); // gethostbyname2指定AF_IENT IPV4地址 signal(SIGALRM, SIG_IGN); return p_ret_hostent;&#125;int main(int argc,char *argv[])&#123; in_addr_t inaddr; struct sockaddr_in dest_addr; int socket_fd; int size = 50 *1024; struct hostent *p_host; int n_send = 1; if(argc &lt; 2)&#123; printf(\"Usgae: %s [hostname/ip address]\\n\",argv[0]); &#125; /* * 创建socket套接字 AF_INET ipv4 IPPROTO_ICMP icmp协议 */ socket_fd = socket(AF_INET,SOCK_RAW,IPPROTO_ICMP); if(socket_fd &lt; 0)&#123; perror(\"fail socket\"); exit(EXIT_FAILURE); &#125; /* * setsockopt 这里使用主要是设置接收数据包缓冲区，避免了send(),recv()不断的循环收发 */ if(setsockopt(socket_fd,SOL_SOCKET,SO_RCVBUF,&amp;size,sizeof(size)) &lt; 0 )&#123; perror(\"fail setsocketopt\"); exit(EXIT_FAILURE); &#125; bzero(&amp;dest_addr,sizeof(dest_addr)); dest_addr.sin_family = AF_INET; inaddr = inet_addr(argv[1]); // 将点分十进制ip地址转换为网络字节序 if(inaddr == INADDR_NONE)&#123; p_host = gethostbyname2_block_proc(argv[1],12); //gethostbyname2 防止阻塞处理 if(NULL == p_host)&#123; printf(\"unknow host:%s\\n\",argv[1]); exit(EXIT_FAILURE); &#125; memcpy((char *)&amp;dest_addr.sin_addr,p_host-&gt;h_addr,p_host-&gt;h_length); &#125;else&#123; dest_addr.sin_addr.s_addr = inaddr; &#125; if(NULL != p_host)&#123; printf(\"PING %s\",p_host-&gt;h_name); &#125;else&#123; printf(\"PING %s\",argv[1]); &#125; printf(\"(%s) %d bytes of data.\\n\",inet_ntoa(dest_addr.sin_addr),ICMP_LEN); signal(SIGINT,statistics); pHost = p_host; // pHost statisticsd 打印信息使用 IP = argv[1]; // IP statistics打印信息使用 SocketICMP = socket_fd; //SocketICMP statistics()函数close套接字使用 while(n_send &lt; SEND_NUM )&#123; send_packet(socket_fd,&amp;dest_addr,n_send); recv_packet(socket_fd,&amp;dest_addr); sleep(1); n_send++; nSend = n_send; // nSend statistics打印信息使用 &#125; statistics();&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Flipped205.github.io/BlogCode/categories/笔记/"}],"tags":[{"name":"ping","slug":"ping","permalink":"http://Flipped205.github.io/BlogCode/tags/ping/"}]},{"title":"Linux CPU使用率","slug":"笔记/0cLinuxCPU使用率","date":"2018-06-26T00:00:00.000Z","updated":"2018-06-26T00:00:00.000Z","comments":true,"path":"2018/06/26/笔记/0cLinuxCPU使用率/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/06/26/笔记/0cLinuxCPU使用率/","excerpt":"","text":"内核版本 1cat /proc/version CPU活动信息 1cat /proc/stat jiffies是内核中的一个全局变量，用来记录自系统启动以来产生的节拍书，在linux中，一个节拍大致可以立即为操作系统进程调度的最小时间片，不同的linux内核可能值有所不同，通常在1ms到10ms之间。 参数说明: 参数 解释(jiffies) user（6001460） 从系统启动开始累计到当前时刻，处于用户态的运行时间，不包含nice值为负进程 nice（37043） 从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间 system（95525758） 从系统启动开始累计到当前时刻，核心时间 idle（277280659） 从系统启动开始累计到当前时刻，除IO等待时间以外其它等待时间 iowait（904849） 从系统启动开始累计到当前时刻，IO等待时间 irq（0） 从系统启动开始累计到当前时刻，硬中断时间 softirq（200629） 从系统启动开始累计到当前时刻，软中断时间 stealstolen（0） which is the time spent in other operating systems when running in a virtualized environment(since 2.6.11) guest（0） which is the time spent running a virtual CPU for guest operating systems under the control of the Linux kernel(since 2.6.24) 总的CPU使用率计算计算方法： 1、采用两个足够用段的时间间隔的CPU快照，t1,t2。（user,nice,system,idle） 2、计算总的CPU时间片totalCPUTime a)、t1的CPU使用情况，求和s1; b)、t2的CPU使用情况，求和s2; c)、s2-s1得到时间间隔的所有时间片，即totalCPUTime = s2-s1; 3、计算使用时间(usr+system) a)、t1的使用情况，u1 = (user+system). b)、t2的使用情况，u2 = (user+system). c)、u2-u1得到时间间隔的使用时间片，即useCPUTime = u2-u1; 4、计算使用率 pcpu = 100*(userCPUTime)/totalCPUTime; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct CPU_JIFFIES&#123; char name[20]; unsigned int user; unsigned int nice; unsigned int system; unsigned int idle;&#125;;void get_cpu_jiffies(struct CPU_JIFFIES *jiffies)&#123; FILE *fp = NULL; char buff[1024] =&#123;0&#125;; fp = fopen(\"/proc/stat\",\"r\"); if (!fp)&#123; printf(\"error\\n\"); return ; &#125; fgets(buff, sizeof(buff), fp); sscanf(buff, \"%s %u %u %u %u\",jiffies-&gt;name, &amp;(jiffies-&gt;user), &amp;(jiffies-&gt;nice), &amp;(jiffies-&gt;system), &amp;(jiffies-&gt;idle)); printf(\"%s %u %u %u %u\\n\", jiffies-&gt;name, jiffies-&gt;user, jiffies-&gt;nice, jiffies-&gt;system, jiffies-&gt;idle); fclose(fp);&#125;float cal_pcpu(struct CPU_JIFFIES e, struct CPU_JIFFIES s)&#123; double et, st; double eu, su; double idle ; et = (double)(e.user + e.nice + e.system + e.idle); st = (double)(s.user + s.nice + s.system + s.idle); idle = (double)(e.idle-s.idle); eu = (double)(e.user + e.system); su = (double)(s.user + s.system); printf(\"et:%f st:%f eu:%f su:%f\\n\",et, st, eu,su ); printf(\"%f\\n\",(100*(eu-su))/(et-st)); return (100*(et-st-idle))/(et-st);&#125;void main(void)&#123; struct CPU_JIFFIES s; struct CPU_JIFFIES e; int pcpu=0; sleep(1); get_cpu_jiffies(&amp;s); sleep(1); get_cpu_jiffies(&amp;e); pcpu = (int)cal_pcpu(e,s); printf(\"%d\\n\", pcpu);&#125; TOP 命令 1top 内存使用free命令 1free 备注： 1．不同内核版本/proc/stat文件格式不大一致。/proc/stat文件中第一行为总的cpu使用情况。 各个版本都有的4个字段: user、nice、system、idle 2.5.41版本新增字段：iowait 2.6.0-test4新增字段：irq、softirq 2.6.11新增字段：stealstolen：which is the time spent in other operating systems when running in a virtualized environment 2.6.24新增字段：guest：which is the time spent running a virtual CPU for guest operating systems under the control of the Linux kernel 2．/proc/pid/task目录是Linux 2.6.0-test6之后才有的功能。 3．关于出现cpu使用率为负的情况，目前想到的解决方案是如果出现负值，连续采样计算cpu使用率直到为非负。 4．有些线程生命周期较短,可能在我们采样期间就已经死掉了.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://Flipped205.github.io/BlogCode/categories/Linux/"}],"tags":[{"name":"cpu","slug":"cpu","permalink":"http://Flipped205.github.io/BlogCode/tags/cpu/"}]},{"title":"socket函数 几种不同的套接字使用","slug":"笔记/04socket函数","date":"2018-06-04T00:00:00.000Z","updated":"2018-06-04T00:00:00.000Z","comments":true,"path":"2018/06/04/笔记/04socket函数/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/06/04/笔记/04socket函数/","excerpt":"","text":"bits/socket.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* Protocol families. */#define PF_UNSPEC 0 /* Unspecified. */#define PF_LOCAL 1 /* Local to host (pipes and file-domain). */#define PF_UNIX PF_LOCAL /* POSIX name for PF_LOCAL. */#define PF_FILE PF_LOCAL /* Another non-standard name for PF_LOCAL. */#define PF_INET 2 /* IP protocol family. */#define PF_AX25 3 /* Amateur Radio AX.25. */#define PF_IPX 4 /* Novell Internet Protocol. */#define PF_APPLETALK 5 /* Appletalk DDP. */#define PF_NETROM 6 /* Amateur radio NetROM. */#define PF_BRIDGE 7 /* Multiprotocol bridge. */#define PF_ATMPVC 8 /* ATM PVCs. */#define PF_X25 9 /* Reserved for X.25 project. */#define PF_INET6 10 /* IP version 6. */#define PF_ROSE 11 /* Amateur Radio X.25 PLP. */#define PF_DECnet 12 /* Reserved for DECnet project. */#define PF_NETBEUI 13 /* Reserved for 802.2LLC project. */#define PF_SECURITY 14 /* Security callback pseudo AF. */#define PF_KEY 15 /* PF_KEY key management API. */#define PF_NETLINK 16#define PF_ROUTE PF_NETLINK /* Alias to emulate 4.4BSD. */#define PF_PACKET 17 /* Packet family. */#define PF_ASH 18 /* Ash. */#define PF_ECONET 19 /* Acorn Econet. */#define PF_ATMSVC 20 /* ATM SVCs. */#define PF_RDS 21 /* RDS sockets. */#define PF_SNA 22 /* Linux SNA Project */#define PF_IRDA 23 /* IRDA sockets. */#define PF_PPPOX 24 /* PPPoX sockets. */#define PF_WANPIPE 25 /* Wanpipe API sockets. */#define PF_LLC 26 /* Linux LLC. */#define PF_CAN 29 /* Controller Area Network. */#define PF_TIPC 30 /* TIPC sockets. */#define PF_BLUETOOTH 31 /* Bluetooth sockets. */#define PF_IUCV 32 /* IUCV sockets. */#define PF_RXRPC 33 /* RxRPC sockets. */#define PF_ISDN 34 /* mISDN sockets. */#define PF_PHONET 35 /* Phonet sockets. */#define PF_IEEE802154 36 /* IEEE 802.15.4 sockets. */#define PF_CAIF 37 /* CAIF sockets. */#define PF_ALG 38 /* Algorithm sockets. */#define PF_NFC 39 /* NFC sockets. */#define PF_VSOCK 40 /* vSockets. */#define PF_MAX 41 /* For now.. *//* Address families. */#define AF_UNSPEC PF_UNSPEC#define AF_LOCAL PF_LOCAL#define AF_UNIX PF_UNIX#define AF_FILE PF_FILE#define AF_INET PF_INET#define AF_AX25 PF_AX25#define AF_IPX PF_IPX#define AF_APPLETALK PF_APPLETALK#define AF_NETROM PF_NETROM#define AF_BRIDGE PF_BRIDGE#define AF_ATMPVC PF_ATMPVC#define AF_X25 PF_X25#define AF_INET6 PF_INET6#define AF_ROSE PF_ROSE#define AF_DECnet PF_DECnet#define AF_NETBEUI PF_NETBEUI#define AF_SECURITY PF_SECURITY#define AF_KEY PF_KEY#define AF_NETLINK PF_NETLINK#define AF_ROUTE PF_ROUTE#define AF_PACKET PF_PACKET#define AF_ASH PF_ASH#define AF_ECONET PF_ECONET#define AF_ATMSVC PF_ATMSVC#define AF_RDS PF_RDS#define AF_SNA PF_SNA#define AF_IRDA PF_IRDA#define AF_PPPOX PF_PPPOX#define AF_WANPIPE PF_WANPIPE#define AF_LLC PF_LLC#define AF_CAN PF_CAN#define AF_TIPC PF_TIPC#define AF_BLUETOOTH PF_BLUETOOTH#define AF_IUCV PF_IUCV#define AF_RXRPC PF_RXRPC#define AF_ISDN PF_ISDN#define AF_PHONET PF_PHONET#define AF_IEEE802154 PF_IEEE802154#define AF_CAIF PF_CAIF#define AF_ALG PF_ALG#define AF_NFC PF_NFC#define AF_VSOCK PF_VSOCK#define AF_MAX PF_MAX AF_xx地址簇，BF_xx协议簇AF_xx 与 BF_xx值相同 通常PF_INET表示互联网协议簇（TCP/IP协议簇）；或者PF_PACKET协议栈（底层数据包接口） 不同的AF_xx或BF_xx需要的目的结构不同 函数原型int socket(int domain, int type, int protocol); domain:协议域，又称协议簇(family)。常用的协议簇有AF_INET,AF_INET6，AF_LOCAL(或称AF_UNIX,UNIX域Socket)、AF_ROUTE。协议簇决定Socket的地址类型。在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址(32位)与端口号(16位)的组合、AF_UNIX决定了要用一个绝对路径名作为地址。 type:指定Socket类型。常用的socket类型有SOCK_STREAM(用于TCP)、SOCK_DGRAM（用于UDP）、SOCK_RAW（ICMP,IGMP）、SOCK_PACKET、SOCK_SEQPACKET、FA_PACKET. protocol：指定协议。常用的协议有IPPROTO_TCP、IPPROTO_UDP、IPPROTO_STCP、IPPROTO_TIPC。分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。 链路层套接字：PF_PACKET该套接字的打开需要用户root权限。 其中socket type有两种类型SOCK_RAW,SOCK_DGRAM。SOCK_RAW:它包含了MAC层头部信息的原始分组，当然这种类型的套接字在发送的时候需要自己加上一个MAC头部（以太网头部，其类型定义在linux/if_ether.h中ethhdr）。应用：dhcpc中接收来自DHCP服务器数据时创建该套接字。portocol为：htons(ETH_P_IP)。 struct sockaddr_ll sock;SOCK_DGRAM:它已经进行了MAC层头部处理的，即收到的帧已经去掉了头部。应用：dhcpc在发送Discover等报文时使用该类型创建套接字，可无需添加以太网头部，只需添加IP头部、UDP头部和Data。portocol为：htons(ETH_P_IP)。 protocol是指其送交的上层的协议好，如IP为0x0800.当其为htons(ETH_P_ALL)（其宏定义为0）时表示收发所有协议。 创建好套接字后，就可以通过UDP一样的recvform和sendto函数进行数据的收发，其目的的地址结构sockaddr_ll。这与传输层的地址结构定义是不一样的，其长度为20字节。（在TCP/IP的链路层地址中使用18字节），而传输层额结构长度为16字节。 12345678910struct sockaddr_ll&#123; unsigned short sll_family; // 总是AF_INET unsigned short sll_protocol; //物理层的协议 int sll_ifindex; // 接口号 unsigned short sll_hatype; // 报文类型 unsigned char sll_pkttype; // 分组类型 unsigned char sll_halen; // 地址长度 unsigned char sll_addr[8]; //物理层地址&#125; eg: 12345678910111213141516#define MAC_BCAST_ADDR (unsigned char *) \"\\xff\\xff\\xff\\xff\\xff\\xff\"// dhcp discoverint dhcp_discover(...)&#123; int fd; fd = socket(PF_PACKET,SOCK_DGRAM,htons(ETH_P_IP)); struct sockaddr_ll dest; memset(&amp;dest,0,sizeof(dest)); dest.sll_family = AF_PACKET; dest.sll_protocol = htons(ETH_P_IP); dest.sll_ifindex = ifindex; // 随机数 dest.sll_halen = 6; memcpy(dest.sll_addr,MAC_BCAST_ADDR,6);&#125; 参考资料：1、raw_socket以及普通socket使用终极总结2、socket建立","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Flipped205.github.io/BlogCode/categories/笔记/"}],"tags":[{"name":"socket","slug":"socket","permalink":"http://Flipped205.github.io/BlogCode/tags/socket/"},{"name":"套接字","slug":"套接字","permalink":"http://Flipped205.github.io/BlogCode/tags/套接字/"}]},{"title":"Linux内核Socket实现","slug":"笔记/0bLinux内核Socket实现","date":"2018-05-30T00:00:00.000Z","updated":"2018-05-30T00:00:00.000Z","comments":true,"path":"2018/05/30/笔记/0bLinux内核Socket实现/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/05/30/笔记/0bLinux内核Socket实现/","excerpt":"","text":"内核版本2.6.36 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* * System call vectors. * * Argument checking cleaned up. Saved 20% in size. * This function doesn't need to set the kernel lock because * it is set by the callees. */SYSCALL_DEFINE2(socketcall, int, call, unsigned long __user *, args)&#123; unsigned long a[6]; unsigned long a0, a1; int err; unsigned int len; if (call &lt; 1 || call &gt; SYS_RECVMMSG) return -EINVAL; len = nargs[call]; if (len &gt; sizeof(a)) return -EINVAL; /* copy_from_user should be SMP safe. */ if (copy_from_user(a, args, len)) return -EFAULT; audit_socketcall(nargs[call] / sizeof(unsigned long), a); a0 = a[0]; a1 = a[1]; switch (call) &#123; case SYS_SOCKET: err = sys_socket(a0, a1, a[2]); break; case SYS_BIND: err = sys_bind(a0, (struct sockaddr __user *)a1, a[2]); break; case SYS_CONNECT: err = sys_connect(a0, (struct sockaddr __user *)a1, a[2]); break; case SYS_LISTEN: err = sys_listen(a0, a1); break; case SYS_ACCEPT: err = sys_accept4(a0, (struct sockaddr __user *)a1, (int __user *)a[2], 0); break; case SYS_GETSOCKNAME: err = sys_getsockname(a0, (struct sockaddr __user *)a1, (int __user *)a[2]); break; case SYS_GETPEERNAME: err = sys_getpeername(a0, (struct sockaddr __user *)a1, (int __user *)a[2]); break; case SYS_SOCKETPAIR: err = sys_socketpair(a0, a1, a[2], (int __user *)a[3]); break; case SYS_SEND: err = sys_send(a0, (void __user *)a1, a[2], a[3]); break; case SYS_SENDTO: err = sys_sendto(a0, (void __user *)a1, a[2], a[3], (struct sockaddr __user *)a[4], a[5]); break; case SYS_RECV: err = sys_recv(a0, (void __user *)a1, a[2], a[3]); break; case SYS_RECVFROM: err = sys_recvfrom(a0, (void __user *)a1, a[2], a[3], (struct sockaddr __user *)a[4], (int __user *)a[5]); break; case SYS_SHUTDOWN: err = sys_shutdown(a0, a1); break; case SYS_SETSOCKOPT: err = sys_setsockopt(a0, a1, a[2], (char __user *)a[3], a[4]); break; case SYS_GETSOCKOPT: err = sys_getsockopt(a0, a1, a[2], (char __user *)a[3], (int __user *)a[4]); break; case SYS_SENDMSG: err = sys_sendmsg(a0, (struct msghdr __user *)a1, a[2]); break; case SYS_RECVMSG: err = sys_recvmsg(a0, (struct msghdr __user *)a1, a[2]); break; case SYS_RECVMMSG: err = sys_recvmmsg(a0, (struct mmsghdr __user *)a1, a[2], a[3], (struct timespec __user *)a[4]); break; case SYS_ACCEPT4: err = sys_accept4(a0, (struct sockaddr __user *)a1, (int __user *)a[2], a[3]); break; default: err = -EINVAL; break; &#125; return err;&#125;#endif /* __ARCH_WANT_SYS_SOCKETCALL */ 一、创建Socket Socket内核调用数SYSCALL_DEFINE3： Socket的创建是在用户空间调用socket系统函数完成的，创建一个Socket返回一个文件描述符fd，内核的系统调用接口为SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)，在net/socket.c文件中，下面我们看一下内核中的源码实现。 1、SYSCALL_DEFINE3(socket,…)SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol) // net/socket.c line:1272 1234567891011121314151617181920212223242526272829303132333435363738SYSCALL_DEFINE3(`socket`, int, family, int, type, int, protocol)&#123; int retval; struct socket *sock; int flags; /* Check the SOCK_* constants for consistency. */ //进行各种检查操作 BUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC); BUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK); BUILD_BUG_ON(SOCK_CLOEXEC &amp; SOCK_TYPE_MASK); BUILD_BUG_ON(SOCK_NONBLOCK &amp; SOCK_TYPE_MASK); flags = type &amp; ~SOCK_TYPE_MASK; if (flags &amp; ~(SOCK_CLOEXEC | SOCK_NONBLOCK)) return -EINVAL; type &amp;= SOCK_TYPE_MASK; if (SOCK_NONBLOCK != O_NONBLOCK &amp;&amp; (flags &amp; SOCK_NONBLOCK)) flags = (flags &amp; ~SOCK_NONBLOCK) | O_NONBLOCK; //调用创建socket的函数 retval = `sock_create`(family, type, protocol, &amp;sock); // 详见----第一章第2节 if (retval &lt; 0) goto out; retval = `sock_map_fd`(sock, flags &amp; (O_CLOEXEC | O_NONBLOCK)); //详见----第一章第6节 if (retval &lt; 0) goto out_release;out: /* It may be already another descriptor 8) Not kernel problem. */ return retval;out_release: sock_release(sock); return retval;&#125; 2、sock_create函数sock_create // net/socket.c line:1260 1234int sock_create(int family, int type, int protocol, struct socket **res)&#123; return `__sock_create`(current-&gt;nsproxy-&gt;net_ns, family, type, protocol, res, 0);&#125; 真正实现函数__sock_create(); __sock_create函数实现 // net/socket.c line 1147 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126static int __sock_create(struct net *net, int family, int type, int protocol, struct socket **res, int kern)&#123; int err; struct socket *sock; const struct net_proto_family *pf; /* * Check protocol is in range * `检查协议的范围，现在内核定义的最大范围为38，这里的family指的是` * `AF_INET6，AF_INET协议簇` * `#define NPROTO AF_MAX //include/linux/net.h` * `#define AF_MAX 38 // For now.. ` * */ if (family &lt; 0 || family &gt;= NPROTO) return -EAFNOSUPPORT; if (type &lt; 0 || type &gt;= SOCK_MAX) //`type： socket的类型 eg:SOCK_STREAM` return -EINVAL; /* Compatibility. This uglymoron is moved from INET layer to here to avoid deadlock in module load. */ if (family == PF_INET &amp;&amp; type == SOCK_PACKET) &#123; // 如果soeket type 为SOCK_PACKET，需要重新给family赋值 static int warned; //默认初始化为0 if (!warned) &#123; warned = 1; printk(KERN_INFO \"%s uses obsolete (PF_INET,SOCK_PACKET)\\n\", current-&gt;comm); &#125; family = PF_PACKET; //赋值为PF_PACKET &#125; err = security_socket_create(family, type, protocol, kern); if (err) return err; /* * Allocate the socket and allow the family to set things up. if * the protocol is 0, the family is instructed to select an appropriate * default. * `调用sock_alloc分配sock` */ sock = `sock_alloc`(); if (!sock) &#123; if (net_ratelimit()) printk(KERN_WARNING \"socket: no more sockets\\n\"); return -ENFILE; /* Not exactly a match, but its the closest posix thing */ &#125; sock-&gt;type = type;#ifdef CONFIG_MODULES /* Attempt to load a protocol module if the find failed. * * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user * requested real, full-featured networking support upon configuration. * Otherwise module support will break! */ if (net_families[family] == NULL) request_module(\"net-pf-%d\", family);#endif rcu_read_lock(); pf = rcu_dereference(net_families[family]); err = -EAFNOSUPPORT; if (!pf) goto out_release; /* * We will call the -&gt;create function, that possibly is in a loadable * module, so we have to bump that loadable module refcnt first. */ if (!try_module_get(pf-&gt;owner)) goto out_release; /* Now protected by module ref count */ rcu_read_unlock(); /* * static const struct net_proto_family inet_family_ops = &#123; * .family = PF_INET, * .create = inet_create, * .owner = THIS_MODULE, * &#125;; //net/ipv4/af_inet.c * `根据注册的family类型，调用不同的create函数，这里就是调用inet_ctreate。` */ err = pf-&gt;`create`(net, sock, protocol, kern); if (err &lt; 0) goto out_module_put; /* * Now to bump the refcnt of the [loadable] module that owns this * socket at sock_release time we decrement its refcnt. */ if (!try_module_get(sock-&gt;ops-&gt;owner)) goto out_module_busy; /* * Now that we're done with the -&gt;create function, the [loadable] * module can have its refcnt decremented */ module_put(pf-&gt;owner); err = security_socket_post_create(sock, family, type, protocol, kern); if (err) goto out_sock_release; `*res = sock`; return 0;out_module_busy: err = -EAFNOSUPPORT;out_module_put: sock-&gt;ops = NULL; module_put(pf-&gt;owner);out_sock_release: sock_release(sock); return err;out_release: rcu_read_unlock(); goto out_sock_release;&#125; 3、sock_alloc函数 sock_alloc函数用于分配一个socket结构体，这这里涉及了inode结构以及在分配完成后返回的地址指针。sock_alloc // net/socket.c line:471 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * sock_alloc - allocate a socket * * Allocate a new inode and socket object. The two are bound together * and initialised. The socket is then returned. If we are out of inodes * NULL is returned. */static struct socket *sock_alloc(void)&#123; struct inode *inode; struct socket *sock; /* 下面的new_inode_pseudo函数是分配一个新的inode结构体，但在实际分配过程中，分配了一个socket_alloc结构体，返回d的是inode地址， * struct socket_alloc &#123; * struct socket socket; * struct inode vfs_inode; * &#125;; //include/net/sock.h */ inode = `new_inode(sock_mnt-&gt;mnt_sb)`; // new_inode 详见 fs/inode.c中实现,sock_mnt什么时候初始化 if (!inode) return NULL; /* SOCKET_I * static inline struct socket *SOCKET_I(struct inode *inode) * &#123; * return &amp;container_of(inode, struct socket_alloc, vfs_inode)-&gt;socket; * &#125;//include/net/sock.h * * #define container_of(ptr, type, member) (&#123; \\ * const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \\ * (type *)( (char *)__mptr - offsetof(type,member) );&#125;) * #endif //drivers/staging/rtl8192e/ieee80211.h */ sock = SOCKET_I(inode); // 该宏根据返回的inode获取到分配的socket_alloc指针 kmemcheck_annotate_bitfield(sock, type); /* inode变量进行初始化操作 */ inode-&gt;i_mode = S_IFSOCK | S_IRWXUGO; inode-&gt;i_uid = current_fsuid(); // 用户ID，在后面调用bind系统调用时会进行对比 inode-&gt;i_gid = current_fsgid(); // 组ID percpu_add(sockets_in_use, 1); return sock;&#125; 3.1、sock_mnt-&gt;mnt_sb的赋值分配过程 在sock_init函数中对socket类型的文件系统进行注册sock_mnt // net/sock.c line:316 1static struct vfsmount *`sock_mnt` __read_mostly; sock_mnt数据类型为结构体 vfsmount;vfsmount结构体 include/linux/mount.h line:49 123456789101112131415161718192021222324252627282930313233343536373839struct vfsmount &#123; struct list_head mnt_hash; struct vfsmount *mnt_parent; /* fs we are mounted on */ struct dentry *mnt_mountpoint; /* dentry of mountpoint */ struct dentry *mnt_root; /* root of the mounted tree */ struct super_block *`mnt_sb`; /* pointer to superblock */ struct list_head mnt_mounts; /* list of children, anchored here */ struct list_head mnt_child; /* and going through their mnt_child */ int mnt_flags; /* 4 bytes hole on 64bits arches without fsnotify */#ifdef CONFIG_FSNOTIFY __u32 mnt_fsnotify_mask; struct hlist_head mnt_fsnotify_marks;#endif const char *mnt_devname; /* Name of device e.g. /dev/dsk/hda1 */ struct list_head mnt_list; struct list_head mnt_expire; /* link in fs-specific expiry list */ struct list_head mnt_share; /* circular list of shared mounts */ struct list_head mnt_slave_list;/* list of slave mounts */ struct list_head mnt_slave; /* slave list entry */ struct vfsmount *mnt_master; /* slave is on master-&gt;mnt_slave_list */ struct mnt_namespace *mnt_ns; /* containing namespace */ int mnt_id; /* mount identifier */ int mnt_group_id; /* peer group identifier */ /* * We put mnt_count &amp; mnt_expiry_mark at the end of struct vfsmount * to let these frequently modified fields in a separate cache line * (so that reads of mnt_flags wont ping-pong on SMP machines) */ atomic_t mnt_count; int mnt_expiry_mark; /* true if marked for expiry */ int mnt_pinned; int mnt_ghosts;#ifdef CONFIG_SMP int __percpu *mnt_writers;#else int mnt_writers;#endif&#125;; 12345static struct file_system_type sock_fs_type = &#123; .name = \"sockfs\", .get_sb = sockfs_get_sb, .kill_sb = kill_anon_super,&#125;; sock_init函数 // net/socket.c line:2392 1234567891011121314151617181920212223242526272829303132333435static int __init sock_init(void)&#123; /* * Initialize sock SLAB cache. */ sk_init(); /* * Initialize skbuff SLAB cache */ skb_init(); /* * Initialize the protocols module. */ init_inodecache(); register_filesystem(&amp;sock_fs_type); // 文件系统的注册 sock_mnt = `kern_mount`(&amp;sock_fs_type); // 挂载文件系统 /* The real protocol initialization is performed in later initcalls. */#ifdef CONFIG_NETFILTER netfilter_init();#endif#ifdef CONFIG_NETWORK_PHY_TIMESTAMPING skb_timestamping_init();#endif return 0;&#125; 3.2、new_inode函数 new_inode函数创建inode,并初始化inode的i_state变量和inode-&gt;isn_list链表，实际的分配函数为alloc_inode函数。fs/inode.c 12345678910111213141516171819202122232425262728293031323334/** * new_inode - obtain an inode * @sb: superblock * * Allocates a new inode for given superblock. The default gfp_mask * for allocations related to inode-&gt;i_mapping is GFP_HIGHUSER_MOVABLE. * If HIGHMEM pages are unsuitable or it is known that pages allocated * for the page cache are not reclaimable or migratable, * mapping_set_gfp_mask() must be called with suitable flags on the * newly created inode's mapping * */struct inode *new_inode(struct super_block *sb)&#123; /* * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW * error if st_ino won't fit in target struct field. Use 32bit counter * here to attempt to avoid that. */ static unsigned int last_ino; struct inode *inode; spin_lock_prefetch(&amp;inode_lock); inode = `alloc_inode`(sb); if (inode) &#123; spin_lock(&amp;inode_lock); `__inode_add_to_lists`(sb, NULL, inode); inode-&gt;i_ino = ++last_ino; `inode-&gt;i_state` = 0; spin_unlock(&amp;inode_lock); &#125; return inode;&#125; 3.2.1、alloc_inode函数alloc_inode函数 // fs/inode.c line:193 123456789101112131415161718192021222324252627282930313233static struct inode *alloc_inode(struct super_block *sb)&#123; struct inode *inode; /* * 如果当前文件系统的超级块，有自己的分配inode的函数，则调用它自己的分配函数，否则从公用的高速缓存中分配一个inode。对于sockt来说，在socket.c中，调用的函数为sock_alloc_inode * static const struct super_operations `sockfs_ops` = &#123; * .alloc_inode = `sock_alloc_inode`, * .destroy_inode = sock_destroy_inode, * .statfs = simple_statfs, * &#125;; * */ if (sb-&gt;s_op-&gt;alloc_inode) inode = `sb-&gt;s_op-&gt;alloc_inode`(sb); else inode = kmem_cache_alloc(inode_cachep, GFP_KERNEL); if (!inode) return NULL; /* * 初始化 inode结构体 */ if (unlikely(inode_init_always(sb, inode))) &#123; if (inode-&gt;i_sb-&gt;s_op-&gt;destroy_inode) inode-&gt;i_sb-&gt;s_op-&gt;destroy_inode(inode); else kmem_cache_free(inode_cachep, inode); return NULL; &#125; return inode;&#125; 3.2.1.1、sock_alloc_inode函数sock_alloc_inode函数 // net/socket.c line:240 1234567891011121314151617181920212223242526static struct inode *sock_alloc_inode(struct super_block *sb)&#123; struct socket_alloc *ei; /* * kmem_cache_alloc分配stuct socket_alloc结构体，如何分配？ */ ei = `kmem_cache_alloc`(sock_inode_cachep, GFP_KERNEL); if (!ei) return NULL; ei-&gt;socket.wq = kmalloc(sizeof(struct socket_wq), GFP_KERNEL); if (!ei-&gt;socket.wq) &#123; kmem_cache_free(sock_inode_cachep, ei); return NULL; &#125; init_waitqueue_head(&amp;ei-&gt;socket.wq-&gt;wait); ei-&gt;socket.wq-&gt;fasync_list = NULL; ei-&gt;socket.state = SS_UNCONNECTED; ei-&gt;socket.flags = 0; ei-&gt;socket.ops = NULL; ei-&gt;socket.sk = NULL; ei-&gt;socket.file = NULL; return &amp;ei-&gt;vfs_inode; //返回sturct inode `vfs_inode`;&#125; 备注：在分配函数sock_alloc_inode中调用了 ei = kmem_cache_alloc(sock_inode_cachep,GFP_KERNEL);这里分配的大小为socket_alloc大小，下面分宜如何分配该大小? kmem_cache_create init_inodecache函数中（net/socket.c），对其进行高速缓存的分配操作，定义在socket.c文件中，这里分配的大小为socket_alloc，但是返回时socket_alloc结构体中的struct indoe vfs_inode;变量。该函数在sock_init中被调用。 init_inodecache函数： 12345678910111213static int init_inodecache(void)&#123; sock_inode_cachep = `kmem_cache_create`(\"sock_inode_cache\", sizeof(struct socket_alloc), 0, (SLAB_HWCACHE_ALIGN | SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD), init_once); if (sock_inode_cachep == NULL) return -ENOMEM; return 0;&#125; 3.2.2、__inode_add_to_lists函数__inode_add_to_lists函数 // fs/inode.c 12345678910static inline void__inode_add_to_lists(struct super_block *sb, struct hlist_head *head, struct inode *inode)&#123; inodes_stat.nr_inodes++; list_add(&amp;inode-&gt;i_list, &amp;inode_in_use); list_add(&amp;inode-&gt;i_sb_list, &amp;sb-&gt;s_inodes); if (head) hlist_add_head(&amp;inode-&gt;i_hash, head);&#125; 4、inet_create函数 在socket_create函数中调用pf-&gt;create,这里的指针为inet_create。在文件net/ipv4/af_inet中。socket_create // net/ipv4/af_inet.c line:268 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/* * Create an inet socket. */static int inet_create(struct net *net, struct socket *sock, int protocol, int kern)&#123; struct sock *sk; struct inet_protosw *answer; struct inet_sock *inet; struct proto *answer_prot; unsigned char answer_flags; char answer_no_check; int try_loading_module = 0; int err; if (unlikely(!inet_ehash_secret)) if (sock-&gt;type != SOCK_RAW &amp;&amp; sock-&gt;type != SOCK_DGRAM) build_ehash_secret(); sock-&gt;state = SS_UNCONNECTED; /* Look for the requested type/protocol pair. */lookup_protocol: err = -ESOCKTNOSUPPORT; rcu_read_lock(); /* * 从inetsw中根据类型，协议查找相应的socket interface即 inet_protosw *answer; * * // include/linux/rculist.h * #define list_for_each_entry_rcu(pos, head, member) \\ * for (pos = list_entry_rcu((head)-&gt;next, typeof(*pos), member); \\ * prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head); \\ * pos = list_entry_rcu(pos-&gt;member.next, typeof(*pos), member)) */ list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], list) &#123; err = 0; /* Check the non-wild match. */ if (protocol == answer-&gt;protocol) &#123; if (protocol != IPPROTO_IP) break; &#125; else &#123; /* Check for the two wild cases. */ if (IPPROTO_IP == protocol) &#123; protocol = answer-&gt;protocol; break; &#125; if (IPPROTO_IP == answer-&gt;protocol) break; &#125; err = -EPROTONOSUPPORT; &#125; /* * 如果没找到，尝试加载模块 */ if (unlikely(err)) &#123; if (try_loading_module &lt; 2) &#123; rcu_read_unlock(); /* * Be more specific, e.g. net-pf-2-proto-132-type-1 * (net-pf-PF_INET-proto-IPPROTO_SCTP-type-SOCK_STREAM) */ if (++try_loading_module == 1) request_module(\"net-pf-%d-proto-%d-type-%d\", PF_INET, protocol, sock-&gt;type); /* * Fall back to generic, e.g. net-pf-2-proto-132 * (net-pf-PF_INET-proto-IPPROTO_SCTP) */ else request_module(\"net-pf-%d-proto-%d\", PF_INET, protocol); goto lookup_protocol; &#125; else goto out_rcu_unlock; &#125; err = -EPERM; if (sock-&gt;type == SOCK_RAW &amp;&amp; !kern &amp;&amp; !capable(CAP_NET_RAW)) goto out_rcu_unlock; err = -EAFNOSUPPORT; if (!inet_netns_ok(net, protocol)) goto out_rcu_unlock; sock-&gt;ops = answer-&gt;ops; answer_prot = answer-&gt;prot; answer_no_check = answer-&gt;no_check; answer_flags = answer-&gt;flags; rcu_read_unlock(); WARN_ON(answer_prot-&gt;slab == NULL); err = -ENOBUFS; /* * sk_alloc表面上看是生成sock的结构体，但是实际上对于tcp来说是tcp_sock的大小的结构体，这样就可以使用inet_sk(sk);进行强制的类型转换，具体如何分配tcp_sock大小？ */ sk = `sk_alloc`(net, PF_INET, GFP_KERNEL, answer_prot); if (sk == NULL) goto out; err = 0; sk-&gt;sk_no_check = answer_no_check; if (INET_PROTOSW_REUSE &amp; answer_flags) sk-&gt;sk_reuse = 1; inet = inet_sk(sk); inet-&gt;is_icsk = (INET_PROTOSW_ICSK &amp; answer_flags) != 0; inet-&gt;nodefrag = 0; if (SOCK_RAW == sock-&gt;type) &#123; inet-&gt;inet_num = protocol; if (IPPROTO_RAW == protocol) inet-&gt;hdrincl = 1; &#125; if (ipv4_config.no_pmtu_disc) inet-&gt;pmtudisc = IP_PMTUDISC_DONT; else inet-&gt;pmtudisc = IP_PMTUDISC_WANT; inet-&gt;inet_id = 0; /* * sk结构体变量进行初始化。 */ `sock_init_data`(sock, sk); sk-&gt;sk_destruct = inet_sock_destruct; sk-&gt;sk_protocol = protocol; sk-&gt;sk_backlog_rcv = sk-&gt;sk_prot-&gt;backlog_rcv; inet-&gt;uc_ttl = -1; inet-&gt;mc_loop = 1; inet-&gt;mc_ttl = 1; inet-&gt;mc_all = 1; inet-&gt;mc_index = 0; inet-&gt;mc_list = NULL; sk_refcnt_debug_inc(sk); if (inet-&gt;inet_num) &#123; /* It assumes that any protocol which allows * the user to assign a number at socket * creation time automatically * shares. */ inet-&gt;inet_sport = htons(inet-&gt;inet_num); /* Add to protocol hash chains. */ sk-&gt;sk_prot-&gt;hash(sk); &#125; if (sk-&gt;sk_prot-&gt;init) &#123; err = `sk-&gt;sk_prot-&gt;init(sk)`; //如果tcp 这里为tcp_v4_init_sock if (err) sk_common_release(sk); &#125;out: return err;out_rcu_unlock: rcu_read_unlock(); goto out;&#125; 4.1、sk_alloc函数sk_alloc函数 // net/core/sock.c line:1096 1234567891011121314151617181920212223242526272829/** * sk_alloc - All socket objects are allocated here * @net: the applicable net namespace * @family: protocol family * @priority: for allocation (%GFP_KERNEL, %GFP_ATOMIC, etc) * @prot: struct proto associated with this new sock instance */struct sock *sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot)&#123; struct sock *sk; sk = `sk_prot_alloc`(prot, priority | __GFP_ZERO, family); if (sk) &#123; sk-&gt;sk_family = family; /* * See comment in struct sock definition to understand * why we need sk_prot_creator -acme */ sk-&gt;sk_prot = sk-&gt;sk_prot_creator = prot; sock_lock_init(sk); sock_net_set(sk, get_net(net)); atomic_set(&amp;sk-&gt;sk_wmem_alloc, 1); sock_update_classid(sk); &#125; return sk;&#125; 4.1.1、sk_prot_alloc函数sk_prot_alloc函数 //net/core/sock.c line:1012 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152static struct sock *sk_prot_alloc(struct `proto *prot`, gfp_t priority, int family)&#123; struct sock *sk; struct kmem_cache *slab; /* * 下面分配内存空间时，分两种情况：`1`、从高速缓冲中分配，`2`、普通的分配 */ `slab = prot-&gt;slab`; if (slab != NULL) &#123; sk = `kmem_cache_alloc`(slab, priority &amp; ~__GFP_ZERO); // 第一种分配方式 if (!sk) return sk; if (priority &amp; __GFP_ZERO) &#123; /* * caches using SLAB_DESTROY_BY_RCU should let * sk_node.next un-modified. Special care is taken * when initializing object to zero. */ if (offsetof(struct sock, sk_node.next) != 0) memset(sk, 0, offsetof(struct sock, sk_node.next)); memset(&amp;sk-&gt;sk_node.pprev, 0, prot-&gt;obj_size - offsetof(struct sock, sk_node.pprev)); &#125; &#125; else sk = `kmalloc`(prot-&gt;obj_size, priority); //第二种分配方式 if (sk != NULL) &#123; kmemcheck_annotate_bitfield(sk, flags); if (security_sk_alloc(sk, family, priority)) goto out_free; if (!try_module_get(prot-&gt;owner)) goto out_free_sec; sk_tx_queue_clear(sk); &#125; return sk;out_free_sec: security_sk_free(sk);out_free: if (slab != NULL) kmem_cache_free(slab, sk); else kfree(sk); return NULL;&#125; sk_prot_alloc函数中包括内存空间的分配过程，存在两种分配方式，而第一种分配方式涉及到slab是否为空，slab=prot-&gt;slab;而prot为sk_prot_alloc的传入参数，其结构体为struct proto *prot; sk_prot_alloc参数prot由sk_alloc传入，sk_alloc参数prot 为inet_create 函数出入的answer_prot；answer_prot = answer-&gt;prot，即sk_prot_alloc中的prot为inet_create中的answer结构体重的prot成员变量。answer为inet_create函数中变量，其结构体为struct inet_protosw *answer;关于answer初始化赋值list_for_each_entry_rcu；详看第5小结。 第二种内存分配机制：主要是prot-&gt;obj_size;就是struct proto tcp_prot中初始化的.obj_size = sizeof(struct tcp_sock); 。 sk = kmalloc(prot-&gt;obj_size,priority); 下图为5个相关的数据结构，tcp_sock结构体占用的空间是最大的，所有在分配内存控件是，都是分配的tcp_sock的大小，这样在后面进行强制转换的过程中可以保证正确： ![](/img/note_0b/01.png) 4.2、sock_init_data函数sock_init_data函数 // net/core/sock.c line:1937 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void sock_init_data(struct socket *sock, struct sock *sk)&#123; skb_queue_head_init(&amp;sk-&gt;sk_receive_queue); skb_queue_head_init(&amp;sk-&gt;sk_write_queue); skb_queue_head_init(&amp;sk-&gt;sk_error_queue);#ifdef CONFIG_NET_DMA skb_queue_head_init(&amp;sk-&gt;sk_async_wait_queue);#endif sk-&gt;sk_send_head = NULL; init_timer(&amp;sk-&gt;sk_timer); // 初始化sk定时器 sk-&gt;sk_allocation = GFP_KERNEL; sk-&gt;sk_rcvbuf = sysctl_rmem_default; sk-&gt;sk_sndbuf = sysctl_wmem_default; sk-&gt;sk_state = TCP_CLOSE; // 初始化sk_state = TCP_CLOSE状态，为后面在系统调用中会进行判断 sk_set_socket(sk, sock); // sk-&gt;sk_socket = sock; 设置sk中指向socket的指针 sock_set_flag(sk, SOCK_ZAPPED); // 设置 SOCKET的flag位，表明该socket已经绑定一个名字，该标志什么意思？ if (sock) &#123; sk-&gt;sk_type = sock-&gt;type; sk-&gt;sk_wq = sock-&gt;wq; sock-&gt;sk = sk; &#125; else sk-&gt;sk_wq = NULL; spin_lock_init(&amp;sk-&gt;sk_dst_lock); rwlock_init(&amp;sk-&gt;sk_callback_lock); lockdep_set_class_and_name(&amp;sk-&gt;sk_callback_lock, af_callback_keys + sk-&gt;sk_family, af_family_clock_key_strings[sk-&gt;sk_family]); sk-&gt;sk_state_change = sock_def_wakeup; sk-&gt;sk_data_ready = sock_def_readable; sk-&gt;sk_write_space = sock_def_write_space; sk-&gt;sk_error_report = sock_def_error_report; sk-&gt;sk_destruct = sock_def_destruct; sk-&gt;sk_sndmsg_page = NULL; sk-&gt;sk_sndmsg_off = 0; sk-&gt;sk_peer_pid = NULL; sk-&gt;sk_peer_cred = NULL; sk-&gt;sk_write_pending = 0; sk-&gt;sk_rcvlowat = 1; sk-&gt;sk_rcvtimeo = MAX_SCHEDULE_TIMEOUT; sk-&gt;sk_sndtimeo = MAX_SCHEDULE_TIMEOUT; sk-&gt;sk_stamp = ktime_set(-1L, 0); /* * Before updating sk_refcnt, we must commit prior changes to memory * (Documentation/RCU/rculist_nulls.txt for details) */ smp_wmb(); atomic_set(&amp;sk-&gt;sk_refcnt, 1); // sk的引用计数+1 atomic_set(&amp;sk-&gt;sk_drops, 0);&#125; 备注：思考 sock 与socket 参考资料： struct sk_buff与struct socket及struct sock 结构体分析 sock结构体 struct socket 结构详解 struct socket结构体详解 struct sk_buff结构体详解 4.3、tcp_v4_init_sock函数tcp_v4_init_sock函数 // net/ipv4/tcp_ipv4.c line:1857 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* NOTE: A lot of things set to zero explicitly by call to * sk_alloc() so need not be done here. */static int tcp_v4_init_sock(struct sock *sk)&#123; struct inet_connection_sock *icsk = inet_csk(sk); // 强制类型转换 return (struct inet_connection_sock *)sk; struct tcp_sock *tp = tcp_sk(sk); // `强制类型转换 return (struct tcp_sock *)sk`; /* * tcp 相关变量初始化工作 */ skb_queue_head_init(&amp;tp-&gt;out_of_order_queue); tcp_init_xmit_timers(sk); tcp_prequeue_init(tp); icsk-&gt;icsk_rto = TCP_TIMEOUT_INIT; tp-&gt;mdev = TCP_TIMEOUT_INIT; /* So many TCP implementations out there (incorrectly) count the * initial SYN frame in their delayed-ACK and congestion control * algorithms that we must have the following bandaid to talk * efficiently to them. -DaveM */ tp-&gt;snd_cwnd = 2; /* See draft-stevens-tcpca-spec-01 for discussion of the * initialization of these values. */ tp-&gt;snd_ssthresh = TCP_INFINITE_SSTHRESH; tp-&gt;snd_cwnd_clamp = ~0; tp-&gt;mss_cache = TCP_MSS_DEFAULT; tp-&gt;reordering = sysctl_tcp_reordering; icsk-&gt;icsk_ca_ops = &amp;tcp_init_congestion_ops; sk-&gt;sk_state = TCP_CLOSE; sk-&gt;sk_write_space = sk_stream_write_space; sock_set_flag(sk, SOCK_USE_WRITE_QUEUE); icsk-&gt;icsk_af_ops = &amp;ipv4_specific; icsk-&gt;icsk_sync_mss = tcp_sync_mss;#ifdef CONFIG_TCP_MD5SIG tp-&gt;af_specific = &amp;tcp_sock_ipv4_specific;#endif /* TCP Cookie Transactions */ if (sysctl_tcp_cookie_size &gt; 0) &#123; /* Default, cookies without s_data_payload. */ tp-&gt;cookie_values = kzalloc(sizeof(*tp-&gt;cookie_values), sk-&gt;sk_allocation); if (tp-&gt;cookie_values != NULL) kref_init(&amp;tp-&gt;cookie_values-&gt;kref); &#125; /* Presumed zeroed, in order of appearance: * cookie_in_always, cookie_out_never, * s_data_constant, s_data_in, s_data_out */ sk-&gt;sk_sndbuf = sysctl_tcp_wmem[1]; sk-&gt;sk_rcvbuf = sysctl_tcp_rmem[1]; local_bh_disable(); percpu_counter_inc(&amp;tcp_sockets_allocated); local_bh_enable(); return 0;&#125; 5、sk_prot_alloc参数prot 由第4小结中的sk_prot_alloc函数解释，可知sk_prot_alloc中使用的prot变量，其作为参数传入，最早定义在inet_create函数中answer结构体。answer初始化详看以下代码inet_create函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/* * Create an inet socket. */static int inet_create(struct net *net, struct socket *sock, int protocol, int kern)&#123; struct sock *sk; struct inet_protosw *answer; struct inet_sock *inet; struct proto *answer_prot; unsigned char answer_flags; char answer_no_check; int try_loading_module = 0; int err; if (unlikely(!inet_ehash_secret)) if (sock-&gt;type != SOCK_RAW &amp;&amp; sock-&gt;type != SOCK_DGRAM) build_ehash_secret(); sock-&gt;state = SS_UNCONNECTED; /* Look for the requested type/protocol pair. */lookup_protocol: err = -ESOCKTNOSUPPORT; rcu_read_lock(); /* * 从inetsw中根据类型，协议查找相应的socket interface即 inet_protosw *answer; * * // include/linux/rculist.h * #define list_for_each_entry_rcu(pos, head, member) \\ * for (pos = list_entry_rcu((head)-&gt;next, typeof(*pos), member); \\ * prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head); \\ * pos = list_entry_rcu(pos-&gt;member.next, typeof(*pos), member)) */ `list_for_each_entry_rcu`(answer, &amp;inetsw[sock-&gt;type], list) &#123; err = 0; /* Check the non-wild match. */ if (protocol == answer-&gt;protocol) &#123; if (protocol != IPPROTO_IP) break; &#125; else &#123; /* Check for the two wild cases. */ if (IPPROTO_IP == protocol) &#123; protocol = answer-&gt;protocol; break; &#125; if (IPPROTO_IP == answer-&gt;protocol) break; &#125; err = -EPROTONOSUPPORT; &#125; /* * 如果没找到，尝试加载模块 */ if (unlikely(err)) &#123; if (try_loading_module &lt; 2) &#123; rcu_read_unlock(); /* * Be more specific, e.g. net-pf-2-proto-132-type-1 * (net-pf-PF_INET-proto-IPPROTO_SCTP-type-SOCK_STREAM) */ if (++try_loading_module == 1) request_module(\"net-pf-%d-proto-%d-type-%d\", PF_INET, protocol, sock-&gt;type); /* * Fall back to generic, e.g. net-pf-2-proto-132 * (net-pf-PF_INET-proto-IPPROTO_SCTP) */ else request_module(\"net-pf-%d-proto-%d\", PF_INET, protocol); goto lookup_protocol; &#125; else goto out_rcu_unlock; &#125; err = -EPERM; if (sock-&gt;type == SOCK_RAW &amp;&amp; !kern &amp;&amp; !capable(CAP_NET_RAW)) goto out_rcu_unlock; err = -EAFNOSUPPORT; if (!inet_netns_ok(net, protocol)) goto out_rcu_unlock; sock-&gt;ops = answer-&gt;ops; answer_prot = answer-&gt;prot; answer_no_check = answer-&gt;no_check; answer_flags = answer-&gt;flags; rcu_read_unlock(); WARN_ON(answer_prot-&gt;slab == NULL); err = -ENOBUFS; /* * sk_alloc表面上式生成sock的结构体，但是实际上对于tcp来说是tcp_sock的大小的结构体，这样就可以使用inet_sk(sk);进行强制的类型转换，具体如何分配tcp_sock大小？ */ sk = `sk_alloc`(net, PF_INET, GFP_KERNEL, answer_prot); if (sk == NULL) goto out; err = 0; sk-&gt;sk_no_check = answer_no_check; if (INET_PROTOSW_REUSE &amp; answer_flags) sk-&gt;sk_reuse = 1; inet = inet_sk(sk); inet-&gt;is_icsk = (INET_PROTOSW_ICSK &amp; answer_flags) != 0; inet-&gt;nodefrag = 0; if (SOCK_RAW == sock-&gt;type) &#123; inet-&gt;inet_num = protocol; if (IPPROTO_RAW == protocol) inet-&gt;hdrincl = 1; &#125; if (ipv4_config.no_pmtu_disc) inet-&gt;pmtudisc = IP_PMTUDISC_DONT; else inet-&gt;pmtudisc = IP_PMTUDISC_WANT; inet-&gt;inet_id = 0; /* * sk结构体变量进行初始化。 */ sock_init_data(sock, sk); sk-&gt;sk_destruct = inet_sock_destruct; sk-&gt;sk_protocol = protocol; sk-&gt;sk_backlog_rcv = sk-&gt;sk_prot-&gt;backlog_rcv; inet-&gt;uc_ttl = -1; inet-&gt;mc_loop = 1; inet-&gt;mc_ttl = 1; inet-&gt;mc_all = 1; inet-&gt;mc_index = 0; inet-&gt;mc_list = NULL; sk_refcnt_debug_inc(sk); if (inet-&gt;inet_num) &#123; /* It assumes that any protocol which allows * the user to assign a number at socket * creation time automatically * shares. */ inet-&gt;inet_sport = htons(inet-&gt;inet_num); /* Add to protocol hash chains. */ sk-&gt;sk_prot-&gt;hash(sk); &#125; if (sk-&gt;sk_prot-&gt;init) &#123; err = sk-&gt;sk_prot-&gt;init(sk); //如果tcp 这里为`tcp_v4_init_sock` if (err) sk_common_release(sk); &#125;out: return err;out_rcu_unlock: rcu_read_unlock(); goto out;&#125; list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], list)中的answer由inetsw遍历得出，其中inetsw的定义下面类型的数组如果是SOCK_STREAM类型的socket，这里的prot = tcp_prot;inetsw_array // net/ipv4/af_inet.c 12345678910111213141516171819202122232425262728293031323334/* Upon startup we insert all the elements in inetsw_array[] into * the linked list inetsw. */static struct inet_protosw `inetsw_array`[] =&#123; &#123; .type = SOCK_STREAM, .protocol = IPPROTO_TCP, .prot = &amp;`tcp_prot`, .ops = &amp;inet_stream_ops, .no_check = 0, .flags = INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK, &#125;, &#123; .type = SOCK_DGRAM, .protocol = IPPROTO_UDP, .prot = &amp;udp_prot, .ops = &amp;inet_dgram_ops, .no_check = UDP_CSUM_DEFAULT, .flags = INET_PROTOSW_PERMANENT, &#125;, &#123; .type = SOCK_RAW, .protocol = IPPROTO_IP, /* wild card */ .prot = &amp;raw_prot, .ops = &amp;inet_sockraw_ops, .no_check = UDP_CSUM_DEFAULT, .flags = INET_PROTOSW_REUSE, &#125;&#125;; tcp_prot // net/ipv4/tcp_ipv4.c 12345678910111213141516171819202122232425262728293031323334353637383940struct proto `tcp_prot` = &#123; .name = \"TCP\", .owner = THIS_MODULE, .close = tcp_close, .connect = tcp_v4_connect, .disconnect = tcp_disconnect, .accept = inet_csk_accept, .ioctl = tcp_ioctl, .init = tcp_v4_init_sock, .destroy = tcp_v4_destroy_sock, .shutdown = tcp_shutdown, .setsockopt = tcp_setsockopt, .getsockopt = tcp_getsockopt, .recvmsg = tcp_recvmsg, .sendmsg = tcp_sendmsg, .sendpage = tcp_sendpage, .backlog_rcv = tcp_v4_do_rcv, .hash = inet_hash, .unhash = inet_unhash, .get_port = inet_csk_get_port, .enter_memory_pressure = tcp_enter_memory_pressure, .sockets_allocated = &amp;tcp_sockets_allocated, .orphan_count = &amp;tcp_orphan_count, .memory_allocated = &amp;tcp_memory_allocated, .memory_pressure = &amp;tcp_memory_pressure, .sysctl_mem = sysctl_tcp_mem, .sysctl_wmem = sysctl_tcp_wmem, .sysctl_rmem = sysctl_tcp_rmem, .max_header = MAX_TCP_HEADER, .`obj_size` = sizeof(struct tcp_sock), .slab_flags = SLAB_DESTROY_BY_RCU, .twsk_prot = &amp;tcp_timewait_sock_ops, .rsk_prot = &amp;tcp_request_sock_ops, .h.hashinfo = &amp;tcp_hashinfo, .no_autobind = true,#ifdef CONFIG_COMPAT .compat_setsockopt = compat_tcp_setsockopt, .compat_getsockopt = compat_tcp_getsockopt,#endif&#125;; 在inet_init函数中（af_inet.c文件）inet_init // net/ipv4/af_inet.c line:1609 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121static int __init inet_init(void)&#123; struct sk_buff *dummy_skb; struct inet_protosw *q; struct list_head *r; int rc = -EINVAL; BUILD_BUG_ON(sizeof(struct inet_skb_parm) &gt; sizeof(dummy_skb-&gt;cb)); sysctl_local_reserved_ports = kzalloc(65536 / 8, GFP_KERNEL); if (!sysctl_local_reserved_ports) goto out; // 该函数注册tcp_prot，在该函数中对tcp_prot-&gt;slab进行内存分配 rc = `proto_register`(&amp;tcp_prot, 1); // 详见 ---[5.1] if (rc) goto out_free_reserved_ports; rc = proto_register(&amp;udp_prot, 1); if (rc) goto out_unregister_tcp_proto; rc = proto_register(&amp;raw_prot, 1); if (rc) goto out_unregister_udp_proto; /* * Tell SOCKET that we are alive... */ (void)sock_register(&amp;inet_family_ops);#ifdef CONFIG_SYSCTL ip_static_sysctl_init();#endif /* * Add all the base protocols. */ if (inet_add_protocol(&amp;icmp_protocol, IPPROTO_ICMP) &lt; 0) printk(KERN_CRIT \"inet_init: Cannot add ICMP protocol\\n\"); if (inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; 0) printk(KERN_CRIT \"inet_init: Cannot add UDP protocol\\n\"); if (inet_add_protocol(&amp;tcp_protocol, IPPROTO_TCP) &lt; 0) printk(KERN_CRIT \"inet_init: Cannot add TCP protocol\\n\");#ifdef CONFIG_IP_MULTICAST if (inet_add_protocol(&amp;igmp_protocol, IPPROTO_IGMP) &lt; 0) printk(KERN_CRIT \"inet_init: Cannot add IGMP protocol\\n\");#endif /* Register the socket-side information for inet_create. */ // `inetsw 进行初始化操作 ` for (r = &amp;inetsw[0]; r &lt; &amp;inetsw[SOCK_MAX]; ++r) `INIT_LIST_HEAD`(r); //详见------[5.2] // `将 inetsw_array加入到对应的inetsw链表中，就可以在inet_create函数中进行遍历` for (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q) `inet_register_protosw`(q); // 详见------[5.3] /* * Set the ARP module up */ arp_init(); /* * Set the IP module up */ ip_init(); tcp_v4_init(); /* Setup TCP slab cache for open requests. */ tcp_init(); /* Setup UDP memory threshold */ udp_init(); /* Add UDP-Lite (RFC 3828) */ udplite4_register(); /* * Set the ICMP layer up */ if (icmp_init() &lt; 0) panic(\"Failed to create the ICMP control socket.\\n\"); /* * Initialise the multicast router */#if defined(CONFIG_IP_MROUTE) if (ip_mr_init()) printk(KERN_CRIT \"inet_init: Cannot init ipv4 mroute\\n\");#endif /* * Initialise per-cpu ipv4 mibs */ if (init_ipv4_mibs()) printk(KERN_CRIT \"inet_init: Cannot init ipv4 mibs\\n\"); ipv4_proc_init(); ipfrag_init(); dev_add_pack(&amp;ip_packet_type); rc = 0;out: return rc;out_unregister_udp_proto: proto_unregister(&amp;udp_prot);out_unregister_tcp_proto: proto_unregister(&amp;tcp_prot);out_free_reserved_ports: kfree(sysctl_local_reserved_ports); goto out;&#125; *5.1、proto_register *proto_register 注册函数 // net/core/sock.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970int proto_register(struct proto *prot, int alloc_slab)&#123; if (alloc_slab) &#123; // prot-&gt;obj_size 为`.obj = sizeof(struct tcp_sock)` prot-&gt;slab = `kmem_cache_create`(prot-&gt;name, prot-&gt;obj_size, 0, SLAB_HWCACHE_ALIGN | prot-&gt;slab_flags, NULL); if (prot-&gt;slab == NULL) &#123; printk(KERN_CRIT \"%s: Can't create sock SLAB cache!\\n\", prot-&gt;name); goto out; &#125; if (prot-&gt;rsk_prot != NULL) &#123; prot-&gt;rsk_prot-&gt;slab_name = kasprintf(GFP_KERNEL, \"request_sock_%s\", prot-&gt;name); if (prot-&gt;rsk_prot-&gt;slab_name == NULL) goto out_free_sock_slab; prot-&gt;rsk_prot-&gt;slab = kmem_cache_create(prot-&gt;rsk_prot-&gt;slab_name, prot-&gt;rsk_prot-&gt;obj_size, 0, SLAB_HWCACHE_ALIGN, NULL); if (prot-&gt;rsk_prot-&gt;slab == NULL) &#123; printk(KERN_CRIT \"%s: Can't create request sock SLAB cache!\\n\", prot-&gt;name); goto out_free_request_sock_slab_name; &#125; &#125; if (prot-&gt;twsk_prot != NULL) &#123; prot-&gt;twsk_prot-&gt;twsk_slab_name = kasprintf(GFP_KERNEL, \"tw_sock_%s\", prot-&gt;name); if (prot-&gt;twsk_prot-&gt;twsk_slab_name == NULL) goto out_free_request_sock_slab; prot-&gt;twsk_prot-&gt;twsk_slab = kmem_cache_create(prot-&gt;twsk_prot-&gt;twsk_slab_name, prot-&gt;twsk_prot-&gt;twsk_obj_size, 0, SLAB_HWCACHE_ALIGN | prot-&gt;slab_flags, NULL); if (prot-&gt;twsk_prot-&gt;twsk_slab == NULL) goto out_free_timewait_sock_slab_name; &#125; &#125; write_lock(&amp;proto_list_lock); list_add(&amp;prot-&gt;node, &amp;proto_list); assign_proto_idx(prot); write_unlock(&amp;proto_list_lock); return 0;out_free_timewait_sock_slab_name: kfree(prot-&gt;twsk_prot-&gt;twsk_slab_name);out_free_request_sock_slab: if (prot-&gt;rsk_prot &amp;&amp; prot-&gt;rsk_prot-&gt;slab) &#123; kmem_cache_destroy(prot-&gt;rsk_prot-&gt;slab); prot-&gt;rsk_prot-&gt;slab = NULL; &#125;out_free_request_sock_slab_name: if (prot-&gt;rsk_prot) kfree(prot-&gt;rsk_prot-&gt;slab_name);out_free_sock_slab: kmem_cache_destroy(prot-&gt;slab); prot-&gt;slab = NULL;out: return -ENOBUFS;&#125; 5.2、INIT_LIST_HEAD12345static inline void INIT_LIST_HEAD(struct list_head *list)&#123; list-&gt;next = list; list-&gt;prev = list;&#125; 5.3、inet_register_protosw1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void inet_register_protosw(struct inet_protosw *p)&#123; struct list_head *lh; struct inet_protosw *answer; int protocol = p-&gt;protocol; struct list_head *last_perm; spin_lock_bh(&amp;inetsw_lock); if (p-&gt;type &gt;= SOCK_MAX) goto out_illegal; /* If we are trying to override a permanent protocol, bail. */ answer = NULL; last_perm = &amp;inetsw[p-&gt;type]; list_for_each(lh, &amp;inetsw[p-&gt;type]) &#123; answer = list_entry(lh, struct inet_protosw, list); /* Check only the non-wild match. */ if (INET_PROTOSW_PERMANENT &amp; answer-&gt;flags) &#123; if (protocol == answer-&gt;protocol) break; last_perm = lh; &#125; answer = NULL; &#125; if (answer) goto out_permanent; /* Add the new entry after the last permanent entry if any, so that * the new entry does not override a permanent entry when matched with * a wild-card protocol. But it is allowed to override any existing * non-permanent entry. This means that when we remove this entry, the * system automatically returns to the old behavior. */ list_add_rcu(&amp;p-&gt;list, last_perm);out: spin_unlock_bh(&amp;inetsw_lock); return;out_permanent: printk(KERN_ERR \"Attempt to override permanent protocol %d.\\n\", protocol); goto out;out_illegal: printk(KERN_ERR \"Ignoring attempt to register invalid socket type %d.\\n\", p-&gt;type); goto out;&#125; 6、sock_map_fd函数 在用户控件控件创建了一个socket后，返回值是一个文件描述符，下面分析一下创建socket时怎么和文件描述符联系，在SYSCLALL_DEFINE3(socket,int,family,int,type,int,portocol)最后调用socke_map_fd进行关联，其中返回的retval就是用户控件获取的文件描述符fd,sock就是调用sock_create创建成功的socket。 sock_map_fd()主要用于对socket的file指针初始化，经过sock_map_fd()操作后，socket就通过其file指针与VFS管理的文件进行了关联，便可以进行文件的各种操作，如read,write,lessk,ioctl等。 retval = sock_map_fd(sock,flag&amp;(O_CLOEXEC|O_NOBLOCK));sock_map_fd函数 // net/socket.c line:395 12345678910int sock_map_fd(struct socket *sock, int flags)&#123; struct file *newfile; int fd = `sock_alloc_file`(sock, &amp;newfile, flags); if (likely(fd &gt;= 0)) fd_install(fd, newfile); return fd;&#125; 6.1、sock_alloc_file函数sock_alloc_file函数 // net/socket.c line:354 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* * Obtains the first available file descriptor and sets it up for use. * * These functions create file structures and maps them to fd space * of the current process. On success it returns file descriptor * and file struct implicitly stored in sock-&gt;file. * Note that another thread may close file descriptor before we return * from this function. We use the fact that now we do not refer * to socket after mapping. If one day we will need it, this * function will increment ref. count on file by 1. * * In any case returned fd MAY BE not valid! * This race condition is unavoidable * with shared fd spaces, we cannot solve it inside kernel, * but we take care of internal coherence yet. */static int sock_alloc_file(struct socket *sock, struct file **f, int flags)&#123; struct qstr name = &#123; .name = \"\" &#125;; struct path path; struct file *file; int fd; /* * #define get_unused_fd_flags(flags) `alloc_fd`(0, (flags)) * // include/linux/file.h */ fd = `get_unused_fd_flags`(flags); if (unlikely(fd &lt; 0)) return fd; path.dentry = d_alloc(sock_mnt-&gt;mnt_sb-&gt;s_root, &amp;name); if (unlikely(!path.dentry)) &#123; put_unused_fd(fd); return -ENOMEM; &#125; path.mnt = mntget(sock_mnt); path.dentry-&gt;d_op = &amp;sockfs_dentry_operations; /* * 将文件操作的函数绑定到inode,对于dentry是在socket_mount函数中socket_dentry_operations，该函数在sock_init中调用 */ d_instantiate(path.dentry, SOCK_INODE(sock)); SOCK_INODE(sock)-&gt;i_fop = &amp;socket_file_ops; /* * 申请新的file,将path和file关联起来 */ file = alloc_file(&amp;path, FMODE_READ | FMODE_WRITE, &amp;socket_file_ops); if (unlikely(!file)) &#123; /* drop dentry, keep inode */ atomic_inc(&amp;path.dentry-&gt;d_inode-&gt;i_count); path_put(&amp;path); put_unused_fd(fd); return -ENFILE; &#125; sock-&gt;file = file; file-&gt;f_flags = O_RDWR | (flags &amp; O_NONBLOCK); file-&gt;f_pos = 0; file-&gt;private_data = sock; *f = file; return fd;&#125; 6.2、get_unused_fd_flags宏实现get_unused_fd_flags 宏 // include/linux/file.h line:36 1#define get_unused_fd_flags(flags) alloc_fd(0, (flags)) alloc_fd函数 // fs/file.c line:427 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* * allocate a file descriptor, mark it busy. */int alloc_fd(unsigned start, unsigned flags)&#123; struct files_struct *files = current-&gt;files; unsigned int fd; int error; struct fdtable *fdt; spin_lock(&amp;files-&gt;file_lock);repeat: /* 得到本进程的文件描述符 */ fdt = `files_fdtable`(files); fd = start; // 从start开始,这里start为0 /* * files-&gt;next_fd为上一次确定的下一个可用空闲的文件描述符，这里可以提高获取的效率，如果fd小于files-&gt;next_fd的话就可以直接使用next_fd; */ if (fd &lt; files-&gt;next_fd) fd = files-&gt;next_fd; /* * 当fd小于目前进程支持的最大的描述符号，那么可以通过fds_bit位图，从fd位开始查找，找到下一位0位，即下一个空闲描述符 */ if (fd &lt; fdt-&gt;max_fds) fd = find_next_zero_bit(fdt-&gt;open_fds-&gt;fds_bits, fdt-&gt;max_fds, fd); /* * 如需要则扩展文件描述符表 */ error = expand_files(files, fd); if (error &lt; 0) goto out; /* * If we needed to expand the fs array we * might have blocked - try again. */ if (error) goto repeat; /* * 设置next_fd，用于下次加速查找空闲的fd * 当start大于next_fd时，不会设置next_fd以避免文件描述符的不连续。 */ if (start &lt;= files-&gt;next_fd) files-&gt;next_fd = fd + 1; /* * 将fd添加到一打开的文件描述符表中 */ FD_SET(fd, fdt-&gt;open_fds); if (flags &amp; O_CLOEXEC) FD_SET(fd, fdt-&gt;close_on_exec); else FD_CLR(fd, fdt-&gt;close_on_exec); error = fd; /* Sanity check */ if (rcu_dereference_raw(fdt-&gt;fd[fd]) != NULL) &#123; printk(KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\", fd); rcu_assign_pointer(fdt-&gt;fd[fd], NULL); &#125;out: spin_unlock(&amp;files-&gt;file_lock); return error;&#125; 二、绑定bind1、SYSCALL_DEFINE3(bind,…) bind系统调用通过SYSCALL_DEFINE3调用各个协议不同的bind函数。SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen) // net/socket.c line:1394 123456789101112131415161718192021SYSCALL_DEFINE3(`bind`, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)&#123; struct socket *sock; struct sockaddr_storage address; int err, fput_needed; sock = `sockfd_lookup_light`(fd, &amp;err, &amp;fput_needed); // 根据文件描述符fd,查找相应套接字socket if (sock) &#123; err = `move_addr_to_kernel`(umyaddr, addrlen, (struct sockaddr *)&amp;address); if (err &gt;= 0) &#123; err = security_socket_bind(sock, (struct sockaddr *)&amp;address, addrlen); if (!err) err = `sock-&gt;ops-&gt;bind`(sock, (struct sockaddr *) &amp;address, addrlen); &#125; fput_light(sock-&gt;file, fput_needed); &#125; return err;&#125; 2、sockfd_lookup_light函数sockfd_lookup_light函数 //net/socket.c line:447 123456789101112131415static struct socket *sockfd_lookup_light(int fd, int *err, int *fput_needed)&#123; struct file *file; struct socket *sock; *err = -EBADF; file = `fget_light`(fd, fput_needed); //通过fd获取struct file结构体 if (file) &#123; sock = `sock_from_file`(file, err); //返回套接字所对应的存储在file-&gt;private_date;在sock_aloc_file函数中对其进行赋值 if (sock) return sock; fput_light(file, *fput_needed); &#125; return NULL;&#125; 3、inet_bind函数 sock-&gt;ops-&gt;bind实际调用为inet_bind。sock-&gt;ops-&gt;bind赋值过程。 在创建TCP类型的socket时，进行了下面的赋值初始化操作，这里的bind定义为inet_bind()函数。inetsw_array结构体数组 // net/ipv4/af_inet.c 12345678910111213141516171819202122232425262728293031static struct inet_protosw `inetsw_array`[] =&#123; &#123; .type = SOCK_STREAM, .protocol = IPPROTO_TCP, .prot = &amp;tcp_prot, .`ops = &amp;inet_stream_ops`, .no_check = 0, .flags = INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK, &#125;, &#123; .type = SOCK_DGRAM, .protocol = IPPROTO_UDP, .prot = &amp;udp_prot, .ops = &amp;inet_dgram_ops, .no_check = UDP_CSUM_DEFAULT, .flags = INET_PROTOSW_PERMANENT, &#125;, &#123; .type = SOCK_RAW, .protocol = IPPROTO_IP, /* wild card */ .prot = &amp;raw_prot, .ops = &amp;inet_sockraw_ops, .no_check = UDP_CSUM_DEFAULT, .flags = INET_PROTOSW_REUSE, &#125;&#125;; inet_stream_ops // net/ipv4/af_inet.c 12345678910111213141516171819202122232425const struct proto_ops inet_stream_ops = &#123; .family = PF_INET, .owner = THIS_MODULE, .release = inet_release, .`bind = inet_bind`, .connect = inet_stream_connect, .socketpair = sock_no_socketpair, .accept = inet_accept, .getname = inet_getname, .poll = tcp_poll, .ioctl = inet_ioctl, .listen = inet_listen, .shutdown = inet_shutdown, .setsockopt = sock_common_setsockopt, .getsockopt = sock_common_getsockopt, .sendmsg = inet_sendmsg, .recvmsg = inet_recvmsg, .mmap = sock_no_mmap, .sendpage = inet_sendpage, .splice_read = tcp_splice_read,#ifdef CONFIG_COMPAT .compat_setsockopt = compat_sock_common_setsockopt, .compat_getsockopt = compat_sock_common_getsockopt,#endif&#125;; inet_dgram_ops // net/ipv4/af_inet.c 123456789101112131415161718192021222324const struct proto_ops inet_dgram_ops = &#123; .family = PF_INET, .owner = THIS_MODULE, .release = inet_release, .`bind = inet_bind`, .connect = inet_dgram_connect, .socketpair = sock_no_socketpair, .accept = sock_no_accept, .getname = inet_getname, .poll = udp_poll, .ioctl = inet_ioctl, .listen = sock_no_listen, .shutdown = inet_shutdown, .setsockopt = sock_common_setsockopt, .getsockopt = sock_common_getsockopt, .sendmsg = inet_sendmsg, .recvmsg = inet_recvmsg, .mmap = sock_no_mmap, .sendpage = inet_sendpage,#ifdef CONFIG_COMPAT .compat_setsockopt = compat_sock_common_setsockopt, .compat_getsockopt = compat_sock_common_getsockopt,#endif&#125;; inet_sockraw_ops // net/ipv4/af_inet.c 123456789101112131415161718192021222324static const struct proto_ops inet_sockraw_ops = &#123; .family = PF_INET, .owner = THIS_MODULE, .release = inet_release, .`bind = inet_bind`, .connect = inet_dgram_connect, .socketpair = sock_no_socketpair, .accept = sock_no_accept, .getname = inet_getname, .poll = datagram_poll, .ioctl = inet_ioctl, .listen = sock_no_listen, .shutdown = inet_shutdown, .setsockopt = sock_common_setsockopt, .getsockopt = sock_common_getsockopt, .sendmsg = inet_sendmsg, .recvmsg = inet_recvmsg, .mmap = sock_no_mmap, .sendpage = inet_sendpage,#ifdef CONFIG_COMPAT .compat_setsockopt = compat_sock_common_setsockopt, .compat_getsockopt = compat_sock_common_getsockopt,#endif&#125;; 3.1、inet_bind函数inet_bind函数 // net/ipv4/af_inet.c line:453 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102int inet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)&#123; struct sockaddr_in *addr = (struct sockaddr_in *)uaddr; //要绑定的sockaddr_in结构体 struct sock *sk = sock-&gt;sk; struct inet_sock *inet = inet_sk(sk); unsigned short snum; //绑定的端口 int chk_addr_ret; //地址类型 int err; /* If the socket has its own bind function then use it. (RAW) *//* * 对于RAW类型的socket，调用raw socket自己的bind函数 raw_bind */ if (`sk-&gt;sk_prot-&gt;bind`) &#123; err = sk-&gt;sk_prot-&gt;bind(sk, uaddr, addr_len); goto out; &#125; err = -EINVAL; if (addr_len &lt; sizeof(struct sockaddr_in)) // sockaddr_in长度错误 goto out; chk_addr_ret = inet_addr_type(sock_net(sk), addr-&gt;sin_addr.s_addr); //地址类型检查，看看是否回环地址，多播地址，组播地址，在下面的判断中需要使用到 /* Not specified by any standard per-se, however it breaks too * many applications when removed. It is unfortunate since * allowing applications to make a non-local bind solves * several problems with systems using dynamic addressing. * (ie. your servers still start up even if your ISDN link * is temporarily down) */ err = -EADDRNOTAVAIL; /* * sysctl_ip_nonlocal_bind表明是否允许绑定非本地的IP地址，默认为0，不允许绑定 * # cd /proc/sys/net/ipv4 * # cat ip_nonlocal_bind 0 * 以上注释说明了使用费本地地址绑定可以解决一些使用动态地址绑定的服务器程 * 序，所有这个实现还是有实际意义的。 * inet-&gt;freebind是通过do_ip_setsockopt函数进行设置的，默认值为1，改值表示允许 * 绑定一个非本地IP地址和不存在的IP地址，可以通过IP_FREEBIND设置 * inet-&gt;tarnsparent 含义就是可以使用一个服务器程序监听所有的IP地址，哪怕不是 * 本地的IP地址 */ if (!sysctl_ip_nonlocal_bind &amp;&amp; !(inet-&gt;freebind || inet-&gt;transparent) &amp;&amp; addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY) &amp;&amp; chk_addr_ret != RTN_LOCAL &amp;&amp; chk_addr_ret != RTN_MULTICAST &amp;&amp; chk_addr_ret != RTN_BROADCAST) goto out; snum = ntohs(addr-&gt;sin_port); //获取绑定端口号 err = -EACCES; /* * 如果要绑定`0-1023`之内的端口号，需要用户具有CAP_NET_BIND_SERVICE权限，PROT_SOCK就是1024 */ if (snum &amp;&amp; snum &lt; PROT_SOCK &amp;&amp; !capable(CAP_NET_BIND_SERVICE)) goto out; /* We keep a pair of addresses. rcv_saddr is the one * used by hash lookups, and saddr is used for transmit. * * In the BSD API these are the same except where it * would be illegal to use them (multicast/broadcast) in * which case the sending device address is used. */ lock_sock(sk); /* Check these errors (active socket, double bind). */ err = -EINVAL; /* * 判断sk_state的状态十分为TCP_CLOSE,在创建socket时，sk_state初始为TCP_CLOSE，如果不等于TCP_CLOSE说明已经bind过，而num只有当raw socket时才不为0 */ if (sk-&gt;sk_state != TCP_CLOSE || inet-&gt;inet_num) goto out_release_sock; inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr; //需要绑定的地址 if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST) inet-&gt;inet_saddr = 0; /* Use device */ /* Make sure we are allowed to bind here. */ /* * 调用四层的bind函数，对于TCP来说，就是inet_csk_get_port */ if (`sk-&gt;sk_prot-&gt;get_port`(sk, snum)) &#123; inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = 0; err = -EADDRINUSE; goto out_release_sock; &#125; if (inet-&gt;inet_rcv_saddr) sk-&gt;sk_userlocks |= SOCK_BINDADDR_LOCK; //设置sk中的sk-&gt;userlocks表示绑定地址 if (snum) sk-&gt;sk_userlocks |= SOCK_BINDPORT_LOCK; //设置sk中的sk-&gt;userlocks表示绑定端口 inet-&gt;inet_sport = htons(inet-&gt;inet_num); inet-&gt;inet_daddr = 0; inet-&gt;inet_dport = 0; sk_dst_reset(sk); err = 0;out_release_sock: release_sock(sk);out: return err; 3.2、sk-&gt;sk_prot-&gt;bind赋值 sk-&gt;sk_prot-&gt;bind成员赋值，由以下tcp_prot、udp_prot和raw_prot三个proto结构体变量的各个成员赋值可值，tcp_prot和udp_prot变量不存在bind成员赋值，只有raw_prot变量存在bind成员赋值且.bind = raw_bind。tcp_prot // net/ipv4/tcp_ipv4.c line:2601 12345678910111213141516171819202122232425262728293031323334353637383940struct proto tcp_prot = &#123; .name = `\"TCP\"`, .owner = THIS_MODULE, .close = tcp_close, .connect = tcp_v4_connect, .disconnect = tcp_disconnect, .accept = inet_csk_accept, .ioctl = tcp_ioctl, .init = tcp_v4_init_sock, .destroy = tcp_v4_destroy_sock, .shutdown = tcp_shutdown, .setsockopt = tcp_setsockopt, .getsockopt = tcp_getsockopt, .recvmsg = tcp_recvmsg, .sendmsg = tcp_sendmsg, .sendpage = tcp_sendpage, .backlog_rcv = tcp_v4_do_rcv, .hash = inet_hash, .unhash = inet_unhash, .`get_port = inet_csk_get_port`, .enter_memory_pressure = tcp_enter_memory_pressure, .sockets_allocated = &amp;tcp_sockets_allocated, .orphan_count = &amp;tcp_orphan_count, .memory_allocated = &amp;tcp_memory_allocated, .memory_pressure = &amp;tcp_memory_pressure, .sysctl_mem = sysctl_tcp_mem, .sysctl_wmem = sysctl_tcp_wmem, .sysctl_rmem = sysctl_tcp_rmem, .max_header = MAX_TCP_HEADER, .obj_size = sizeof(struct tcp_sock), .slab_flags = SLAB_DESTROY_BY_RCU, .twsk_prot = &amp;tcp_timewait_sock_ops, .rsk_prot = &amp;tcp_request_sock_ops, .h.hashinfo = &amp;tcp_hashinfo, .no_autobind = true,#ifdef CONFIG_COMPAT .compat_setsockopt = compat_tcp_setsockopt, .compat_getsockopt = compat_tcp_getsockopt,#endif&#125;; udp_prot // net/ipv4/udp.c line:1860 123456789101112131415161718192021222324252627282930struct proto udp_prot = &#123; .name = `\"UDP\"`, .owner = THIS_MODULE, .close = udp_lib_close, .connect = ip4_datagram_connect, .disconnect = udp_disconnect, .ioctl = udp_ioctl, .destroy = udp_destroy_sock, .setsockopt = udp_setsockopt, .getsockopt = udp_getsockopt, .sendmsg = udp_sendmsg, .recvmsg = udp_recvmsg, .sendpage = udp_sendpage, .backlog_rcv = __udp_queue_rcv_skb, .hash = udp_lib_hash, .unhash = udp_lib_unhash, .rehash = udp_v4_rehash, .`get_port = udp_v4_get_port`, .memory_allocated = &amp;udp_memory_allocated, .sysctl_mem = sysctl_udp_mem, .sysctl_wmem = &amp;sysctl_udp_wmem_min, .sysctl_rmem = &amp;sysctl_udp_rmem_min, .obj_size = sizeof(struct udp_sock), .slab_flags = SLAB_DESTROY_BY_RCU, .h.udp_table = &amp;udp_table,#ifdef CONFIG_COMPAT .compat_setsockopt = compat_udp_setsockopt, .compat_getsockopt = compat_udp_getsockopt,#endif&#125;; raw_port //net/ipv4/raw.c line:842 123456789101112131415161718192021222324struct proto raw_prot = &#123; .name = `\"RAW\"`, .owner = THIS_MODULE, .close = raw_close, .destroy = raw_destroy, .connect = ip4_datagram_connect, .disconnect = udp_disconnect, .ioctl = raw_ioctl, .init = raw_init, .setsockopt = raw_setsockopt, .getsockopt = raw_getsockopt, .sendmsg = raw_sendmsg, .recvmsg = raw_recvmsg, .`bind = raw_bind`, .backlog_rcv = raw_rcv_skb, .hash = raw_hash_sk, .unhash = raw_unhash_sk, .obj_size = sizeof(struct raw_sock), .h.raw_hash = &amp;raw_v4_hashinfo,#ifdef CONFIG_COMPAT .compat_setsockopt = compat_raw_setsockopt, .compat_getsockopt = compat_raw_getsockopt,#endif&#125;; 通过以上tcp_prot、udp_prot和raw_prot发现，在tcp_prot和udp_prot不存在bind成员，而存在get_prot成员。raw_prot中存在bind成员。这也是inet_bind函数中判断sk-&gt;sk_prot-&gt;bind是否存在，存在则调用自身的bind函数。对于tcp和udp socket，inet_bind函数随后会调用sk-&gt;sk_prot-&gt;get_port即inet_csk_get_port（tcp）或udp_v4_get_port(udp); 4、inet_csk_get_port函数 inet_csk_get_port函数为TCP套接字sk-&gt;sk_prot-&gt;get_port的赋值。inet_csk_get_port // net/ipv4/tcp_ipv4.c line:2621 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144/* Obtain a reference to a local port for the given sock, * if snum is zero it means select any available local port. */int inet_csk_get_port(struct sock *sk, unsigned short snum)&#123; /* * TCP散列表管理结构实例tcp_hashinfo,在tcp.c文件中tcp_init函数中进行初始化 * 工作，在tcp_ipv4.c文件中，struct proto tcp_prot结构体对其进行赋值 * .h.hasinfo=&amp;tcp_hashinfo; */ struct inet_hashinfo *hashinfo = sk-&gt;sk_prot-&gt;h.hashinfo; struct `inet_bind_hashbucket` *head; struct hlist_node *node; struct inet_bind_bucket *tb; int ret, attempts = 5; struct net *net = sock_net(sk); int smallest_size = -1, smallest_rover; local_bh_disable(); if (!snum) &#123; //如果用户绑定端口为0，就选择一个可用的本地端口 int remaining, rover, low, high;again: `inet_get_local_port_range`(&amp;low, &amp;high); //获取本地可以使用的端口范围 remaining = (high - low) + 1; //最大重新分配次数 smallest_rover = rover = net_random() % remaining + low; // 随机生成端口号赋值给rover smallest_size = -1; /* * while循环代码是根据获取到的空闲的端口号和bhash_size从bhash上取得HASH值对应 * 的链表，然后遍历链表，对比链表中是否有获取到的空闲端口，如果存在该端口，说明 * 获取的该端口号已经被占用，如果已经被占用就将获取的+1,如果大于最大值，则从最 * 小值开始重新遍历端口列表，知道尝试成功次数为remaining * */ do &#123; if (inet_is_reserved_local_port(rover)) //如果是保留端口直接寻找下一接口 goto next_nolock; head = &amp;hashinfo-&gt;bhash[inet_bhashfn(net, rover, hashinfo-&gt;bhash_size)]; spin_lock(&amp;head-&gt;lock); inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain) if (net_eq(ib_net(tb), net) &amp;&amp; tb-&gt;port == rover) &#123; /* * 判断端口是否可以被复用，如果可以被复用即使在绑定表中，*也优先使用可以复用的端口 */ if (`tb`-&gt;fastreuse &gt; 0 &amp;&amp; sk-&gt;sk_reuse &amp;&amp; sk-&gt;sk_state != TCP_LISTEN &amp;&amp; (tb-&gt;num_owners &lt; smallest_size || smallest_size == -1)) &#123; smallest_size = tb-&gt;num_owners; //记录端口使用者的次数 smallest_rover = rover; /* * 如果绑定端口的个数大于端口的可用个数，就回判断是否绑定冲突 */ if (atomic_read(&amp;hashinfo-&gt;bsockets) &gt; (high - low) + 1) &#123; spin_unlock(&amp;head-&gt;lock); snum = smallest_rover; goto have_snum; &#125; &#125; goto next; &#125; break; next: spin_unlock(&amp;head-&gt;lock); next_nolock: if (++rover &gt; high) rover = low; &#125; while (--remaining &gt; 0); /* Exhausted local port range during search? It is not * possible for us to be holding one of the bind hash * locks if this test triggers, because if 'remaining' * drops to zero, we broke out of the do/while loop at * the top level, not from the 'break;' statement. */ ret = 1; if (remaining &lt;= 0) &#123; //如果没有查找到，再给次机会 if (smallest_size != -1) &#123; snum = smallest_rover; goto have_snum; &#125; goto fail; &#125; /* OK, here is the one we will use. HEAD is * non-NULL and we hold it's mutex. */ snum = rover; //找到绑定端口号 &#125; else &#123; //如果指定端口号，则在相应的链表中进行查询have_snum: head = &amp;hashinfo-&gt;bhash[inet_bhashfn(net, snum, hashinfo-&gt;bhash_size)]; spin_lock(&amp;head-&gt;lock); inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain) if (net_eq(ib_net(tb), net) &amp;&amp; tb-&gt;port == snum) goto tb_found; // 在绑定表中查找，表示该端口已经绑定 &#125; tb = NULL; //如果指定的端口在绑定表中没有发现，直接创建 goto tb_not_found;tb_found: if (!hlist_empty(&amp;tb-&gt;owners)) &#123; if (tb-&gt;fastreuse &gt; 0 &amp;&amp; sk-&gt;sk_reuse &amp;&amp; sk-&gt;sk_state != TCP_LISTEN &amp;&amp; smallest_size == -1) &#123; goto success; &#125; else &#123; ret = 1; if (`inet_csk(sk)-&gt;icsk_af_ops-&gt;bind_conflict`(sk, tb)) &#123; // 调用inet_csk_bind_conflict 函数 if (sk-&gt;sk_reuse &amp;&amp; sk-&gt;sk_state != TCP_LISTEN &amp;&amp; smallest_size != -1 &amp;&amp; --attempts &gt;= 0) &#123; spin_unlock(&amp;head-&gt;lock); goto again; &#125; goto fail_unlock; &#125; &#125; &#125;tb_not_found: ret = 1; //如果在绑定表中没有发现，则创建 if (!tb &amp;&amp; (tb = `inet_bind_bucket_create`(hashinfo-&gt;bind_bucket_cachep, net, head, snum)) == NULL) goto fail_unlock; if (hlist_empty(&amp;tb-&gt;owners)) &#123; //如果没有绑定socket if (sk-&gt;sk_reuse &amp;&amp; sk-&gt;sk_state != TCP_LISTEN) tb-&gt;fastreuse = 1; else tb-&gt;fastreuse = 0; &#125; else if (tb-&gt;fastreuse &amp;&amp; (!sk-&gt;sk_reuse || sk-&gt;sk_state == TCP_LISTEN)) tb-&gt;fastreuse = 0;success: //如果成功找到一个可用的端口，添加到绑定表中 if (!inet_csk(sk)-&gt;icsk_bind_hash) `inet_bind_hash`(sk, tb, snum); // 把当前的sock插入到woers WARN_ON(inet_csk(sk)-&gt;icsk_bind_hash != tb); ret = 0;fail_unlock: spin_unlock(&amp;head-&gt;lock);fail: local_bh_enable(); return ret;&#125; 4.1、inet_get_local_port_range函数inet_get_local_port_range // net/ipv4/inet_connection_sock.c line:43 12345678910void inet_get_local_port_range(int *low, int *high)&#123; unsigned seq; do &#123; seq = read_seqbegin(&amp;sysctl_local_ports.lock); *low = sysctl_local_ports.range[0]; *high = sysctl_local_ports.range[1]; &#125; while (read_seqretry(&amp;sysctl_local_ports.lock, seq));&#125; sysctl_local_ports // net/ipv4/inet_connection_sock.c line:35 1234567/* * This struct holds the first and last local port number. */struct local_ports sysctl_local_ports __read_mostly = &#123; .lock = SEQLOCK_UNLOCKED, .range = &#123; 32768, 61000 &#125;,&#125;; inet_get_local_port_range()获取本地可用端口的范围，由sysctl_local_ports定义可以知道端口的范围为32768-61000。如果用户控件绑定的本地端口为0的话，会自动为套接字分配一个可以的端口。 4.2、本地端口可以被复用的条件本地端口可以被复用的几个条件如下： 1、绑定到不同接口的Sockets可以复用本地端口 2、如果所有Sockets都设置sk-&gt;sk_reuse,并且都不在TCP_LISTEN状态，可以复用端口 3、如果所有Socket绑定在一个特定的inet_sk(sk)-&gt;rcv_saddr本地地址，并且地址都不相同，可以复用 inet_bind_bucket结构体 // include/net/inet_hashtables.h 1234567891011121314151617181920212223242526272829303132333435363738394041/* There are a few simple rules, which allow for local port reuse by * an application. In essence: * * 1) Sockets bound to different interfaces may share a local port. * Failing that, goto test 2. * 2) If all sockets have sk-&gt;sk_reuse set, and none of them are in * TCP_LISTEN state, the port may be shared. * Failing that, goto test 3. * 3) If all sockets are bound to a specific inet_sk(sk)-&gt;rcv_saddr local * address, and none of them are the same, the port may be * shared. * Failing this, the port cannot be shared. * * The interesting point, is test #2. This is what an FTP server does * all day. To optimize this case we use a specific flag bit defined * below. As we add sockets to a bind bucket list, we perform a * check of: (newsk-&gt;sk_reuse &amp;&amp; (newsk-&gt;sk_state != TCP_LISTEN)) * As long as all sockets added to a bind bucket pass this test, * the flag bit will be set. * The resulting situation is that tcp_v[46]_verify_bind() can just check * for this flag bit, if it is set and the socket trying to bind has * sk-&gt;sk_reuse set, we don't even have to walk the owners list at all, * we return that it is ok to bind this socket to the requested local port. * * Sounds like a lot of work, but it is worth it. In a more naive * implementation (ie. current FreeBSD etc.) the entire list of ports * must be walked for each data port opened by an ftp server. Needless * to say, this does not scale at all. With a couple thousand FTP * users logged onto your box, isn't it nice to know that new data * ports are created in O(1) time? I thought so. ;-) -DaveM */struct inet_bind_bucket &#123;#ifdef CONFIG_NET_NS struct net *ib_net;#endif unsigned short port; signed short fastreuse; int num_owners; struct hlist_node node; struct hlist_head owners;&#125;; 4.3、inet_csk(sk)-&gt;icsk_af_ops-&gt;bind_conflict(sk, tb)调用bind_conflict赋值 // net/ipv4/tcp_ipv4.c line:1825 123456789101112131415161718const struct inet_connection_sock_af_ops `ipv4_specific` = &#123; .queue_xmit = ip_queue_xmit, .send_check = tcp_v4_send_check, .rebuild_header = inet_sk_rebuild_header, .conn_request = tcp_v4_conn_request, .syn_recv_sock = tcp_v4_syn_recv_sock, .remember_stamp = tcp_v4_remember_stamp, .net_header_len = sizeof(struct iphdr), .setsockopt = ip_setsockopt, .getsockopt = ip_getsockopt, .addr2sockaddr = inet_csk_addr2sockaddr, .sockaddr_len = sizeof(struct sockaddr_in), `.bind_conflict = inet_csk_bind_conflict`, #ifdef CONFIG_COMPAT .compat_setsockopt = compat_ip_setsockopt, .compat_getsockopt = compat_ip_getsockopt,#endif&#125;; 由第一章4.3节中tcp_v4_init_sock函数可知ipv4_specific被赋值于icsk-&gt;icsk_af_ops = &ipv4_specific;而struct inet_connection_sock *icsk = inet_csk(sk); 代码如下： tcp_v4_init_sock函数同第一章4.3节 // net/ipv4/tcp_ipv4.c line:1857 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* NOTE: A lot of things set to zero explicitly by call to * sk_alloc() so need not be done here. */static int tcp_v4_init_sock(struct sock *sk)&#123; struct inet_connection_sock `*icsk = inet_csk(sk)`; struct tcp_sock *tp = tcp_sk(sk); skb_queue_head_init(&amp;tp-&gt;out_of_order_queue); tcp_init_xmit_timers(sk); tcp_prequeue_init(tp); icsk-&gt;icsk_rto = TCP_TIMEOUT_INIT; tp-&gt;mdev = TCP_TIMEOUT_INIT; /* So many TCP implementations out there (incorrectly) count the * initial SYN frame in their delayed-ACK and congestion control * algorithms that we must have the following bandaid to talk * efficiently to them. -DaveM */ tp-&gt;snd_cwnd = 2; /* See draft-stevens-tcpca-spec-01 for discussion of the * initialization of these values. */ tp-&gt;snd_ssthresh = TCP_INFINITE_SSTHRESH; tp-&gt;snd_cwnd_clamp = ~0; tp-&gt;mss_cache = TCP_MSS_DEFAULT; tp-&gt;reordering = sysctl_tcp_reordering; icsk-&gt;icsk_ca_ops = &amp;tcp_init_congestion_ops; sk-&gt;sk_state = TCP_CLOSE; sk-&gt;sk_write_space = sk_stream_write_space; sock_set_flag(sk, SOCK_USE_WRITE_QUEUE); `icsk-&gt;icsk_af_ops = &amp;ipv4_specific;` icsk-&gt;icsk_sync_mss = tcp_sync_mss;#ifdef CONFIG_TCP_MD5SIG tp-&gt;af_specific = &amp;tcp_sock_ipv4_specific;#endif /* TCP Cookie Transactions */ if (sysctl_tcp_cookie_size &gt; 0) &#123; /* Default, cookies without s_data_payload. */ tp-&gt;cookie_values = kzalloc(sizeof(*tp-&gt;cookie_values), sk-&gt;sk_allocation); if (tp-&gt;cookie_values != NULL) kref_init(&amp;tp-&gt;cookie_values-&gt;kref); &#125; /* Presumed zeroed, in order of appearance: * cookie_in_always, cookie_out_never, * s_data_constant, s_data_in, s_data_out */ sk-&gt;sk_sndbuf = sysctl_tcp_wmem[1]; sk-&gt;sk_rcvbuf = sysctl_tcp_rmem[1]; local_bh_disable(); percpu_counter_inc(&amp;tcp_sockets_allocated); local_bh_enable(); return 0;&#125; 由以上代码可知inet_csk(sk)-&gt;icsk_af_ops-&gt;bind_conflict(sk, tb)真正调用的为：inet_csk_bind_conflict函数。 inet_csk_bind_conflict 检查端口是否冲突，返回0表示可以绑定，不冲突，返回1表示无法绑定该端口。inet_csk_bind_conflict函数 // net/ipv4/inet_connection_sock.c line:57 1234567891011121314151617181920212223242526272829303132int inet_csk_bind_conflict(const struct sock *sk, const struct inet_bind_bucket *tb)&#123; const __be32 sk_rcv_saddr = inet_rcv_saddr(sk); struct sock *sk2; struct hlist_node *node; int reuse = sk-&gt;sk_reuse; /* * Unlike other sk lookup places we do not check * for sk_net here, since _all_ the socks listed * in tb-&gt;owners list belong to the same net - the * one this bucket belongs to. */ sk_for_each_bound(sk2, node, &amp;tb-&gt;owners) &#123; if (sk != sk2 &amp;&amp; !inet_v6_ipv6only(sk2) &amp;&amp; (!sk-&gt;sk_bound_dev_if || !sk2-&gt;sk_bound_dev_if || sk-&gt;sk_bound_dev_if == sk2-&gt;sk_bound_dev_if)) &#123; if (!reuse || !sk2-&gt;sk_reuse || sk2-&gt;sk_state == TCP_LISTEN) &#123; const __be32 sk2_rcv_saddr = inet_rcv_saddr(sk2); if (!sk2_rcv_saddr || !sk_rcv_saddr || sk2_rcv_saddr == sk_rcv_saddr) break; &#125; &#125; &#125; return node != NULL;&#125; 4.4、inet_bind_bucket_create inet_bind_bucket_create函数分配一个inet_bind_bucket结构体实例并进行初始化操作，然后绑定到已绑定端口的散列表中。inet_bind_bucket_create函数 // net/ipv4/inet_hashtables.c line:33 123456789101112131415161718192021/* * Allocate and initialize a new local port bind bucket. * The bindhash mutex for snum's hash chain must be held here. */struct inet_bind_bucket *inet_bind_bucket_create(struct kmem_cache *cachep, struct net *net, struct inet_bind_hashbucket *head, const unsigned short snum)&#123; struct inet_bind_bucket *tb = kmem_cache_alloc(cachep, GFP_ATOMIC); if (tb != NULL) &#123; write_pnet(&amp;tb-&gt;ib_net, hold_net(net)); tb-&gt;port = snum; tb-&gt;fastreuse = 0; tb-&gt;num_owners = 0; INIT_HLIST_HEAD(&amp;tb-&gt;owners); hlist_add_head(&amp;tb-&gt;node, &amp;head-&gt;chain); &#125; return tb;&#125; 4.5、inet_bind_hash inet_bind_hash函数更新变量inet_bind_hash函数 // net/ipv4/inet_hashtables.c line:63 123456789101112void inet_bind_hash(struct sock *sk, struct inet_bind_bucket *tb, const unsigned short snum)&#123; struct inet_hashinfo *hashinfo = sk-&gt;sk_prot-&gt;h.hashinfo; //TCP散列表管理结构实例TCP_hashinfo atomic_inc(&amp;hashinfo-&gt;bsockets); // 绑定次数加1 inet_sk(sk)-&gt;inet_num = snum; //端口号赋值 sk_add_bind_node(sk, &amp;tb-&gt;owners); //把Socket加入到tb-&gt;owners的hash表中 tb-&gt;num_owners++; //端口绑定次数加1 inet_csk(sk)-&gt;icsk_bind_hash = tb;&#125; 5、inet_hashinfo 结构体inet_hashinfo结构体 //include/net/inet_hashtables.h line:118 1234567891011121314151617181920212223242526272829303132333435363738struct inet_hashinfo &#123; /* This is for sockets with full identity only. Sockets here will * always be without wildcards and will have the following invariant: * * TCP_ESTABLISHED &lt;= sk-&gt;sk_state &lt; TCP_CLOSE * * TIME_WAIT sockets use a separate chain (twchain). */ struct inet_ehash_bucket *ehash; spinlock_t *ehash_locks; unsigned int ehash_mask; unsigned int ehash_locks_mask; /* Ok, let's try this, I give up, we do need a local binding * TCP hash as well as the others for fast bind/connect. */ struct inet_bind_hashbucket *bhash; unsigned int bhash_size; /* 4 bytes hole on 64 bit */ struct kmem_cache *bind_bucket_cachep; /* All the above members are written once at bootup and * never written again _or_ are predominantly read-access. * * Now align to a new cache line as all the following members * might be often dirty. */ /* All sockets in TCP_LISTEN state will be in here. This is the only * table where wildcard'd TCP sockets can exist. Hash function here * is just local port number. */ struct inet_listen_hashbucket listening_hash[INET_LHTABLE_SIZE] ____cacheline_aligned_in_smp; atomic_t bsockets;&#125;; 6、绑定bind代码流程图 bind主要的主要是选择一个可用的端口号，如果用户没有指定端口号，则会按照一定的规则进行选择一个可用的端口号。 对于Google REUSEPORT 新特性，支持多个进程或者线程绑定到相同的 IP 和端口，以提高 server 的性能。 该特性实现了 IPv4/IPv6 下 TCP/UDP 协议的支持， 已经集成到 kernel 3.9 中。 核心的实现主要有三点： -（1）扩展 socket option，增加 SO_REUSEPORT 选项，用来设置 reuseport。 -（2）修改 bind 系统调用实现，以便支持可以绑定到相同的 IP 和端口 -（3）修改处理新建连接的实现，查找 listener 的时候，能够支持在监听相同 IP 和端口的多个 sock 之间均衡选择。请参考： 多个进程绑定相同端口的实现分析 参考资料： Socket层实现系列 — bind()的实现 linux中绑定一个不存在的本地地址 三、监听listen SYSCALL_DEFINE2(listen, int, fd, int, backlog)函数，该函数主要是在用户空间使用listen系统调用函数进行调用执行，在Linux内核中的还是使用System call vectors实现 1、SYSCALL_DEFINE2(listen,…)SYSCALL_DEFINE2(listen, int, fd, int, backlog) // net/socket.c line:1422 12345678910111213141516171819202122232425262728293031323334353637383940/* * Perform a listen. Basically, we allow the protocol to do anything * necessary for a listen, and if that works, we mark the socket as * ready for listening. */SYSCALL_DEFINE2(`listen`, int, fd, int, backlog)&#123; struct socket *sock; int err, fput_needed; int somaxconn; //表示socket监听（listen）的backlog上限 sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed); //通过文件描述符fd查找套接字sock if (sock) &#123; /* * # cd /proc/sys/net/core * # cat somaxconn 128 * 这里默认时128，Hadoop集群时一般都会增大该值 */ somaxconn = sock_net(sock-&gt;sk)-&gt;core.sysctl_somaxconn; /* * 如果backlog值大于somaxconn,backlog就为somaxconn,也就是最大值不能大于 * somaxconn */ if ((unsigned)backlog &gt; somaxconn) backlog = somaxconn; err = security_socket_listen(sock, backlog); /* * 调用对于的socket层的listen函数，如果是TCP的话，inet_listen，根据 * net/ipv4/af_inet.c文件中，const struct proto_ops inet_stream_ops = &#123; * .listen = inet_listen,&#125;;定义 */ if (!err) err = `sock-&gt;ops-&gt;listen`(sock, backlog); fput_light(sock-&gt;file, fput_needed); &#125; return err;&#125; 2、backlog 通过man listen对于backlog的解释 The backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow. If a connection request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED or, if the underlying protocol supports retransmission, the request may be ignored so that a later reattempt at connection succeeds. The behavior of the backlog argument on TCP sockets changed with Linux 2.2. Now it specifies the queue length for completely established sockets waiting to be accepted, instead of the number of incomplete connection requests. The maximum length of the queue for incomplete sockets can be set using /proc/sys/net/ipv4/tcp_max_syn_backlog. When syncookies are enabled there is no logical maximum length and this setting is ignored. See tcp(7) for more information. If the backlog argument is greater than the value in /proc/sys/net/core/somaxconn, then it is silently truncated to that value; the default value in this file is 128. In kernels before 2.4.25, this limit was a hard coded value, SOMAXCONN, with the value 128. 上面的解释的大体意思为：从Linux2.2内核版本开始，backlog的行为发生了改变，现在该参数指定了等待accepted的全连接队列的长度。而不是半连接的请求的队列长度。全连接需要在完成三次握手之后。 半连接最大长度可以使用/proc/sys/net/ipv4/tcp_max_syn_backlog进行设置。这个默认值为cat /proc/sys/net/ipv4/tcp_max_syn_backlog 1024 当syncookies被设置后，该参数被忽略掉。如果backlog值大于/proc/sys/net/core/somaxconn,它将被截断，默认值为128。也就是 当传参backlog的值 &gt;= somaxconn时，已完成连结队列的数量最多就是somaxconn 3、inet_listen 该函数主要是做一些检查工作，例如当前连接的状态，sock的类型，最主要的处理在inet_csk_listen_start函数中。inet_listen函数 // net/ipv4/af_inet.c line:194 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * Move a socket into listening state. */int inet_listen(struct socket *sock, int backlog)&#123; struct sock *sk = sock-&gt;sk; unsigned char old_state; int err; lock_sock(sk); err = -EINVAL; /* * 检查sock的状态是否为SS_UNCONNECTED,sock的类型是否为SOCK_STREAM, * 只有SOCK_STREAM类型的sock才需要进行listen，建立socket后的初始状态为 * SS_UNCONNECTED */ if (sock-&gt;state != SS_UNCONNECTED || sock-&gt;type != SOCK_STREAM) goto out; old_state = sk-&gt;sk_state; // 获取sock的当前状态，后续要变成老状态 /* * 当前连接的状态需要CLOSED状态和LISTEN状态 */ if (!((1 &lt;&lt; old_state) &amp; (TCPF_CLOSE | TCPF_LISTEN))) goto out; /* Really, if the socket is already in listen state * we can only allow the backlog to be adjusted. */ /* * 如果现在状态不是监听 */ if (old_state != TCP_LISTEN) &#123; err = `inet_csk_listen_start`(sk, backlog); //启用监听功能 if (err) goto out; &#125; /* * 如果socket的状态已经处于监听状态，这里只是对backlog进行调整 */ sk-&gt;sk_max_ack_backlog = backlog; err = 0;out: release_sock(sk); return err;&#125; 4、inet_csk_listen_start函数 该函数使TCP传输控制块进入监听状态，实现监听的过程是：为管理连接请求的散列表分配存储空间，接着使TCP的sock状态迁移到LISTEN状态，然后将sock加入到监听散列表中。inet_csk_listen_start函数 // net/ipv4/inet_connection_sock.c line:645 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int inet_csk_listen_start(struct sock *sk, const int nr_table_entries)&#123; struct inet_sock *inet = inet_sk(sk); struct inet_connection_sock *icsk = inet_csk(sk); /* * 初始化全连接队列 */ int rc = `reqsk_queue_alloc`(&amp;icsk-&gt;icsk_accept_queue, nr_table_entries); if (rc != 0) return rc; sk-&gt;sk_max_ack_backlog = 0; // 最大的全连接队列 sk-&gt;sk_ack_backlog = 0; // 当前的全连接队列 inet_csk_delack_init(sk); /* There is race window here: we announce ourselves listening, * but this transition is still not validated by get_port(). * It is OK, because this socket enters to hash table only * after validation is complete. */ sk-&gt;sk_state = TCP_LISTEN; // 设置现在的状态为TCP_LISTEN状态 /* * 检查端口号是否可用，防止bind后修改 * struct proto tcp_prot = &#123; * .unhash = inet_unhash, * .get_port = inet_csk_get_port,&#125; * 调用get_port函数与bind时调用的是同一个函数如果正确返回为0，其中inet_num * 就是bind的端口，如果没有绑定端口就进行绑定端口操作。 */ if (!sk-&gt;sk_prot-&gt;get_port(sk, inet-&gt;inet_num)) &#123; inet-&gt;inet_sport = htons(inet-&gt;inet_num); sk_dst_reset(sk); /* * 把socket添加到监听HASH表中，strutc proto tcp_prot = &#123; * .hash = inet_hash * &#125; */ `sk-&gt;sk_prot-&gt;hash`(sk); return 0; &#125; sk-&gt;sk_state = TCP_CLOSE; //如果端口不再可用，设置socket的状态为TCP_CLOSE,并销毁全连接队列 __reqsk_queue_destroy(&amp;icsk-&gt;icsk_accept_queue); return -EADDRINUSE;&#125; 4.1、reqsk_queue_alloc函数reqsk_queue_aclloc // net/core/request_sock.c line:37 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int reqsk_queue_alloc(struct request_sock_queue *queue, unsigned int nr_table_entries)&#123; size_t lopt_size = sizeof(struct listen_sock); struct listen_sock *lopt; /* * 这里nr_table_entries 最大值传进来时128，sysctl_max_backlog值为256，所以 * 这里最小值不会小于8，最大值不会大于128，在[8,128]之间 */ nr_table_entries = min_t(u32, nr_table_entries, sysctl_max_syn_backlog); nr_table_entries = max_t(u32, nr_table_entries, 8); /* * 取一个最接近z^n的值赋给nr_table_entries */ nr_table_entries = roundup_pow_of_two(nr_table_entries + 1); lopt_size += nr_table_entries * sizeof(struct request_sock *); //确定队列大小 if (lopt_size &gt; PAGE_SIZE) lopt = __vmalloc(lopt_size, GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);//如果申请得空间大于1页，则神奇虚拟地址空间连续 else lopt = kzalloc(lopt_size, GFP_KERNEL);//小于1页，在常规内存中分配内存 if (lopt == NULL) return -ENOMEM; /* * for循环计算nr_table_entries已2为底的对数，计算结果就存储在max_qlen_log成员中， * eg:如果nr_table_entries = 1024,max_qlen_log = 10 */ for (lopt-&gt;max_qlen_log = 3; \\ (1 &lt;&lt; lopt-&gt;max_qlen_log) &lt; nr_table_entries; \\ lopt-&gt;max_qlen_log++); /* *上面的代码实际上是确认了半连接队列的长度，这个值还受系统配置sysctl_max_syn_backlog的 * 影响，所以如果想调大监听套接字的半连接队列，除了增大listen()的backlog参数外，还需要调整 * sysctl_max_syn_backlog系统配置的值，proc文件为 /proc/sys/net/ipv4/tcp_max_syn_backlog */ get_random_bytes(&amp;lopt-&gt;hash_rnd, sizeof(lopt-&gt;hash_rnd)); //得到一个随机数，用于HASH rwlock_init(&amp;queue-&gt;syn_wait_lock); queue-&gt;rskq_accept_head = NULL; //全连接队列置为空 lopt-&gt;nr_table_entries = nr_table_entries; //半连接队列的最大长度 write_lock_bh(&amp;queue-&gt;syn_wait_lock); queue-&gt;listen_opt = lopt; //初始化半连接队列，其实就是icsk_accept_queue.listen_opt-&gt;syn_table write_unlock_bh(&amp;queue-&gt;syn_wait_lock); return 0;&#125; 4.2、inet_hash函数inet_hash函数 // net/ipv4/inet_hashtables.c line:401 12345678void inet_hash(struct sock *sk)&#123; if (sk-&gt;sk_state != TCP_CLOSE) &#123; local_bh_disable(); `__inet_hash`(sk); local_bh_enable(); &#125;&#125; 123456789101112131415161718192021222324static void __inet_hash(struct sock *sk)&#123; struct inet_hashinfo *hashinfo = sk-&gt;sk_prot-&gt;h.hashinfo; struct inet_listen_hashbucket *ilb; if (sk-&gt;sk_state != TCP_LISTEN) &#123; // socket不处于监听状态 __inet_hash_nolisten(sk, NULL); return; &#125; WARN_ON(!sk_unhashed(sk)); /* * 根据监听端口号，查找相对应的HASH */ ilb = &amp;hashinfo-&gt;listening_hash[inet_sk_listen_hashfn(sk)]; spin_lock(&amp;ilb-&gt;lock); /* * 把sock添加到监听HASH桶的头部，连接到sk-&gt;sk_nulls_node */ __sk_nulls_add_node_rcu(sk, &amp;ilb-&gt;head); sock_prot_inuse_add(sock_net(sk), sk-&gt;sk_prot, 1); spin_unlock(&amp;ilb-&gt;lock);&#125; 5、监听listen代码流程图 (1)listen初始化了半连接队列和全连接队列 (2)实现侦听，使TCP传输控制块的状态迁移到LISTEN状态，然后将传输控制块添加到侦听散列表中","categories":[{"name":"Linux","slug":"Linux","permalink":"http://Flipped205.github.io/BlogCode/categories/Linux/"}],"tags":[{"name":"socket","slug":"socket","permalink":"http://Flipped205.github.io/BlogCode/tags/socket/"}]},{"title":"程序员书籍","slug":"杂读/03程序员书单","date":"2018-05-29T00:00:00.000Z","updated":"2018-05-29T00:00:00.000Z","comments":true,"path":"2018/05/29/杂读/03程序员书单/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/05/29/杂读/03程序员书单/","excerpt":"","text":"转 程序员必读书籍入门书籍程序设计： 01.基础理论：编码：隐匿在计算机软硬件背后的语言 02.编程语言： C：C和指针 C++：C++程序设计原理与实践 Java：Java核心技术（第9版） C#：精通C#（第6版） JavaScript：JavaScript DOM编程艺术（第2版） Python：Python基础教程（第二版） 03.编程语言理论：编程语言实现模式 04.程序设计：程序设计方法 05.算法与数据结构：算法（第4版） 06.程序调试：调试九法——软硬件错误的排查之道 软件开发： 01.编程实践：程序设计实践 02.面向对象程序设计：Head First设计模式 03.重构：重构 04.软件测试：How to Break Software 05.项目管理：极客与团队 06.专业开发：程序员修炼之道：从小工到专家 07.大师之言：奇思妙想：15位计算机天才及其重大发现 08.界面设计：写给大家看的设计书 09.交互设计：通用设计法则 个人成长： 01.职业规划：软件开发者路线图 02.思维方式：程序员的思维修炼：开发认知潜能的九堂课 03.求职面试：金领简历：敲开苹果微软谷歌的大门 04.英语写作：The Only Grammar Book You’ll Ever Need 必读书籍程序设计： 01.基础理论：深入理解计算机系统（第2版） 02.编程语言： C：C程序设计语言（第2版） C++：C++程序设计语言（第4版） Java：Effective Java（第2版） C#：CLR via C#（第4版） JavaScript：JavaScript语言精粹 Python：Python参考手册（第4版） 03.编程语言理论：程序设计语言——实践之路（第3版） 04.程序设计：计算机程序的构造与解释（第2版） 05.算法与数据结构：编程珠玑（第2版） 06.程序调试：调试九法——软硬件错误的排查之道 软件开发： 01.编程实践：代码大全（第2版） 02.面向对象程序设计：设计模式 03.重构：修改代码的艺术 04.软件测试：xUnit Test Patterns 05.项目管理：人月神话 06.专业开发：程序员职业素养 07.大师之言：编程人生：15位软件先驱访谈录 08.界面设计：认知与设计：理解UI设计准则（第2版） 09.交互设计：交互设计精髓（第3版） 个人成长： 01.职业规划：软件开发者路线图 02.思维方式：如何把事情做到最好 03.求职面试：程序员面试金典（第5版） 04.英语写作：风格的要素","categories":[{"name":"杂读","slug":"杂读","permalink":"http://Flipped205.github.io/BlogCode/categories/杂读/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http://Flipped205.github.io/BlogCode/tags/转载/"},{"name":"技术书","slug":"技术书","permalink":"http://Flipped205.github.io/BlogCode/tags/技术书/"}]},{"title":"Ubuntu下json-c安装与使用","slug":"工具/04Ubuntu下json-c安装与使用","date":"2018-05-25T00:00:00.000Z","updated":"2018-05-25T00:00:00.000Z","comments":true,"path":"2018/05/25/工具/04Ubuntu下json-c安装与使用/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/05/25/工具/04Ubuntu下json-c安装与使用/","excerpt":"","text":"Ubuntu下json-c安装与使用1、获取并编译json-c1234567//获取源代码git clone https://github.com/json-c/json-c.gitcd json-c./autogen.sh./configuremakesudo make install 2、使用json-c通过sudo make install可以看出json-c的头文件和库所安装位置 12345678## 查看库路径和头文件路径# 头文件所在路径cd /usr/local/include/json-cls# 库所在路径cd /usr/local/lib/ls 一般使用中只需在代码中包含json.h 12345//test.c....#include &lt;json-c/json.h&gt;........ 编译test.c 1gcc test.c -ljson-c 注：-l 代表库文件路径 3、常见问题问题1：执行时出错”error while loading shared libraries: libjson-c.so.4: cannot open shared object file: No such file or directory” 修复方法：/etc/ld.so.conf中加入json库路径。可在/etc/ld.so.conf中加入该行/usr/local/lib 1234# file /etc/ld.so.confinclude /etc/ld.so.conf.d/*.conf/usr/local/bin #新增内容","categories":[{"name":"工具","slug":"工具","permalink":"http://Flipped205.github.io/BlogCode/categories/工具/"}],"tags":[{"name":"linux工具","slug":"linux工具","permalink":"http://Flipped205.github.io/BlogCode/tags/linux工具/"}]},{"title":"Windows 清除系统垃圾脚本","slug":"工具/03Windows清除垃圾脚本","date":"2018-05-24T00:00:00.000Z","updated":"2018-05-24T00:00:00.000Z","comments":true,"path":"2018/05/24/工具/03Windows清除垃圾脚本/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/05/24/工具/03Windows清除垃圾脚本/","excerpt":"","text":"12345678910111213141516171819@echo offecho 正在清除系统垃圾文件，请稍等......del /f /s /q %systemdrive%\\*.tmpdel /f /s /q %systemdrive%\\*._mpdel /f /s /q %systemdrive%\\*.logdel /f /s /q %systemdrive%\\*.giddel /f /s /q %systemdrive%\\*.chkdel /f /s /q %systemdrive%\\*.olddel /f /s /q %systemdrive%\\recycled\\*.*del /f /s /q %windir%\\*.bakdel /f /s /q %windir%\\prefetch\\*.*rd /s /q %windir%\\temp &amp; md %windir%\\tempdel /f /q %userprofile%\\cookies\\*.*del /f /q %userprofile%\\recent\\*.*del /f /s /q \"%userprofile%\\Local Settings\\Temporary Internet Files\\*.*\"del /f /s /q \"%userprofile%\\Local Settings\\Temp\\*.*\"del /f /s /q \"%userprofile%\\recent\\*.*\"echo 清除系统LJ完成！echo. &amp; pause clear.bat脚本下载","categories":[{"name":"工具","slug":"工具","permalink":"http://Flipped205.github.io/BlogCode/categories/工具/"}],"tags":[{"name":"win工具","slug":"win工具","permalink":"http://Flipped205.github.io/BlogCode/tags/win工具/"},{"name":"win脚本","slug":"win脚本","permalink":"http://Flipped205.github.io/BlogCode/tags/win脚本/"}]},{"title":"Luci配置界面开发框架","slug":"前端/01Luci配置界面开发框架","date":"2018-05-24T00:00:00.000Z","updated":"2018-05-24T00:00:00.000Z","comments":true,"path":"2018/05/24/前端/01Luci配置界面开发框架/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/05/24/前端/01Luci配置界面开发框架/","excerpt":"","text":"Luci配置界面开发框架 MVC: Model(/usr/lib/lua/luci/model/cbi)Controller(/usr/lib/lua/luci/controller)View() 1/usr/sbin/uhttpd -f -h /www -r LEDE -x /cgi-bin -u /ubus -t 60 -T 30 -k 20 -A 1 -n 3 -N 100 -R -p 0.0.0.0:80 -p [::]:80 uhttpd是基于ubox ubus json-c的，如果加上ssl,还需要openssl库 openwrt libubox：libubox是openwrt新版本中的一个基础库，在openwrt中有很多应用程序是基于libubox开发的。（如uhttpd, linubus）。 libubox: 提供一套基于事件驱动的机制 提供多种开发支持接口。（如链表、kv聊表、平衡查找二叉树、md5、json） 使用libubox开发的好处有如下几点： 1、可以是程序基于事件驱动，从而可实现在单进程中处理多个任务 2、基于libubox提供的开发API可以加快开发进度的同时提高程序的稳定性 3、能更好的将程序融入openwrt的开发架构中，因为新的openwrt得很多应用和库都基于libubox开发的 openwrt ubusubus是最新openwrt引入的一个消息总线，主要作用是实现不同应用程序之间的信息交互。ubus启动后会在后台运行ubusd进程，该进程监听一个unix套接字用于与其他应用程序通信。其他应用程序可基于libubox提供的接口（或自己实现）与其通信。 使用ubus的方式主要有： 1、向其注册消息或控制接口。 2、向其调用其他应用程序的消息或控制接口。 3、向其注册关心事件 ubus (OpenWrt micro bus 架构) 1/usr/sbin/uhttpd -f -h /www -r LEDE -x /cgi-bin -u /ubus -t 60 -T 30 -k 20 -A 1 -n 3 -N 100 -R -p 0.0.0.0:80 -p [::]:80 1、Luci配置界面开发框架(Controller)Controller定义模块的入口 12345module(\"luci.controller.控制器名\",package.seeall)function index() entry(路径,调用目标,_(\"显示名称\"),显示顺序) end 第一行说明了程序和模块的名称，eg:controller/目录下创建parentctrl.lua,那么久应该写成”luci.controller.parentctrl”。如果程序较多，可以分为好几个模块，那么可以在controller下再创建一个子目录，eg:controller/app/,那么就可以下城”luci.controller.app.parentctrl”。 entry表示一个模块的入口，官方给出entry的定义如下：entry(path, target, title=nil, order=nil)path为访问路径，路径按字符串数组给定的，eg:{“admin”,”more_set”,”parentctrl”},那么在浏览器里访问“http://192.168.2.1/cgi-bin/luci/admin/more_set/parentctrl” 来访问该脚本。 第一种直接调用指定函数，比如直接重启路由器，eg:写成“call(&quot;function_name&quot;)”，然后又在Lua文件中编写名为function_name的函数就可以调用了。 第二种可以访问指定页面，eg:“template(&quot;pc/parentctrl&quot;)”就可以调用/usr/lib/lua/luci/view/pc/parentctrl.html。 配置界面，第三种方法无非最方便的，eg:“cbi(&quot;app/parentctrl&quot;)”就可以调用/usr/lib/lua/luci/model/cbi/app/parentctrl.lua。 eg:创建/usr/lib/lua/luci/controller/njitclient.lua 12345module(\"luci.controller.njitclient\",package.seeall)function index() entry(&#123;\"admin\", \"network\", \"njitclient\"&#125;, cbi(\"njitclient\") , _(\"NJITClient\"), 100) end 2、用Lua和UCI接口开发LuCI配置模块(Model)功能描述：希望将用户名、密码等信息存储在路由器文件中，同时路由器开机时能根据设定的配置自动运行njitclient,同时希望动态的禁止和启用njitclient等等。所有最好的方式使用CBI Module,创建model文件，/usr/lib/lua/luci/model/cbi/njitclient.lua 开发LuCI的配置模块的有很多方式，比较基本的可以用SimpleForm，就跟开发普通的Web应用类似，当然最方便的还是使用UCI（Unified Configuration Interface,统一配置接口）的方式，因为使用UCI接口可以使得在LuCI中无需考虑配置文件如何存储和读取(这种方式也会自动创建“保存&amp;应用”、“保存”以及“复位”三个按钮)。同时在Bash文件中也可以非常方便的存储和读取。 对于UCI方式(1)、创建配置文件，存储于/etc/config。eg:/etc/config/njitclient 12345config login option username '' option password '' option ifname 'eth0' option domain '' 配置文件的编写参见UCI系统文档 (2)、然后在CBI Module的lua文件中首先需要映射与存储文件的关系eg: 1m = Map(njitclient,\"NJIT Client\", Configure NJIT 802.11x client.\") m = Map(“配置文件名”,”配置页面标题”,”配置页面说明”) 第一个参数即为配置文件存储的文件名，不包含路径。第二个参数和第三个参数用于页面显示。 (3)、创建与配置文件中对应的Section，Section分两种，NamedSection和TypedSection前者根据配置文件中的Section名，后者根据配置文件中的Section类型。这里使用后者。代码如下，同时设置不允许增加或删除Section(“.addremove=false”),以及不显示Section名称(“.anonymous=true”)。 123s = m:section(TypedSection, \"login\", \"\")s.addremove = falses.anonymous = true (4)、接下来创建Section中不同内容的交互（创建Option），常见的比如有Value(文本框)、ListValue(下拉框)、Flag(选择框)等等。详见官方参考文档CBI 创建Option的过程非常简单，创建后无需考虑读写配置问题，系统都会自动处理，但是根据上述的要求，我们在应用配置后希望启用、晋中或重启njitclient，所有我们需要在页面最后判断用户是否点击“应用”按钮，以及点击后的动作。 123456local apply = luci.http.formvlaue(\"cbi.apply\")if apply then --[[ 需要处理的代码 ]]--end model文件完整代码njitclient.lua 123456789101112131415161718192021222324252627require(\"luci.sys\")m = Map(\"njitclient\", translate(\"NJIT Client\"), translate(\"Configure NJIT 802.11x Client\"))s = m:section(TypedSection, \"login\", \"\")s.addremove = falses.anonymous = trueenable = s:option(Flag,\"enable\", translate(\"Enable\"))name = s:option(Value, \"username\", translate(\"Username\"))pass = s:option(Value, \"password\", translate(\"Password\"))pass.password = truedomain = s:option(Value, \"domain\", translate(\"Domain\"))ifname = s:option(ListValue, \"ifname\", translate(\"Interface\"))for k, v in ipairs(luci.sys.net.devices()) do if v ~= \"lo\" then ifname:value(v) endendlocal apply = luci.http.formvalue(\"cbi.apply\")if apply the io.popen(\"/etc/init.d/njitclient restart\")endreturn m 其中Luci全部库类的函数定义和使用说明，可以参考Luci API 3、Bash文件中调用UCI接口接下来编写njitclient脚本，使得程序最终运行起来。关于UCI接口的脚本文档中官方参考资料Configuration in scripts (1)、使用UCI调用脚本，第一步需要读取配置文件，命令为“config_load 配置文件名”。 1config_load njitclient (2)、接下来遍历配置中的Section，可以使用“config_foreach 遍历函数名为Section类型”。 1config_foreach run_njit login (3)、编写名为run_njit函数，在这个函数中，可以使用“config_get 变量名 Section名 Section参数名”获取变量的值，或者使用“config_get_bool变量名 Section名 Section参数名”获取布尔的值。 njitclient完整脚本如下 12345678910111213141516171819202122232425262728293031323334353637383940#!/bin/sh /etc/rc.commonSTART=50run_njit()&#123; local enable config_get bool enable $1 enable if [$enable]; then local username local password local domain local ifname config_get username $1 username config_get password $1 password config_get domain $1 domain config_get ifname $1 ifname if [ \"$domain\" !=\"\" ]; then njit-client $username@$domain $password $ifname &amp; else njit-client $username $password $ifname &amp; fi echo \"NJIT Client hase started.\"&#125;start()&#123; config_load njitclient config_foreach run_njit login&#125;stop()&#123; killall njit-client killall udhcpc echo \"NJIT Client has stoped.\"&#125; openwrt uhttpd交互流程docroot 为/www 1234root@LEDE:/www# ls -ldrwxrwxr-x 2 root root 27 Aug 12 00:12 cgi-bin-rw-rw-r-- 1 root root 495 Aug 12 00:12 index.htmldrwxrwxr-x 4 root root 49 Aug 12 00:12 luci-static (1)、默认index.html,该文件内容如下 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Cache-Control\" content=\"no-cache\" /&gt; &lt;meta http-equiv=\"refresh\" content=\"0; URL=/cgi-bin/luci\" /&gt; &lt;/head&gt; &lt;body style=\"background-color: white\"&gt; &lt;a style=\"color: black; font-family: arial, helvetica, sans-serif;\" href=\"/cgi-bin/luci\"&gt;LuCI - Lua Configuration Interface&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 默认跳转/cgi-bin/luci，注：luci该文件相对于docroot而言的路径，即相对于/www。(2)、则实际路径为/www/cgi-bin/luci。该文件内容如下： 12345#!/usr/bin/lua --执行命令的路径require \"luci.cacheloader\" --导入cacheloader包require \"luci.sgi.cgi\" --导入sgi.sgi包luci.dispatcher.indexcache = \"/tmp/luci-indexcache\" --cache缓存路径地址luci.sgi.cgi.run() --执行run方法，此方法于/usr/lib/lua/luci/sgi/cgi.lua (3)、cgi.lua文件内容 /usr/lib/lua/luci/sgi/cgi.luacgi.lua文件完整内容 代码解释： 首先执行的是run()函数: 1local r = luci.http.Request(...) --把Web请求放于r中，（包括环境变量，web请求，出错处理接口） create出另一个执行体httpdispatch,每次httpdispatch执行yield返回一些数据时，run()函数读取这些数据，做相应处理，然后再次执行resume(httpdispatch),…如此直到httpdispatch执行完毕。 1234567891011121314151617181920local x = coroutine.create(luci.dispatcher.httpdispatch) --创建一个协同程序local res, id, data1, data2 = coroutine.resume(x, r) --运行创建的协同进程，即运行httpdispatch，参数为上面的local r变量if id == 1 then io.write(\"Status: \" .. tostring(data1) .. \" \" .. data2 .. \"\\r\\n\")elseif id == 2 then hcache = hcache .. data1 .. \": \" .. data2 .. \"\\r\\n\" --准备headerelseif id == 3 then --写header 、blank io.write(hcache) --默认到stdout io.write(\"\\r\\n\")elseif id == 4 then io.write(tostring(data1 or \"\")) --写入bodyelseif id == 5 then io.flush() io.close() active = falseelseif id == 6 then data1:copyz(nixio.stdout, data2) data1:close()end (4)、httpdispatch函数 /usr/lib/lua/luci/dispatcher.luadispatcher.lua文件完整代码. 代码说明：整个代码主要关注一下函数 1、httpdispatch函数 1234567891011121314151617181920212223242526function httpdispatch(request, prefix) http.context.request = request local r = &#123;&#125; context.request = r local pathinfo = http.urldecode(request:getenv(\"PATH_INFO\") or \"\", true) if prefix then for _, node in ipairs(prefix) do r[#r+1] = node end end for node in pathinfo:gmatch(\"[^/]+\") do r[#r+1] = node end local stat, err = util.coxpcall(function() dispatch(context.request) end, error500) http.close() --context._disable_memtrace()end 2、dispatch函数， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358function dispatch(request) --context._disable_memtrace = require \"luci.debug\".trap_memtrace(\"l\") local ctx = context ctx.path = request local conf = require \"luci.config\" assert(conf.main, \"/etc/config/luci seems to be corrupt, unable to find section 'main'\") local i18n = require \"luci.i18n\" local lang = conf.main.lang or \"auto\" if lang == \"auto\" then local aclang = http.getenv(\"HTTP_ACCEPT_LANGUAGE\") or \"\" for lpat in aclang:gmatch(\"[%w-]+\") do lpat = lpat and lpat:gsub(\"-\", \"_\") if conf.languages[lpat] then lang = lpat break end end end if lang == \"auto\" then lang = i18n.default end i18n.setlanguage(lang) local c = ctx.tree local stat if not c then c = createtree() end local track = &#123;&#125; local args = &#123;&#125; ctx.args = args ctx.requestargs = ctx.requestargs or args local n local preq = &#123;&#125; local freq = &#123;&#125; for i, s in ipairs(request) do preq[#preq+1] = s freq[#freq+1] = s c = c.nodes[s] n = i if not c then break end util.update(track, c) if c.leaf then break end end if c and c.leaf then for j=n+1, #request do args[#args+1] = request[j] freq[#freq+1] = request[j] end end ctx.requestpath = ctx.requestpath or freq ctx.path = preq if track.i18n then i18n.loadc(track.i18n) end -- Init template engine if (c and c.index) or not track.notemplate then local tpl = require(\"luci.template\") local media = track.mediaurlbase or luci.config.main.mediaurlbase if not pcall(tpl.Template, \"themes/%s/header\" % fs.basename(media)) then media = nil for name, theme in pairs(luci.config.themes) do if name:sub(1,1) ~= \".\" and pcall(tpl.Template, \"themes/%s/header\" % fs.basename(theme)) then media = theme end end assert(media, \"No valid theme found\") end local function _ifattr(cond, key, val) if cond then local env = getfenv(3) local scope = (type(env.self) == \"table\") and env.self if type(val) == \"table\" then if not next(val) then return '' else val = util.serialize_json(val) end end return string.format( ' %s=\"%s\"', tostring(key), util.pcdata(tostring( val or (type(env[key]) ~= \"function\" and env[key]) or (scope and type(scope[key]) ~= \"function\" and scope[key]) or \"\" )) ) else return '' end end tpl.context.viewns = setmetatable(&#123; write = http.write; include = function(name) tpl.Template(name):render(getfenv(2)) end; translate = i18n.translate; translatef = i18n.translatef; export = function(k, v) if tpl.context.viewns[k] == nil then tpl.context.viewns[k] = v end end; striptags = util.striptags; pcdata = util.pcdata; media = media; theme = fs.basename(media); resource = luci.config.main.resourcebase; ifattr = function(...) return _ifattr(...) end; attr = function(...) return _ifattr(true, ...) end; url = build_url; &#125;, &#123;__index=function(table, key) if key == \"controller\" then return build_url() elseif key == \"REQUEST_URI\" then return build_url(unpack(ctx.requestpath)) elseif key == \"token\" then return ctx.authtoken else return rawget(table, key) or _G[key] end end&#125;) end track.dependent = (track.dependent ~= false) assert(not track.dependent or not track.auto, \"Access Violation\\nThe page at '\" .. table.concat(request, \"/\") .. \"/' \" .. \"has no parent node so the access to this location has been denied.\\n\" .. \"This is a software bug, please report this message at \" .. \"https://github.com/openwrt/luci/issues\" ) if track.sysauth then local authen = track.sysauth_authenticator local _, sid, sdat, default_user, allowed_users if type(authen) == \"string\" and authen ~= \"htmlauth\" then error500(\"Unsupported authenticator %q configured\" % authen) return end if type(track.sysauth) == \"table\" then default_user, allowed_users = nil, track.sysauth else default_user, allowed_users = track.sysauth, &#123; track.sysauth &#125; end if type(authen) == \"function\" then _, sid = authen(sys.user.checkpasswd, allowed_users) else sid = http.getcookie(\"sysauth\") end sid, sdat = session_retrieve(sid, allowed_users) if not (sid and sdat) and authen == \"htmlauth\" then local user = http.getenv(\"HTTP_AUTH_USER\") local pass = http.getenv(\"HTTP_AUTH_PASS\") if user == nil and pass == nil then user = http.formvalue(\"luci_username\") pass = http.formvalue(\"luci_password\") end sid, sdat = session_setup(user, pass, allowed_users) if not sid then local tmpl = require \"luci.template\" context.path = &#123;&#125; http.status(403, \"Forbidden\") tmpl.render(track.sysauth_template or \"sysauth\", &#123; duser = default_user, fuser = user &#125;) return end http.header(\"Set-Cookie\", 'sysauth=%s; path=%s' %&#123; sid, build_url() &#125;) http.redirect(build_url(unpack(ctx.requestpath))) end if not sid or not sdat then http.status(403, \"Forbidden\") return end ctx.authsession = sid ctx.authtoken = sdat.token ctx.authuser = sdat.username end if c and require_post_security(c.target) then if not test_post_security(c) then return end end if track.setgroup then sys.process.setgroup(track.setgroup) end if track.setuser then sys.process.setuser(track.setuser) end local target = nil if c then if type(c.target) == \"function\" then target = c.target elseif type(c.target) == \"table\" then target = c.target.target end end if c and (c.index or type(target) == \"function\") then ctx.dispatched = c ctx.requested = ctx.requested or ctx.dispatched end if c and c.index then local tpl = require \"luci.template\" if util.copcall(tpl.render, \"indexer\", &#123;&#125;) then return true end end if type(target) == \"function\" then util.copcall(function() local oldenv = getfenv(target) local module = require(c.module) local env = setmetatable(&#123;&#125;, &#123;__index= function(tbl, key) return rawget(tbl, key) or module[key] or oldenv[key] end&#125;) setfenv(target, env) end) local ok, err if type(c.target) == \"table\" then ok, err = util.copcall(target, c.target, unpack(args)) else ok, err = util.copcall(target, unpack(args)) end assert(ok, \"Failed to execute \" .. (type(c.target) == \"function\" and \"function\" or c.target.type or \"unknown\") .. \" dispatcher target for entry '/\" .. table.concat(request, \"/\") .. \"'.\\n\" .. \"The called action terminated with an exception:\\n\" .. tostring(err or \"(unknown)\")) else local root = node() if not root or not root.target then error404(\"No root node was registered, this usually happens if no module was installed.\\n\" .. \"Install luci-mod-admin-full and retry. \" .. \"If the module is already installed, try removing the /tmp/luci-indexcache file.\") else error404(\"No page is registered at '/\" .. table.concat(request, \"/\") .. \"'.\\n\" .. \"If this url belongs to an extension, make sure it is properly installed.\\n\" .. \"If the extension was recently installed, try removing the /tmp/luci-indexcache file.\") end endend``` 代码：&lt;div id=\"cgi\"&gt;cgi.lua完整代码如下：&lt;/div&gt;```lua-- Copyright 2008 Steven Barth &lt;steven@midlink.org&gt;-- Licensed to the public under the Apache License 2.0.exectime = os.clock()module(\"luci.sgi.cgi\", package.seeall)local ltn12 = require(\"luci.ltn12\")require(\"nixio.util\")require(\"luci.http\")require(\"luci.sys\")require(\"luci.dispatcher\")-- Limited source to avoid endless blockinglocal function limitsource(handle, limit) limit = limit or 0 local BLOCKSIZE = ltn12.BLOCKSIZE return function() if limit &lt; 1 then handle:close() return nil else local read = (limit &gt; BLOCKSIZE) and BLOCKSIZE or limit limit = limit - read local chunk = handle:read(read) if not chunk then handle:close() end return chunk end endendfunction run() local r = luci.http.Request( luci.sys.getenv(), limitsource(io.stdin, tonumber(luci.sys.getenv(\"CONTENT_LENGTH\"))), ltn12.sink.file(io.stderr) ) local x = coroutine.create(luci.dispatcher.httpdispatch) local hcache = \"\" local active = true while coroutine.status(x) ~= \"dead\" do local res, id, data1, data2 = coroutine.resume(x, r) if not res then print(\"Status: 500 Internal Server Error\") print(\"Content-Type: text/plain\\n\") print(id) break; end if active then if id == 1 then io.write(\"Status: \" .. tostring(data1) .. \" \" .. data2 .. \"\\r\\n\") elseif id == 2 then hcache = hcache .. data1 .. \": \" .. data2 .. \"\\r\\n\" elseif id == 3 then io.write(hcache) io.write(\"\\r\\n\") elseif id == 4 then io.write(tostring(data1 or \"\")) elseif id == 5 then io.flush() io.close() active = false elseif id == 6 then data1:copyz(nixio.stdout, data2) data1:close() end end endend dispatcher.lua完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927-- Copyright 2008 Steven Barth &lt;steven@midlink.org&gt;-- Copyright 2008-2015 Jo-Philipp Wich &lt;jow@openwrt.org&gt;-- Licensed to the public under the Apache License 2.0.local fs = require \"nixio.fs\"local sys = require \"luci.sys\"local util = require \"luci.util\"local http = require \"luci.http\"local nixio = require \"nixio\", require \"nixio.util\"module(\"luci.dispatcher\", package.seeall)context = util.threadlocal()uci = require \"luci.model.uci\"i18n = require \"luci.i18n\"_M.fs = fs-- Index tablelocal index = nil-- Fastindexlocal fifunction build_url(...) local path = &#123;...&#125; local url = &#123; http.getenv(\"SCRIPT_NAME\") or \"\" &#125; local p for _, p in ipairs(path) do if p:match(\"^[a-zA-Z0-9_%-%.%%/,;]+$\") then url[#url+1] = \"/\" url[#url+1] = p end end if #path == 0 then url[#url+1] = \"/\" end return table.concat(url, \"\")endfunction node_visible(node) if node then return not ( (not node.title or #node.title == 0) or (not node.target or node.hidden == true) or (type(node.target) == \"table\" and node.target.type == \"firstchild\" and (type(node.nodes) ~= \"table\" or not next(node.nodes))) ) end return falseendfunction node_childs(node) local rv = &#123; &#125; if node then local k, v for k, v in util.spairs(node.nodes, function(a, b) return (node.nodes[a].order or 100) &lt; (node.nodes[b].order or 100) end) do if node_visible(v) then rv[#rv+1] = k end end end return rvendfunction error404(message) http.status(404, \"Not Found\") message = message or \"Not Found\" require(\"luci.template\") if not util.copcall(luci.template.render, \"error404\") then http.prepare_content(\"text/plain\") http.write(message) end return falseendfunction error500(message) util.perror(message) if not context.template_header_sent then http.status(500, \"Internal Server Error\") http.prepare_content(\"text/plain\") http.write(message) else require(\"luci.template\") if not util.copcall(luci.template.render, \"error500\", &#123;message=message&#125;) then http.prepare_content(\"text/plain\") http.write(message) end end return falseendfunction httpdispatch(request, prefix) http.context.request = request local r = &#123;&#125; context.request = r local pathinfo = http.urldecode(request:getenv(\"PATH_INFO\") or \"\", true) if prefix then for _, node in ipairs(prefix) do r[#r+1] = node end end for node in pathinfo:gmatch(\"[^/]+\") do r[#r+1] = node end local stat, err = util.coxpcall(function() dispatch(context.request) end, error500) http.close() --context._disable_memtrace()endlocal function require_post_security(target) if type(target) == \"table\" then if type(target.post) == \"table\" then local param_name, required_val, request_val for param_name, required_val in pairs(target.post) do request_val = http.formvalue(param_name) if (type(required_val) == \"string\" and request_val ~= required_val) or (required_val == true and (request_val == nil or request_val == \"\")) then return false end end return true end return (target.post == true) end return falseendfunction test_post_security() if http.getenv(\"REQUEST_METHOD\") ~= \"POST\" then http.status(405, \"Method Not Allowed\") http.header(\"Allow\", \"POST\") return false end if http.formvalue(\"token\") ~= context.authtoken then http.status(403, \"Forbidden\") luci.template.render(\"csrftoken\") return false end return trueendlocal function session_retrieve(sid, allowed_users) local sdat = util.ubus(\"session\", \"get\", &#123; ubus_rpc_session = sid &#125;) if type(sdat) == \"table\" and type(sdat.values) == \"table\" and type(sdat.values.token) == \"string\" and (not allowed_users or util.contains(allowed_users, sdat.values.username)) then return sid, sdat.values end return nil, nilendlocal function session_setup(user, pass, allowed_users) if util.contains(allowed_users, user) then local login = util.ubus(\"session\", \"login\", &#123; username = user, password = pass, timeout = tonumber(luci.config.sauth.sessiontime) &#125;) if type(login) == \"table\" and type(login.ubus_rpc_session) == \"string\" then util.ubus(\"session\", \"set\", &#123; ubus_rpc_session = login.ubus_rpc_session, values = &#123; token = sys.uniqueid(16) &#125; &#125;) return session_retrieve(login.ubus_rpc_session) end end return nil, nilendfunction dispatch(request) --context._disable_memtrace = require \"luci.debug\".trap_memtrace(\"l\") local ctx = context ctx.path = request local conf = require \"luci.config\" assert(conf.main, \"/etc/config/luci seems to be corrupt, unable to find section 'main'\") local i18n = require \"luci.i18n\" local lang = conf.main.lang or \"auto\" if lang == \"auto\" then local aclang = http.getenv(\"HTTP_ACCEPT_LANGUAGE\") or \"\" for lpat in aclang:gmatch(\"[%w-]+\") do lpat = lpat and lpat:gsub(\"-\", \"_\") if conf.languages[lpat] then lang = lpat break end end end if lang == \"auto\" then lang = i18n.default end i18n.setlanguage(lang) local c = ctx.tree local stat if not c then c = createtree() end local track = &#123;&#125; local args = &#123;&#125; ctx.args = args ctx.requestargs = ctx.requestargs or args local n local preq = &#123;&#125; local freq = &#123;&#125; for i, s in ipairs(request) do preq[#preq+1] = s freq[#freq+1] = s c = c.nodes[s] n = i if not c then break end util.update(track, c) if c.leaf then break end end if c and c.leaf then for j=n+1, #request do args[#args+1] = request[j] freq[#freq+1] = request[j] end end ctx.requestpath = ctx.requestpath or freq ctx.path = preq if track.i18n then i18n.loadc(track.i18n) end -- Init template engine if (c and c.index) or not track.notemplate then local tpl = require(\"luci.template\") local media = track.mediaurlbase or luci.config.main.mediaurlbase if not pcall(tpl.Template, \"themes/%s/header\" % fs.basename(media)) then media = nil for name, theme in pairs(luci.config.themes) do if name:sub(1,1) ~= \".\" and pcall(tpl.Template, \"themes/%s/header\" % fs.basename(theme)) then media = theme end end assert(media, \"No valid theme found\") end local function _ifattr(cond, key, val) if cond then local env = getfenv(3) local scope = (type(env.self) == \"table\") and env.self if type(val) == \"table\" then if not next(val) then return '' else val = util.serialize_json(val) end end return string.format( ' %s=\"%s\"', tostring(key), util.pcdata(tostring( val or (type(env[key]) ~= \"function\" and env[key]) or (scope and type(scope[key]) ~= \"function\" and scope[key]) or \"\" )) ) else return '' end end tpl.context.viewns = setmetatable(&#123; write = http.write; include = function(name) tpl.Template(name):render(getfenv(2)) end; translate = i18n.translate; translatef = i18n.translatef; export = function(k, v) if tpl.context.viewns[k] == nil then tpl.context.viewns[k] = v end end; striptags = util.striptags; pcdata = util.pcdata; media = media; theme = fs.basename(media); resource = luci.config.main.resourcebase; ifattr = function(...) return _ifattr(...) end; attr = function(...) return _ifattr(true, ...) end; url = build_url; &#125;, &#123;__index=function(table, key) if key == \"controller\" then return build_url() elseif key == \"REQUEST_URI\" then return build_url(unpack(ctx.requestpath)) elseif key == \"token\" then return ctx.authtoken else return rawget(table, key) or _G[key] end end&#125;) end track.dependent = (track.dependent ~= false) assert(not track.dependent or not track.auto, \"Access Violation\\nThe page at '\" .. table.concat(request, \"/\") .. \"/' \" .. \"has no parent node so the access to this location has been denied.\\n\" .. \"This is a software bug, please report this message at \" .. \"https://github.com/openwrt/luci/issues\" ) if track.sysauth then local authen = track.sysauth_authenticator local _, sid, sdat, default_user, allowed_users if type(authen) == \"string\" and authen ~= \"htmlauth\" then error500(\"Unsupported authenticator %q configured\" % authen) return end if type(track.sysauth) == \"table\" then default_user, allowed_users = nil, track.sysauth else default_user, allowed_users = track.sysauth, &#123; track.sysauth &#125; end if type(authen) == \"function\" then _, sid = authen(sys.user.checkpasswd, allowed_users) else sid = http.getcookie(\"sysauth\") end sid, sdat = session_retrieve(sid, allowed_users) if not (sid and sdat) and authen == \"htmlauth\" then local user = http.getenv(\"HTTP_AUTH_USER\") local pass = http.getenv(\"HTTP_AUTH_PASS\") if user == nil and pass == nil then user = http.formvalue(\"luci_username\") pass = http.formvalue(\"luci_password\") end sid, sdat = session_setup(user, pass, allowed_users) if not sid then local tmpl = require \"luci.template\" context.path = &#123;&#125; http.status(403, \"Forbidden\") tmpl.render(track.sysauth_template or \"sysauth\", &#123; duser = default_user, fuser = user &#125;) return end http.header(\"Set-Cookie\", 'sysauth=%s; path=%s' %&#123; sid, build_url() &#125;) http.redirect(build_url(unpack(ctx.requestpath))) end if not sid or not sdat then http.status(403, \"Forbidden\") return end ctx.authsession = sid ctx.authtoken = sdat.token ctx.authuser = sdat.username end if c and require_post_security(c.target) then if not test_post_security(c) then return end end if track.setgroup then sys.process.setgroup(track.setgroup) end if track.setuser then sys.process.setuser(track.setuser) end local target = nil if c then if type(c.target) == \"function\" then target = c.target elseif type(c.target) == \"table\" then target = c.target.target end end if c and (c.index or type(target) == \"function\") then ctx.dispatched = c ctx.requested = ctx.requested or ctx.dispatched end if c and c.index then local tpl = require \"luci.template\" if util.copcall(tpl.render, \"indexer\", &#123;&#125;) then return true end end if type(target) == \"function\" then util.copcall(function() local oldenv = getfenv(target) local module = require(c.module) local env = setmetatable(&#123;&#125;, &#123;__index= function(tbl, key) return rawget(tbl, key) or module[key] or oldenv[key] end&#125;) setfenv(target, env) end) local ok, err if type(c.target) == \"table\" then ok, err = util.copcall(target, c.target, unpack(args)) else ok, err = util.copcall(target, unpack(args)) end assert(ok, \"Failed to execute \" .. (type(c.target) == \"function\" and \"function\" or c.target.type or \"unknown\") .. \" dispatcher target for entry '/\" .. table.concat(request, \"/\") .. \"'.\\n\" .. \"The called action terminated with an exception:\\n\" .. tostring(err or \"(unknown)\")) else local root = node() if not root or not root.target then error404(\"No root node was registered, this usually happens if no module was installed.\\n\" .. \"Install luci-mod-admin-full and retry. \" .. \"If the module is already installed, try removing the /tmp/luci-indexcache file.\") else error404(\"No page is registered at '/\" .. table.concat(request, \"/\") .. \"'.\\n\" .. \"If this url belongs to an extension, make sure it is properly installed.\\n\" .. \"If the extension was recently installed, try removing the /tmp/luci-indexcache file.\") end endendfunction createindex() local controllers = &#123; &#125; local base = \"%s/controller/\" % util.libpath() local _, path for path in (fs.glob(\"%s*.lua\" % base) or function() end) do controllers[#controllers+1] = path end for path in (fs.glob(\"%s*/*.lua\" % base) or function() end) do controllers[#controllers+1] = path end if indexcache then local cachedate = fs.stat(indexcache, \"mtime\") if cachedate then local realdate = 0 for _, obj in ipairs(controllers) do local omtime = fs.stat(obj, \"mtime\") realdate = (omtime and omtime &gt; realdate) and omtime or realdate end if cachedate &gt; realdate and sys.process.info(\"uid\") == 0 then assert( sys.process.info(\"uid\") == fs.stat(indexcache, \"uid\") and fs.stat(indexcache, \"modestr\") == \"rw-------\", \"Fatal: Indexcache is not sane!\" ) index = loadfile(indexcache)() return index end end end index = &#123;&#125; for _, path in ipairs(controllers) do local modname = \"luci.controller.\" .. path:sub(#base+1, #path-4):gsub(\"/\", \".\") local mod = require(modname) assert(mod ~= true, \"Invalid controller file found\\n\" .. \"The file '\" .. path .. \"' contains an invalid module line.\\n\" .. \"Please verify whether the module name is set to '\" .. modname .. \"' - It must correspond to the file path!\") local idx = mod.index assert(type(idx) == \"function\", \"Invalid controller file found\\n\" .. \"The file '\" .. path .. \"' contains no index() function.\\n\" .. \"Please make sure that the controller contains a valid \" .. \"index function and verify the spelling!\") index[modname] = idx end if indexcache then local f = nixio.open(indexcache, \"w\", 600) f:writeall(util.get_bytecode(index)) f:close() endend-- Build the index before if it does not exist yet.function createtree() if not index then createindex() end local ctx = context local tree = &#123;nodes=&#123;&#125;, inreq=true&#125; local modi = &#123;&#125; ctx.treecache = setmetatable(&#123;&#125;, &#123;__mode=\"v\"&#125;) ctx.tree = tree ctx.modifiers = modi -- Load default translation require \"luci.i18n\".loadc(\"base\") local scope = setmetatable(&#123;&#125;, &#123;__index = luci.dispatcher&#125;) for k, v in pairs(index) do scope._NAME = k setfenv(v, scope) v() end local function modisort(a,b) return modi[a].order &lt; modi[b].order end for _, v in util.spairs(modi, modisort) do scope._NAME = v.module setfenv(v.func, scope) v.func() end return treeendfunction modifier(func, order) context.modifiers[#context.modifiers+1] = &#123; func = func, order = order or 0, module = getfenv(2)._NAME &#125;endfunction assign(path, clone, title, order) local obj = node(unpack(path)) obj.nodes = nil obj.module = nil obj.title = title obj.order = order setmetatable(obj, &#123;__index = _create_node(clone)&#125;) return objendfunction entry(path, target, title, order) local c = node(unpack(path)) c.target = target c.title = title c.order = order c.module = getfenv(2)._NAME return cend-- enabling the node.function get(...) return _create_node(&#123;...&#125;)endfunction node(...) local c = _create_node(&#123;...&#125;) c.module = getfenv(2)._NAME c.auto = nil return cendfunction _create_node(path) if #path == 0 then return context.tree end local name = table.concat(path, \".\") local c = context.treecache[name] if not c then local last = table.remove(path) local parent = _create_node(path) c = &#123;nodes=&#123;&#125;, auto=true&#125; -- the node is \"in request\" if the request path matches -- at least up to the length of the node path if parent.inreq and context.path[#path+1] == last then c.inreq = true end parent.nodes[last] = c context.treecache[name] = c end return cend-- Subdispatchers --function _firstchild() local path = &#123; unpack(context.path) &#125; local name = table.concat(path, \".\") local node = context.treecache[name] local lowest if node and node.nodes and next(node.nodes) then local k, v for k, v in pairs(node.nodes) do if not lowest or (v.order or 100) &lt; (node.nodes[lowest].order or 100) then lowest = k end end end assert(lowest ~= nil, \"The requested node contains no childs, unable to redispatch\") path[#path+1] = lowest dispatch(path)endfunction firstchild() return &#123; type = \"firstchild\", target = _firstchild &#125;endfunction alias(...) local req = &#123;...&#125; return function(...) for _, r in ipairs(&#123;...&#125;) do req[#req+1] = r end dispatch(req) endendfunction rewrite(n, ...) local req = &#123;...&#125; return function(...) local dispatched = util.clone(context.dispatched) for i=1,n do table.remove(dispatched, 1) end for i, r in ipairs(req) do table.insert(dispatched, i, r) end for _, r in ipairs(&#123;...&#125;) do dispatched[#dispatched+1] = r end dispatch(dispatched) endendlocal function _call(self, ...) local func = getfenv()[self.name] assert(func ~= nil, 'Cannot resolve function \"' .. self.name .. '\". Is it misspelled or local?') assert(type(func) == \"function\", 'The symbol \"' .. self.name .. '\" does not refer to a function but data ' .. 'of type \"' .. type(func) .. '\".') if #self.argv &gt; 0 then return func(unpack(self.argv), ...) else return func(...) endendfunction call(name, ...) return &#123;type = \"call\", argv = &#123;...&#125;, name = name, target = _call&#125;endfunction post_on(params, name, ...) return &#123; type = \"call\", post = params, argv = &#123; ... &#125;, name = name, target = _call &#125;endfunction post(...) return post_on(true, ...)endlocal _template = function(self, ...) require \"luci.template\".render(self.view)endfunction template(name) return &#123;type = \"template\", view = name, target = _template&#125;endlocal function _cbi(self, ...) local cbi = require \"luci.cbi\" local tpl = require \"luci.template\" local http = require \"luci.http\" local config = self.config or &#123;&#125; local maps = cbi.load(self.model, ...) local state = nil for i, res in ipairs(maps) do res.flow = config local cstate = res:parse() if cstate and (not state or cstate &lt; state) then state = cstate end end local function _resolve_path(path) return type(path) == \"table\" and build_url(unpack(path)) or path end if config.on_valid_to and state and state &gt; 0 and state &lt; 2 then http.redirect(_resolve_path(config.on_valid_to)) return end if config.on_changed_to and state and state &gt; 1 then http.redirect(_resolve_path(config.on_changed_to)) return end if config.on_success_to and state and state &gt; 0 then http.redirect(_resolve_path(config.on_success_to)) return end if config.state_handler then if not config.state_handler(state, maps) then return end end http.header(\"X-CBI-State\", state or 0) if not config.noheader then tpl.render(\"cbi/header\", &#123;state = state&#125;) end local redirect local messages local applymap = false local pageaction = true local parsechain = &#123; &#125; for i, res in ipairs(maps) do if res.apply_needed and res.parsechain then local c for _, c in ipairs(res.parsechain) do parsechain[#parsechain+1] = c end applymap = true end if res.redirect then redirect = redirect or res.redirect end if res.pageaction == false then pageaction = false end if res.message then messages = messages or &#123; &#125; messages[#messages+1] = res.message end end for i, res in ipairs(maps) do res:render(&#123; firstmap = (i == 1), applymap = applymap, redirect = redirect, messages = messages, pageaction = pageaction, parsechain = parsechain &#125;) end if not config.nofooter then tpl.render(\"cbi/footer\", &#123; flow = config, pageaction = pageaction, redirect = redirect, state = state, autoapply = config.autoapply &#125;) endendfunction cbi(model, config) return &#123; type = \"cbi\", post = &#123; [\"cbi.submit\"] = \"1\" &#125;, config = config, model = model, target = _cbi &#125;endlocal function _arcombine(self, ...) local argv = &#123;...&#125; local target = #argv &gt; 0 and self.targets[2] or self.targets[1] setfenv(target.target, self.env) target:target(unpack(argv))endfunction arcombine(trg1, trg2) return &#123;type = \"arcombine\", env = getfenv(), target = _arcombine, targets = &#123;trg1, trg2&#125;&#125;endlocal function _form(self, ...) local cbi = require \"luci.cbi\" local tpl = require \"luci.template\" local http = require \"luci.http\" local maps = luci.cbi.load(self.model, ...) local state = nil for i, res in ipairs(maps) do local cstate = res:parse() if cstate and (not state or cstate &lt; state) then state = cstate end end http.header(\"X-CBI-State\", state or 0) tpl.render(\"header\") for i, res in ipairs(maps) do res:render() end tpl.render(\"footer\")endfunction form(model) return &#123; type = \"cbi\", post = &#123; [\"cbi.submit\"] = \"1\" &#125;, model = model, target = _form &#125;endtranslate = i18n.translate-- This function does not actually translate the given argument but-- is used by build/i18n-scan.pl to find translatable entries.function _(text) return textend","categories":[{"name":"前端","slug":"前端","permalink":"http://Flipped205.github.io/BlogCode/categories/前端/"}],"tags":[{"name":"Luci","slug":"Luci","permalink":"http://Flipped205.github.io/BlogCode/tags/Luci/"}]},{"title":"Linux 串口调试工具","slug":"工具/02Linux串口调试工具","date":"2018-05-23T00:00:00.000Z","updated":"2018-05-23T00:00:00.000Z","comments":true,"path":"2018/05/23/工具/02Linux串口调试工具/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/05/23/工具/02Linux串口调试工具/","excerpt":"","text":"minicom 1、安装1sudo apt-get install minicom 2、查看串口使用linux串口一般/dev/ttyS*,如何查看当前使用的是那个ttyS*。方式1：查看串口是否可用 12su #切换rootecho 123 &gt; /dev/ttyS0 如图，如果不可用则会提示Input/Output error 方式2：通过查看日志 1dmesg | grep ttyS* 针对USB设置，一般查看ttyUSB* 3、使用串口方式1:1、打开minicom 1sudo minicom 2、进入minicom帮助页按键ctrl+A(不区分大小写)，随后按z,出现如下： 3、设置minicom设置minicom,按o 上下选择Serial port setup 一般主要设置Serial Device和Bits,设置后之后Save setup as dfl或Save setup as.. 4、使用保存之后，如果没有反应，可以ctrl+a,q退出，重新进入。 方式2:使用时直接输入设备和波特率 1sudo minicom -D /dev/ttyS0 -b 115200 4、其他命令，查看已接入设备1df","categories":[{"name":"工具","slug":"工具","permalink":"http://Flipped205.github.io/BlogCode/categories/工具/"}],"tags":[{"name":"linux工具","slug":"linux工具","permalink":"http://Flipped205.github.io/BlogCode/tags/linux工具/"}]},{"title":"Git常用命令","slug":"工具/01Git常用命令","date":"2018-05-15T00:00:00.000Z","updated":"2018-05-05T00:00:00.000Z","comments":true,"path":"2018/05/15/工具/01Git常用命令/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/05/15/工具/01Git常用命令/","excerpt":"","text":"安装Git 1sudo apt-get install git 设置Git 12git config --global user.name \"username\"git config --global user.email \"user@example.com\" 仓库，提交代码 本地仓库 123456echo \"# test\" &gt;&gt; README.mdgit initgit add README.mdgit commit -m \"first commit\"git remote add origin https://github.com/***/*.gitgit push -u origin master 克隆远程仓库 1git clone https://github.com/***/*.git 其他命令 创建分支 1git checkout -b branch_a 切换为主分支 1git checkout master 删除分支 1git checkout -d branch_a 更新代码 1git pull 查看修改文件状态 1git status 查看修改内容 1git diff filename 日志 查看仓库历史： 1git log 要以每个提交一行的样式查看日志，你可以用： 1git log --pretty=oneline 或者也许你想要看一个所有分支的 ASCII 艺术树，带有标签和分支名： 1git log --graph --oneline --decorate --all 如果你只想看哪些文件改动过： 1git log --name-status 转** git命令** 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586git init # 初始化本地git仓库（创建新仓库）git config --global user.name &quot;xxx&quot; # 配置用户名git config --global user.email &quot;xxx@xxx.com&quot; # 配置邮件git config --global color.ui true # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit config --global --unset http.proxy # remove proxy configuration on gitgit clone git+ssh://git@192.168.53.168/VT.git # clone远程仓库git status # 查看当前版本状态（是否修改）git add xyz # 添加xyz文件至indexgit add . # 增加当前子目录下所有更改过的文件至indexgit commit -m &apos;xxx&apos; # 提交git commit --amend -m &apos;xxx&apos; # 合并上一次提交（用于反复修改）git commit -am &apos;xxx&apos; # 将add和commit合为一步git rm xxx # 删除index中的文件git rm -r * # 递归删除git log # 显示提交日志git log -1 # 显示1行日志 -n为n行git log -5git log --stat # 显示提交日志及相关变动文件git log -p -mgit show dfb02e6e4f2f7b573337763e5c0013802e392818 # 显示某个提交的详细内容git show dfb02 # 可只用commitid的前几位git show HEAD # 显示HEAD提交日志git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git tag # 显示已存在的taggit tag -a v2.0 -m &apos;xxx&apos; # 增加v2.0的taggit show v2.0 # 显示v2.0的日志及详细内容git log v2.0 # 显示v2.0的日志git diff # 显示所有未添加至index的变更git diff --cached # 显示所有已添加index但还未commit的变更git diff HEAD^ # 比较与上一个版本的差异git diff HEAD -- ./lib # 比较与HEAD版本lib目录的差异git diff origin/master..master # 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）git branch # 显示本地分支git branch --contains 50089 # 显示包含提交50089的分支git branch -a # 显示所有分支git branch -r # 显示所有原创分支git branch --merged # 显示所有已合并到当前分支的分支git branch --no-merged # 显示所有未合并到当前分支的分支git branch -m master master_copy # 本地分支改名git checkout -b master_copy # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy # 上面的完整版git checkout features/performance # 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v2.0 # 检出版本v2.0git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出git checkout -- README # 检出head版本的README文件（可用于修改错误回退）git merge origin/master # 合并远程master分支至当前分支git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改git push origin master # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支git push --tags # 把所有tag推送到远程仓库git fetch # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支git pull origin master # 获取远程分支master并merge到当前分支git mv README README2 # 重命名文件README为README2git reset --hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退）git rebasegit branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933git ls-files # 列出git index包含的文件git show-branch # 图示当前分支历史git show-branch --all # 图示所有分支历史git whatchanged # 显示提交历史对应的文件修改git revert dfb02e6e4f2f7b573337763e5c0013802e392818 # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git ls-tree HEAD # 内部命令：显示某个git对象git rev-parse v2.0 # 内部命令：显示某个ref对于的SHA1 HASHgit reflog # 显示所有提交，包括孤立节点git show HEAD@&#123;5&#125;git show master@&#123;yesterday&#125; # 显示master分支昨天的状态git log --pretty=format:&apos;%h %s&apos; --graph # 图示提交日志git show HEAD~3git show -s --pretty=raw 2be7fcb476git stash # 暂存当前修改，将所有至为HEAD状态git stash list # 查看所有暂存git stash show -p stash@&#123;0&#125; # 参考第一次暂存git stash apply stash@&#123;0&#125; # 应用第一次暂存git grep &quot;delete from&quot; # 文件中搜索文本“delete from”git grep -e &apos;#define&apos; --and -e SORT_DIRENTgit gcgit fsck","categories":[{"name":"工具","slug":"工具","permalink":"http://Flipped205.github.io/BlogCode/categories/工具/"}],"tags":[{"name":"linux工具","slug":"linux工具","permalink":"http://Flipped205.github.io/BlogCode/tags/linux工具/"}]},{"title":"Netfilter源代码分析详解","slug":"笔记/06Netfilter Code分析","date":"2018-05-14T00:00:00.000Z","updated":"2018-05-14T00:00:00.000Z","comments":true,"path":"2018/05/14/笔记/06Netfilter Code分析/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/05/14/笔记/06Netfilter Code分析/","excerpt":"","text":"一、概述1. Netfilter/IPTables框架简介 Netfilter/IPTables是继2.0.x的IPfwadm、2.2.x的IPchains之后，新一代的Linux防火墙机制。Netfilter采用模块化设计，具有良好的可扩充性。其重要工具模块IPTables连接到Netfilter的架构中，并允许使用者对数据报进行过滤、地址转换、处理等操作。 Netfilter提供了一个框架，将对网络代码的直接干涉降到最低，并允许用规定的接口将其他包处理代码以模块的形式添加到内核中，具有极强的灵活性。 2. 主要源代码文件 linux内核版本：2.4.21 Netfilter主文件：net/core/netfilter.c Netfilter头文件：include/linux/netfilter.h IPv4相关： c文件：net/ipv4/netfilter/*.c 头文件：include/linux/netfilter_ipv4.h , include/linux/netfilter_ipv4/*.h IPv4协议栈主体的部分c文件，特别是与数据报传送过程有关的部分: ip_input.c,ip_forward.c,ip_output.c,ip_fragment.c等 二、Netfilter/IPTables-IPv4总体架构 Netfilter主要通过表、链实现规则，可以这么说，Netfilter是表的容器，表是链的容器，链是规则的容器，最终形成对数据报处理规则的实现。 详细地说，Netfilter/IPTables的体系结构可以分为三个大部分： 1. Netfilter的HOOK机制 Netfilter的通用框架不依赖于具体的协议，而是为每种网络协议定义一套HOOK函数。这些HOOK函数在数据报经过协议栈的几个关键点时被调用，在这几个点中，协议栈将数据报及HOOK函数标号作为参数，传递给Netfilter框架。 对于它在网络堆栈中增加的这些HOOK，内核的任何模块可以对每种协议的一个或多个HOOK进行注册，实现挂接。这样当某个数据报被传递给Netfilter框架时，内核能检测到是否有任何模块对该协议和HOOK函数进行了注册。若注册了，则调用该模块的注册时使用的回调函数，这样这些模块就有机会检查、修改、丢弃该数据报及指示Netfilter将该数据报传入用户空间的队列。 这样，HOOK提供了一种方便的机制：在数据报通过Linux内核的不同位置上截获和操作处理数据报。 2.iptables基础模块 iptables基础模块实现了三个表来筛选各种数据报，具体地讲，Linux2.4内核提供的这三种数据报的处理功能是相互间独立的模块，都基于Netfilter的HOOK函数和各种表、链实现。这三个表包括：filter表，nat表以及mangle表。 3.具体功能模块 数据报过滤模块 连接跟踪模块（Conntrack） 网络地址转换模块（NAT） 数据报修改模块（mangle） 其它高级功能模块 于是，Netfilter/IPTables总体架构如下图1所示： 三、HOOK的实现1.Netfilter-IPv4中的HOOK Netfilter模块需要使用HOOK来启用函数的动态钩接，它在IPv4中定义了五个HOOK（位于文件include/linux/netfilter_ipv4.h，Line 39），分别对应0-4的hooknum，简单地说，数据报经过各个HOOK的流程如下： 数据报从进入系统，进行IP校验以后，首先经过第一个HOOK函数NF_IP_PRE_ROUTING进行处理；然后就进入路由代码，其决定该数据报是需要转发还是发给本机的；若该数据报是发被本机的，则该数据经过HOOK函数NF_IP_LOCAL_IN处理以后然后传递给上层协议；若该数据报应该被转发则它被NF_IP_FORWARD处理；经过转发的数据报经过最后一个HOOK函数NF_IP_POST_ROUTING处理以后，再传输到网络上。本地产生的数据经过HOOK函数NF_IP_LOCAL_OUT 处理后，进行路由选择处理，然后经过NF_IP_POST_ROUTING处理后发送出去。 总之，这五个HOOK所组成的Netfilter-IPv4数据报筛选体系如图：（注：下面所说Netfilter/IPTables均基于IPv4，不再赘述） 详细地说，各个HOOK及其在IP数据报传递中的具体位置如图： NF_IP_PRE_ROUTING (0)数据报在进入路由代码被处理之前，数据报在IP数据报接收函数ip_rcv()（位于net/ipv4/ip_input.c，Line379）的最后，也就是在传入的数据报被处理之前经过这个HOOK。在ip_rcv()中挂接这个HOOK之前，进行的是一些与类型、长度、版本有关的检查。经过这个HOOK处理之后，数据报进入ip_rcv_finish()（位于net/ipv4/ip_input.c，Line306），进行查路由表的工作，并判断该数据报是发给本地机器还是进行转发。在这个HOOK上主要是对数据报作报头检测处理，以捕获异常情况。涉及功能（优先级顺序）：Conntrack(-200)、mangle(-150)、DNAT(-100) NF_IP_LOCAL_IN (1)目的地为本地主机的数据报在IP数据报本地投递函数ip_local_deliver()（位于net/ipv4/ip_input.c，Line290）的最后经过这个HOOK。经过这个HOOK处理之后，数据报进入ip_local_deliver_finish()（位于net/ipv4/ip_input.c，Line219）。这样，iptables模块就可以利用这个HOOK对应的INPUT规则链表来对数据报进行规则匹配的筛选了。防火墙一般建立在这个HOOK上。涉及功能：mangle(-150)、filter(0)、SNAT(100)、Conntrack(INT_MAX-1) NF_IP_FORWARD (2)目的地非本地主机的数据报，包括被NAT修改过地址的数据报，都要在IP数据报转发函数ip_forward()（位于net/ipv4/ip_forward.c，Line73）的最后经过这个HOOK。经过这个HOOK处理之后，数据报进入ip_forward_finish()（位于net/ipv4/ip_forward.c，Line44）另外，在net/ipv4/ipmr.c中的ipmr_queue_xmit()函数（Line1119）最后也会经过这个HOOK。（ipmr为多播相关，估计是在需要通过路由转发多播数据时的处理）。这样，IPTables模块就可以利用这个HOOK对应的FORWARD规则链表来对数据报进行规则匹配的筛选了。涉及功能：mangle(-150)、filter(0) NF_IP_LOCAL_OUT (3)本地主机发出的数据报在IP数据报构建/发送函数ip_queue_xmit()（位于net/ipv4/ip_output.c，Line339）、以及ip_build_and_send_pkt()（位于net/ipv4/ip_output.c，Line122）的最后经过这个HOOK。（在数据报处理中，前者最为常用，后者用于那些不传输有效数据的SYN/ACK包）。经过这个HOOK处理后，数据报进入ip_queue_xmit2()（位于net/ipv4/ip_output.c，Line281）。另外，在ip_build_xmit_slow()（位于net/ipv4/ip_output.c，Line429）和ip_build_xmit()（位于net/ipv4/ip_output.c，Line638）中用于进行错误检测；在igmp_send_report()（位于net/ipv4/igmp.c，Line195）的最后也经过了这个HOOK，进行多播时相关的处理。这样，IPTables模块就可以利用这个HOOK对应的OUTPUT规则链表来对数据报进行规则匹配的筛选了。涉及功能：Conntrack(-200)、mangle(-150)、DNAT(-100)、filter(0) NF_IP_POST_ROUTING (4)所有数据报，包括源地址为本地主机和非本地主机的，在通过网络设备离开本地主机之前，在IP数据报发送函数ip_finish_output()（位于net/ipv4/ip_output.c，Line184）的最后经过这个HOOK。经过这个HOOK处理后，数据报进入ip_finish_output2()（位于net/ipv4/ip_output.c，Line160）另外，在函数ip_mc_output()（位于net/ipv4/ip_output.c，Line195）中在克隆新的网络缓存skb时，也经过了这个HOOK进行处理。涉及功能：mangle(-150)、SNAT(100)、Conntrack(INT_MAX) 其中，入口为net_rx_action()（位于net/core/dev.c，Line1602），作用是将数据报一个个地从CPU的输入队列中拿出，然后传递给协议处理例程。出口为dev_queue_xmit()（位于net/core/dev.c，Line1035），这个函数被高层协议的实例使用，以数据结构struct sk_buff *skb的形式在网络设备上发送数据报。 2.HOOK的调用 HOOK的调用是通过宏NF_HOOK实现的，其定义位于include/linux/netfilter.h，Line122： 1234#define NF_HOOK(pf, hook, skb, indev, outdev, okfn) /(list_empty(&amp;nf_hooks[(pf)][(hook)]) /? (okfn)(skb) /: nf_hook_slow((pf), (hook), (skb), (indev), (outdev), (okfn))) 这里先调用list_empty函数检查HOOK点存储数组nf_hooks是否为空，为空则表示没有HOOK注册，则直接调用okfn继续处理。如果不为空，则转入nf_hook_slow()函数。nf_hook_slow()函数（位于net/core/netfilter.c，Line449）的工作主要是读nf_hook数组遍历所有的nf_hook_ops结构，并调用nf_hookfn()处理各个数据报。即HOOK的调用过程如图: 下面说明一下NF_HOOK的各个参数： pf：协议族标识，相关的有效协议族列表位于include/linux/socket.h，Line 178。对于IPv4，应该使用协议族PF_INET； hook：HOOK标识，即前面所说5个HOOK对应的hooknum； skb：是含有需要被处理包的sk_buuff数据结构的指针。sk_buff是Linux网络缓存，指那些linux内核处理IP分组报文的缓存，即套接字缓冲区。 网卡收到IP分组报文后，将它们放入sk_buff，然后再传送给网络堆栈，网络堆栈几乎一直要用到sk_buff。其定义在include/linux/skbuff.h，Line 129，下面列出我认为对分析有意义的部分成员： struct sock *sk;：指向创建分组报文的socket; struct timeval stamp;：分组报文到达系统的时间; 下面是三个union，存放的是各层中各种协议的报文头指针： h对应传输层的报头 nh对应网络层的报头 mac对应MAC层的报头 unsigned int len;：套接字缓存所代表的报文长度，即从unsigned char *data;的位置算起的当前有效报文长度。 unsigned char pkt_type;：表示报文的类型，具体类型定义在include/linux/if_packet.h，Line24：12345678#define PACKET_HOST 0 /* To us 发送到本机的报文*/#define PACKET_BROADCAST 1 /* To all 广播报文 */#define PACKET_MULTICAST 2 /* To group 多播报文 */#define PACKET_OTHERHOST 3 /* To someone else 表示目的地非本机但被本机接收的报文 */#define PACKET_OUTGOING 4 /* Outgoing of any type 离开本机的报文 *//* These ones are invisible by user level */#define PACKET_LOOPBACK 5 /* MC/BRD frame looped back 本机发给自己的报文*/#define PACKET_FASTROUTE 6 /* Fastrouted frame 快速路由报文 */ indev：输入设备，收到数据报的网络设备的net_device数据结构指针，即数据报到达的接口。 用于NF_IP_PRE_ROUTING和NF_IP_LOCAL_IN两个HOOK outdev：输出设备，数据报离开本地所要使用的网络设备的net_device数据结构指针。 用于NF_IP_LOCAL_OUT和NF_IP_POST_ROUTING两个HOOK 注意：在通常情况下，在一次HOOK调用中，indev和outdev中只有一个参数会被使用 okfn：下一步要处理的函数。即如果有HOOK函数，则处理完所有的HOOK函数，且所有向该HOOK注册过的筛选函数都返回NF_ACCEPT时，调用这个函数继续处理；如果没有注册任何HOOK，则直接调用此函数。其5个参数将由宏NF_HOOK传入。 3. HOOK点的实现 对应于各个不同协议的不同HOOK点是由一个二维数组nf_hooks存储的（位于net/core/netfilter.c，Line 47），具体的HOOK点则由数据结构nf_hook_ops（位于include/linux/netfilter.h，Line 44）实现。如图: 其中，nf_hook_ops成员中： int priority; priority值越小，优先级越高，相关优先级在include/linux/netfilter_ipv4.h，Line52中枚举定义： 123456789enum NF_IP_hook_priorities &#123; NF_IP_PRI_FIRST = INT_MIN, NF_IP_PRI_CONNTRACK= -200, NF_IP_PRI_MANGLE = -150, NF_IP_PRI_NAT_DST = -100, NF_IP_PRI_FILTER = 0, NF_IP_PRI_NAT_SRC = 100, NF_IP_PRI_LAST = INT_MAX,&#125; nf_hookfn *hook;：为处理函数的指针，其函数指针类型定义位于include/linux/netfilter.h，Line38，为： 12345typedef unsigned int nf_hookfn(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)); 这是nf_hook_ops中最关键的成员，其五个参数分别对应前面所解释的NF_HOOK中第2到6个参数。调用HOOK的包筛选函数必须返回特定的值，这些值以宏的形式定义于头文件include/linux/netfilter.h中（Line15），分别为： NF_DROP(0)：丢弃此数据报，禁止包继续传递，不进入此后的处理流程； NF_ACCEPT(1)：接收此数据报，允许包继续传递，直至传递到链表最后，而进入okfn函数；以上两个返回值最为常见 NF_STOLEN(2)：数据报被筛选函数截获，禁止包继续传递，但并不释放数据报的资源，这个数据报及其占有的sk_buff仍然有效（e.g. 将分片的数据报一一截获，然后将其装配起来再进行其他处理）； NF_QUEQUE(3)：将数据报加入用户空间队列，使用户空间的程序可以直接进行处理； 在nf_hook_slow()以及nf_reinject()函数（位于net/core/netfilter.c，Line449，Line505）中，当由调用nf_iterate()函数（位于net/core/netfilter.c，Line339，作用为遍历所有注册的HOOK函数，并返回相应的NF_XX值）而返回的verdict值为NF_QUEUE时（即当前正在执行的这个HOOK筛选函数要求将数据报加入用户空间队列），会调用nf_queue()函数（位于net/core/netfilter.c，Line407） nf_queue()函数将这个数据报加入用户空间队列nf_info（位于include/linux/netfilter.h，Line77），并保存其设备信息以备用 NF_REPEAT(4)：再次调用当前这个HOOK的筛选函数，进行重复处理。 4. HOOK的注册和注销 HOOK的注册和注销分别是通过nf_register_hook()函数和nf_unregister_hook()函数（分别位于net/core/netfilter.c，Line60，76）实现的，其参数均为一个nf_hook_ops结构，二者的实现也非常简单。 nf_register_hook()的工作是首先遍历nf_hools[][]，由HOOK的优先级确定在HOOK链表中的位置，然后根据优先级将该HOOK的nf_hook_ops加入链表； nf_unregister_hook()的工作更加简单，其实就是将该HOOK的nf_hook_ops从链表中删除。 四、iptables系统1. 表－规则系统 IPTables是基于Netfilter基本架构实现的一个可扩展的数据报高级管理系统，利用table、chain、rule三级来存储数据报的各种规则。系统预定义了三个table： filter：数据报过滤表（文件net/ipv4/netfilter/iptable_filter.c）监听NF_IP_LOCAL_IN、NF_IP_FORWARD和NF_IP_LOCAL_OUT三个HOOK，作用是在所有数据报传递的关键点上对其进行过滤。 nat：网络地址转换表监听NF_IP_PRE_ROUTING、NF_IP_POST_ROUTING和NF_IP_LOCAL_OUT三个HOOK，作用是当新连接的第一个数据报经过时，在nat表中决定对其的转换操作；而后面的其它数据报都将根据第一个数据报的结果进行相同的转换处理。 mangle：数据报修改表（位于net/ipv4/netfilter/iptable_mangle.c）","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Flipped205.github.io/BlogCode/categories/笔记/"}],"tags":[{"name":"netfilter","slug":"netfilter","permalink":"http://Flipped205.github.io/BlogCode/tags/netfilter/"},{"name":"iptables","slug":"iptables","permalink":"http://Flipped205.github.io/BlogCode/tags/iptables/"}]},{"title":"KMP算法代码案例","slug":"笔记/0eKMP算法代码案例","date":"2018-05-14T00:00:00.000Z","updated":"2018-05-14T00:00:00.000Z","comments":true,"path":"2018/05/14/笔记/0eKMP算法代码案例/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/05/14/笔记/0eKMP算法代码案例/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int *computer_prefix(char *str_p,int *tt)&#123; if(NULL == str_p) return NULL; int i=0,j=0; int m = strlen(str_p); tt[0]=0; for(i=1;i&lt;m;i++)&#123; while(j&gt;0 &amp;&amp; str_p[j]!=str_p[i]) j=tt[j]; if(str_p[j]==str_p[i]) j=j+1; tt[i]=j; &#125; return tt;&#125;int kmp_matcher(char *str_t,char *str_p)&#123; if(NULL ==str_t || NULL == str_p) return -1; int flag = -1; int n = strlen(str_t); int m = strlen(str_p); int i=0,j=0; int *tt = (int*)malloc(sizeof(int)*m); computer_prefix(str_p,tt); if(NULL == tt) return -1; //printf tt for(i=0;i&lt;m;i++)&#123; printf(\"tt[%d]=%d \",i,tt[i]); &#125; printf(\"\\n\"); for(i=0;i&lt;n;i++)&#123; while(j&gt;0 &amp;&amp; str_t[i] != str_p[j]) j = tt[j-1]; if(str_t[i] == str_p[j]) j++; if(j == m)&#123; flag++; printf(\"positon:%d\\n\",i-j+1); j = tt[j-1]; &#125; &#125; free(tt); tt = NULL; return flag;&#125;void main()&#123; char *str_p=\"ababaca\"; char *str_t=\"aababacaafababaca\"; printf(\"orgin_str:%s\\n\",str_t); printf(\"find_str:%s\\n\",str_p); int find_num = kmp_matcher(str_t,str_p); printf(\"find %d locations\\n\",find_num+1);&#125; 参考资料：算法导论","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://Flipped205.github.io/BlogCode/tags/算法/"}]},{"title":"TCP和UDP","slug":"笔记/03UDP和TCP","date":"2018-05-14T00:00:00.000Z","updated":"2018-05-14T00:00:00.000Z","comments":true,"path":"2018/05/14/笔记/03UDP和TCP/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/05/14/笔记/03UDP和TCP/","excerpt":"","text":"补码正数：与原码相同负数：取反+1 校验和：所有数之和，超过0xff即255，就要求其补码作为校验和（取反加1） 123456789101112131415161718#include&lt;stdio.h&gt;int main()&#123; int a[8]=&#123;0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08&#125;; int i,sum=0; for (i=0;i&lt;8;i++) sum+=a[i];//将每个数相加 if(sum&gt;0xff) &#123; sum=~sum; sum+=1; &#125; sum=sum&amp;0xff; printf(\"0x%x\\n\",sum);&#125; 1、UDP1.1 简介UDP数据报封装成一份IP数据报格式如图IP首部（20字节）-UDP首部（8字节）-UDP数据 （IP数据报）应用程序必须关心IP数据报长度。如果超过网络的MTU，那么久要对IP数据包进行分片。 1.2 UDP首部（8字节）16位源端口号 16目的端口号 （4字节）16位UDP长度 16位UDP校验和 （4字节）数据 UDP长度指：UDP首部和UDP数据的字节长度 1.3 UDP校验和UDP校验和覆盖UDP首部和UDP数据。UDP和TCP在手不中都有覆盖它们首部和数据的校验和。UDP的校验和是可选的。TCP的校验和是必需的。 UDP校验和不同之处：1、UDP数据报的长度可以为奇数字节，但是校验和算法是把如干个16bit字节相加。解决方法是必须时在最后增加填充字节0，这是为了校验和的计算。2、UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算校验和而设置的。伪首部包含IP首部的一些字段。器目的是让UDP两次检查数据是否已经正确到达目的地。 UDP伪首部：32位源IP地址32位目的IP地址 UDP校验和是一个端到端的校验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端和接收端之间发生的任何改动。 接收方和发送方，伪首部中，源IP地址和目的IP交换，伪首部和UDP首部中的其他字段都是相同的，就像数据回显一样。然而UDP校验和（事实上，TCP/IP协议簇中的所有校验和）是简单的16bit和。它们检测不出交换两个16bit的差错。 根据一些数据统计：TCP发生的校验和差错的比例比UDP相对要高得多，可能原因是因为该系统中的TCP连接经常是“远程”连接（经过许多路由器和网桥等中间设备），而UDP一般为本地通信。 11.5 IP分片物理网络层一般要限制每次发送数据帧的最大长度。任何时候IP层接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据（选路），并查询该接口获得其MTU。IP把MTU与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。 把一份IP数据报分片后，之后到达目的地才进行重新组装（这里的重新组装与其他网络协议不同，它们要就在下一站就进行重新组装，而不是在最终目的地）。重新组装由目的端的IP层来完成。其目的是使分片和重新组装的过程对运输层（TCP和UDP）是透明的。已经分片过的数据报有可能会再次分片（可能不止一次）。IP首部中包含的数据为分片和重组提供了足够的信息。 对于发送端发送的每份IP数据报来说，其标识字段都包含一个为抑制。该值在数据报分片时被复制到每个片中。标识字段用其中一个bit来表示“更多的片”。除了最后一片外，其他每个组成数据报的片都要把该bit置1。 分片举例：IP首部(20字节) UDP首部(8字节) UDP数据(1473字节)分段IP首部(20字节) UDP首部(8字节) (1472字节) IP首部(20字节)(1字节) 注：IP首部(20字节) UDP首部(8字节) (1472字节) 分组 IP首部(20字节)(1字节) 分组 11.6 ICMP不可达差错（需分片）发送ICMP不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在IP首部又设置不分片（DF）的标志比特，如果某个程序需要判断到达目的端的路途中最小MTU是多少，称作路径MTU发现机制，那么这个差错就可以被改程序使用。 这种情况的ICMP报文格式如图 0-7 8-15 16-32 类型(3) 代码(4) 校验和() 未用(必须为0)()())()()(()()()()","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Flipped205.github.io/BlogCode/categories/笔记/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://Flipped205.github.io/BlogCode/tags/网络/"}]},{"title":"TCP/IP入门经典","slug":"笔记/05TCP-IP入门经典","date":"2018-05-14T00:00:00.000Z","updated":"2020-02-24T10:05:01.783Z","comments":true,"path":"2018/05/14/笔记/05TCP-IP入门经典/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/05/14/笔记/05TCP-IP入门经典/","excerpt":"","text":"TCP/IP入门经典第1章 TCP/IP基础3、TCP/IP特性： 逻辑编址;路由选择名称解析错误控制和流量控制应用支持 （1）、逻辑编址&emsp;&emsp;当传输介质随计算机越来越普及时，物理地址模式不能有效地发挥作用，网络管理员经常使用设备（比如路由器）将网络分段，以减少网络的拥堵。TCP/IP通过逻辑编址提供了这样的子网化能力。逻辑地址是一个通过网络软件来配置的地址。在TCP/IP中，计算机的逻辑地址称为IP地址。&emsp;&emsp;一个IP地址包括： 一个识别网络的网络ID数值一个识别网络中子网的子网ID数值一个识别子网中计算机的主机ID数值 通过ARP和RARP进行逻辑地址和物理地址之间的转换。 第2章 TCP/IP的工作方式2.1、TCP/IP协议系统&emsp;&emsp;TCP/IP协议必须负责完成以下任务： 把消息分解为可管理的数据块，并且这些数据块能够有效地通过传输介质 与网络适配器硬件连接。 寻址，即发送端计算机必须能够定位到接收数据的计算机，接收计算机必须能够是被自己要接收的数据 将数据路由到目的的计算机所在的子网，即使源子网和目的子网分处不同的物理网络。 执行错误控制、流量控制和确认：对可靠的通信而言，发送和接收计算机必须能够发现并纠正传输错误，并控制数据流。 从应用程序接收数据并传输到网络 从网络接收数据并传输到应用程序。 &emsp;&emsp;为了实现上述功能，TCP/IP的创建者使用模块化的设计。TCP/IP协议系统划分为不同的组件。这些组件从理论上来说是能够相互独立地是实现自己的功能。每个组件分别负责通信过程的一个步骤。&emsp;&emsp;TCP/IP模型的协议层: 应用层 传输层 网际层 网络访问层 网络访问层：提供了与物理网络连接的接口。针对传输介质设置数据格式，根据硬件的物理地址实现数据的寻址，对数据在物理网络中的传输提供错误控制。 网际层：提供独立与硬件的逻辑寻址，从而让数据能够在具有不同物理结构的子网之间传力，提供路由功能来降低流量，支持网间的数据传递（术语“网间”（internetwork）指的是多个局域网互相连接而形成的较大的网络，比如大公司的网络或Internet）。实现物理地址（问你过来访问层使用的地址）和逻辑地址的转换。 传输层：为网络提供了流量控制，错误控制和确认服务。从到网络应用程序的接口。 应用层：为网络排错，文件传输，远程控制和Internet操作提供了应用程序，还支持应用编程接口（API），从而使得针对特定操作系统编写的程序能够提供访问网络。 2.2、TCP/IP和OSI模型&emsp;&emsp;OSI(开放系统互连)是ISO(国际标准化组织)为了标准化网络协议系统做出的规范，旨在提高网络互连性，并且方便软件开发人员以一种开放方式来使用协议标准。 TCP/IP OSI 应用层 应用层 表示层 会话层 传输层 传输层 网际层 网络层 网络访问层 数据链路层 物理层 &emsp;&emsp;OSI模型7层: 物理层：把数据转换为传输介质上的电子流或模拟脉冲，并且监听数据的传输。 数据链路层：提供与网络适配器相连的接口，维护子网的逻辑连接。 网络层：支持逻辑寻址与路由选择 传输层：为网络提供错误控控制和数据流控制 会话层：在计算机的通信应用程序之间建立会话 表示层：把数据转换为标准格式，管理数据加密和压缩。 应用层：为应用程序提供网络接口，支持文件传输、通信等功能的网络应用。 注：TCP/IP模型和OSI模型都是标准，而不是实现。TCP/IP的具体实现没有严格遵守上述两个表格模型。 TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。 2.3、数据包&emsp;&emsp;数据包在每一层具有不用的形式和名称&emsp;&emsp;数据包在每层的名称： 在应用层生产的数据包被称为消息。 在传输层生产的数据包封装了应用层得消息，如果它来自于传输层的TCP协议，就被称为分段；如果来自传输层的UDP协议，就被称为数据报。 在网际层的数据包封装了传输层的片段，被称为数据报。 在网络访问层的数据包封装数据包（而且可能对其进行再分解），被称为帧。帧被访问层里的最低子层转化为比特流。 2.4 TCP/IP网络概述&emsp;&emsp;图2.4描述了基本的TCP/IP协议连网系统。当然，在完整的数据包里还包括其他的协议和服务，图中展示的是最主要的部分。 基本场景如下： 数据从工作于应用层的协议、网络服务或应用编程接口（API）通过TCP或UDP端口传递到两个传输层协议（TCP或UDP）中的一个。程序可以根据需要通过TCP或UDP访问网络。 TCP是面向连接的协议。TCP能够确保数据的发送指令，必UDP更可靠，但由于需要进行额外的错误检测和流量控制，必UDP的速度慢。(详见第6章) UDP是面向无连接的协议，比TCP快，但是不可靠，它把错误控制的责任推给了应用。 数据分段传递到网际层，IP协议在此提供逻辑寻址信息，并且把数据封装为数据报。 IP数据报进入网络访问层，传递到与物理网络相连接的软件组件。网络访问层创建额一个或多个数据帧，从而进入到物理网络。在像一台网这样的额局域网系统中，帧可以包含从表格里获取物理地址信息，而这些表格是由网际层的ARP维护的（ARP是地址解析协议，IP地址转换为物理地址。） 数据帧被转化为比特流，通过网络介质进行传输。 &emsp;&emsp;ARP(地址解析协议)，将逻辑地址IP解析成物理地址的协议&emsp;&emsp;DNS(Domain Name System，域名系统) 第3章 网络访问层&emsp;&emsp;网络访问层是最神秘、最不统一的TCP/IP层，它管理为物理网络准备数据所必须的服务于功能，包括： 与计算机网络适配器的连接 根据合适的访问方式调整数据传输， 把数据转化为电子流或模拟脉冲的形式，以在传输介质上进行传输。 对接收到的数据进行错误检查； 给发送的数据添加错误检查信息，从而让接收端计算机能够对数据进行错误检查。 &emsp;&emsp;TCP/IP数据访问层对应OSI数据链路层和物理层。 3.2 网络访问层与OIS模型&emsp;&emsp;如图3.1所示,TCP/IP网络访问层大致对应OSI的物理成和数据链路层。OSI的物理层负责把数据帧转换为适合与传输介质的比特流，也就是说，OSI物理层管理和同步实际传输的电子或模拟脉冲。在接收端，物理层把这些脉冲重新组合为数据帧。&emsp;&emsp;OSI数据链路层执行两个独立的任务，相应地划分为两个子层。 介质访问控制（MAC）：这个子层提供与网络适配器连接的接口。实际上，网络适配器驱动程序通常被称为MAC驱动，而网卡在工厂固化的硬件地址通常称为MAC地址。 逻辑链路控制（LLC）：这个子层经过子网传递的帧进行错误检查，并且管理子网上通信设备之间的链路。 注意： NDIS和ODI 在实际的网络协议实现中没忘了驱动程序接口规范（NDIS）和开发数据链路接口（ODI）规范的存在进一步复杂了TCP/IP层与OSI系统之间的区别。NDIS(有Microsoft和3Com公司开发)和ODI(由Apple和Novell开发)的设计目的在于让单个协议栈（比如TCP/IP）使用多个网络是配资，并让单个网络适配器使用多个上传协议，这样可以让上传协议彻底独立于网络访问系统，从而为网络增加了很强的功能，但同时也增加了复杂性，也让系统地介绍软件组件在底层如何交互变得更加困难。 3.3 网络体系&emsp;&emsp;网络体系（比如以太网）具有一系列的规范来管理介质访问、物理寻址、计算机与传输介质的交互。在决定网络体系时，实际上是在决定如何设计网络访问层。&emsp;&emsp;网络体系包含对物理网络的定义，以及该物理网络上定义的通信规范。通信细节基于物理细节，所以这些规范通常以一个完整的包出现。这些规范包含以下几个方面。 访问控制：访问方法是定义了计算机如何共享传输介质的一组规则。为了避免数据的冲突，计算机在传输数据时必须遵守这些规则。 数据帧格式：来自于网际层的IP几倍的数据报以预定义的格式封装为数据帧，封装在包头中的数据必须提供在物理网络上传输数据所需要的信息。 布线类型：网络锁使用的线缆类型对于其他设计参数具有一定的影响，比如适配器的传递的比特流的电子特性。 布线规则：协议、线缆类型和传输的电子特性影响着线缆的最大和最小长度、电缆连接诶器的规范。 &emsp;&emsp;最终要的是，网络访问层以上的协议层不必关心硬件设计的问题。TCP/IP协议栈的设计保证了与硬件交互相关的细节发生在网络访问层，使得TCP/IP能够工作于多种不同的传输介质。 &emsp;&emsp;网络访问层如下的一些体系： IEEE 802.3(以太网)：在大多数办公室和家庭使用的基于线缆的网络。 IEEE 802.11(无线网络)：办公室、家庭和咖啡厅使用的无线网络技术 IEEE 802.16(WiMAX)：用于移动通信长距离无线连接技术。 点到点协议（PPP）： Modem通过电话线进行连接的技术。 &emsp;&emsp;TCP/IP还支持其他一些网络体系。如图3.2所示，协议栈的模块化特性使得在网络访问层里与硬件打交道的软件组件能够为和硬件无关操作的上层提供接口。 3.4、物理地址&emsp;&emsp;ARP和RARP为用户提供了逻辑IP地址与局域网上使用的硬件地址建立了一个对应关系。(详见第4章)。&emsp;&emsp;以太网软件使用的地址并不是逻辑IP地址，但这个地址在网际层的接口上与IP地址有映射关系。 3.5、以太网(802.3)&emsp;&emsp;以太网是目前使用最广泛的局域网技术。以太网使用称为载波监听多路访问/冲突检测（CSMA/CD）的方法，来判断计算机何时可以把数据发送到访问介质。 &emsp;&emsp;通过使用CSMA/CD，所有计算机都监视传输介质的状态，在传输之前等待线路空闲。如果两台计算机尝试同时发送数据，就会发送冲突，计算机就会停止发送，等待一个随机的时间间隔，然后再次尝试发送。&emsp;&emsp;传统以太网经常使用连续的通走电缆作为传输介质。&emsp;&emsp;现代以太网的形式都是把计算机连接到一个网络设备上（eg 交换机）。 3.6、剖析以太网帧&emsp;&emsp;网络访问层的软件从网际层接收数据包，把它转化符合物理网络规则的形式。在以太网中，网络访问层的软件必须把数据转换成能够通过网络适配器硬件进行转化的形式。 &emsp;&emsp;以太网软件从网际层接收到数据包之后，执行以下操作： 1、根据需要报网际层的数据分解为较小的块，已复核以太网帧数据段的要求。以太网帧的整体大小必须在64字节与1518字节之间（不包括前导码）。有些系统支持醉倒的帧，最大可以到9000字节。这种大型帧能够改变效率，但存在着兼容性问题，而且并没有得到广泛支持。 2、把数据块打包成帧。每一帧都包含数据及其他信息，这些信息是以太网网络适配器处理帧所需要的。IEEE802.3以太网帧包含以下内容。 前导码：表示帧起始的一系列比特（共8字节，最后一个字节是帧起始符）。 目标地址：接收帧的网络适配器的6字节（48bit）物理地址。 源地址：发送帧的网络适配器的6字节（48bit）物理地址。 可选VLAN标记：这个可选的16bit字段在802.1q标准中有讲解，其目的是允许多个虚拟LAN可通过同一网络交换机运行。 长度：另个字节，表示数据段的长度。 数据：帧中传输的数据。 帧校验序列（FCS）：帧的4字节(32bit)校验和，FCS是校验数据传输的常见方式。发送方计算帧的循环冗余码校验（CRC）值，把这个值写到帧里。接收方计算机重新计算CRC，与FCS字段的值进行比较，如果两个值不想用，就表示传输过程中发送了数据丢失或改变，这时就需要重新传输这一帧。 3、把数据帧传递给对应于OSI模型物理层的底层组件，后者把帧转换为比特流，并且通过传输介质发送出去。 &emsp;&emsp;以太网上其他网络适配器接收到这个帧，检查其中的目的地址，如果目的地址与网络适配器的地址相匹配，适配器软件就会处理接收到的帧 ，把数据传递给协议栈中较高的层。 第4章 网际层&emsp;&emsp;网际层提供的协议就负责局域网网段之外的传递，其中重要的协议包括IP、ARP和ICMP。 4.1、寻址与发送&emsp;&emsp;上一章中，以太网卡的物理寻址方式适合单个局域网网段。有不间断介质连接在一起的若干台计算机利用物理地址就可以实现所需的功能。只需使用网络访问层的低级协议就可以把数据从网络适配器直接传递给另一个网络适配器。 使用ARP 1. 如果目的地址与源地址在同一个网段，源计算机就把数据包直接发送给目的计算机。IP地址呗ARP即系为物理地址，数据被直接发送到目的网络适配器。 2. 如果目的地址与源地址不在一个网段上，就执行如下过程： > a)、直接将数据报发送给网关。网关是位于局域网网段上的一个设备，能够把数据报转发到其他网段（网关基本算路由器）。网关地址呗ARP解析为物理地址，数据被发送到网关的适配器。 > b)、数据报通过网关被路由到较高级别的网段（如上图4.1）,再次重复上述过程。如果目的地址在这个新网段里，数据就被发送到目的，否则数据报就会被发送到另一网关。 > c)、数据报经过一系列网关被转发到目的网段，目的IP地址被ARP解析为物理地址，数据被发送到目的网络适配器。 为了在复杂的路由式网络中传输数据，网际层协议必须具有以下功能： 识别网络值班费所以计算机； 提供一种方式来判断何时需要通过网关来传递消息。 提供一种与硬件无关的方式来是被目的网关，从而让数据报能够高效率地经过路由器到达正确的网段； 提供一种方式把目标计算机的逻辑IP地址转化为物理地址，让数据能够传输给目的计算机的网络适配器。 4.2、网际协议（IP）&emsp;&emsp;IP协议提供了一种分层的、与硬件无关的寻址系统，具有在复杂的路由式网络中传递数据所需的服务。TCP/IP网络上的每一网络适配器都有一个唯一的IP。 IP地址分为两个部分: 网络ID 主机ID 分类的寻址系统和CIDR（无类别域间路由选择）寻址。子网划分 &emsp;&emsp;每一个IP数据报都以一个IP报头开始。源TCP/IP软件构造这个IP报头。目的计算机的TCP/IP软件利用IP报头中封装的信息处理数据。IP报头包含大量信息。包括源IP地址、目的IP地址、数据报长度、IP版本号和对路由器的特殊指令。 &emsp;&emsp;IP报头的最小长度是20字节，图4.3所示为IP报头的内容。 版本：这个4位字段表示所使用的IP版本。目前IP版本是4，相应的二进制是0100 网际报头长度(IHL)：这4位自读表示IP报头以32位字为单位的长度。IP报头的最小长度是5个32比特字，相应的二进制表示0101。 服务类型：源IP能够指定特殊的而路由信息。有些路由器会忽略这个字段的信息。但随着服务质量（Qos）技术的出现，这个字段得到了更多的重视，这个8位字段的主要用途是对等待通过路由器的数据报区分优先级，而目前大多数IP实现把是这个字段全填为0 总长度：这个16位的字段表示IP数据报的长度，单位是字节，这个长度包含了IP报头和数据载荷。 标识：这个16位的字段是一个依序变大的数值，分配给源IP发出的消息。当传递到IP层的消息太大而不能放到一个数据报里时，IP会把消息查分到多个数据报，并对这些数据报排序分配相同的标识号。接收端利用这些数值重组为原始消息。 标记：这个字段表示分段可能性。第1位未使用，其值应该为0.第2位为DF(不分段)，表示是否允许分段，0表示分段，1表示不允许。第3位是MF（更多分段），表示是否还有分段正在传输，设置为0表示没有更多分段需要发送，或是数据报根本没有分段。 分段位移：这个13位的字段是一个数值，被赋予每个连续的分段。目的设备IP利用这个值以正确的次序重组分段。这个数值使用的单位是8字节。 生存时间（TTL）：这个字段表示数据报在被抛弃之前能够保留的时间（以秒为单位）或路由器跳数。每个路由器都会检查这个字段，并且至少把它减去1，或数据报在路由器中延迟的秒数。当这个字段的值为0时，数据报就会被抛弃。跳数：代表数据报到达目的之前必须经过的路由器的数量。如果数据报在到达目的之前经过了5个路由器，我们就说距离目的有5跳。 协议：这个8位的字段表示接收数据载荷的协议，比如协议标识为6（二进制00000110）的数据报会被传递到TCP模块，下面为一些常见的协议标识值。ICMP:1，TCP:6，UDP:17。 报头校验和：这个字段包含16位的校验和，只用于检验报头本身的有效性，数据报经过的每个路由器都会对这个值进行重新计算，因为TTL字段的值是在不断变化的。 源IP地址：这个32位字段包含了数据报的源IP地址。 目的IP地址：这个32位的字段包含了数据报的目的IP地址。目的IP根据这个值检验发送的正确性。 IP选项：这个字段支持一些可选的报头设置，主要用于测试、调试和安全的目的。这些选项包括严格源路由（数据报必须经过指定的路由器）、网际时间戳（经过每个路由器时的时间戳记录）和安全限制。 填充： IP选项字段的长度不是固定的。填充字段可以提供一些额外的0，从而保证这个报头的长度是32位的整数倍（报头长度必须是32位字的整数倍，因为“网际头长度IHL”字段以32位字为单位表示报头的长度。） IP数据载荷：这个字段一般用于保存传输给TCP或UDP(在传输层)、ICMP或IGMP的数据。数据块的长度不定，可以包含数千字节。 IP寻址：&emsp;&emsp;地址分类： A类地址： IP地址的前8位表示网络ID，后24位表示主机ID。32位地址以0开头。 B类地址： IP地址的前16位表示网络ID，后16位表示主机ID。32位地址以10开头。 C类地址： IP地址的前24位表示网络ID，后8位表示主机ID。32位地址以110开头。 &emsp;&emsp;使用的位数越多，包含的组合就越多。显而易见，A类地址提供了较少的网络ID，但每个网络都具有大量可用的主机ID。计算机和路由器如何判断一个IP地址是A类、B类或C类？TCP/IP地址规则使得地址本身就可以说明其分类，以32为地址的起始。 注意： D类和E类&emsp;&emsp;Internet规范还定义了特殊用途的D类地址和E类地址，D类地址用于多播。多播是把一个消息发送给网络的子网，这与广播是不同的，后者需要网络上全部节点都进行处理，D类地址最前面4位是1110，对应十进制数值是224249，E类网络是实验性质的，一般不用于生产环境。E类网络地址最前面的5位是11110，对应十进制数值240247。 &emsp;&emsp;网络管理员可以把网络划分为更小的次级网络，这被称为子网。话费子网的是指就是借用主机ID中的一些位，在网络内创建额外的网络。根据前面的分类介绍，我们很容易想到具有大量主机ID的A类和B类地址会广泛使用子网划分技术。当前C类网络也会使用子网划分技术。详见第5章。 注意：地址是否唯一&emsp;&emsp;从理论上将，Internet上每台计算机都必须有一个唯一的IP地址。在实际应用中，代理服务器软件和NAT设备的使用让未注册和非唯一的地址也可以连接Internet。第12章讲解NAT设备。 4.3、ARP&emsp;&emsp;网段上的没太注记在内存中都保存着一个被称为ARP表或ARP缓存的表格，其中包含网段上其他主机IP地址与物理地址对应关系。 12当主机需要向网段上的其他啊主机发送数据时，它会查看ARP缓存来获取目的的物理地址，ARP缓存是动态变化。如果要接收数据的地址当前并不存在与ARP缓存，主机就会发送名为ARP请求帧的广播。ARP请求帧包含未解析的IP地址，还包含发送这个请求的主机IP地址和物理地址。网段上的其他主机接收到这个ARP请求，拥有这个未解析IP地址的主机会向发出请求的主机发送自己的物理地址。这个新的IP地址和物理地址的对应关系就会添加到请求主机的ARP缓存里。 4.4、RARP&emsp;&emsp;RARP的含义是逆向ARP，当知道IP地址而不知道物理地址使用ARP；而在知道物理地址而不知道IP地址时，则使用RARP。RARP经常与BOOTP协议共同使用来启动无盘工作站。 注： BOOTP(启动PROM) 很多网络适配器具有一个空的插槽，支持被称为“启动PROM”的集成电路。计算机一加电，PROM固件就会启动，从网络服务器而不是本地硬盘来读取并加载操作系统，下载到BOOTP设备的操作系统被预配置为特定的IP地址。 4.5、Internet控制消息协议（ICMP）&emsp;&emsp;发送到远程计算机的数据通常会经过一个或多个路由器，这些路由器在把数据传输到最终目的地的过程中可能发生多种问题。路由器利用Internet控制消息协议（ICMP）消息把问题通知给源IP，ICMP还有用于其他调试和排错的功能。常见的ICMP消息： Echo Request（回显请求）和Echo Reply（回显应答）： ICMP经常被用于测试，比如测试连接的ping命令实际就是在使用ICMP。 Source Quench（源抑制）：如果以太告诉计算机向远程计算机发送大量数据，可能会使路由器产生过载。这时路由器可以利用ICMO向源IP发送Source Quench消息，让它降低发送数据的速度。如果必要，还可以向源IP发送额外的源抑制消息。 Destination Unreachable（目的不可到达）：如果路由器收到一个不能传递的数据报，ICMP就会向源IP返回一个Destination Unreachable消息。路由器不能传递消息的原因之一是网络由于设备故障或维修而关闭。 Time Exceeded（超时）：当数据报由于TTL为0而被抛弃时，ICMP就会向源IP发送这个消息。这表示对于当前TTL值来说，到达目标需要经过大多路由器；或者是说明路由表出了问题，导致数据报在同一路由器上连续循环。 当数据报无线循环且永远不能到达目的地时，就会发生路由环路。3台路由器A,B,C，A-&gt;B发送一个数据报，B-&gt;C，C-&gt;A就会形成路由环路，数据报陷入其中，不断在3台路由器之间循环，知道TTL为0。还有一种是当网络管理员在路由表中设置一条静态路由时，有时就可能导致环路路由。 Fragmentation Needed（需要分段）：如果一个数据报的“Don’t Dragment（不可分解）”位被设置为1，而路由器必须要对数据报进行分段才能把它转发到下一台路由器或目的地，这时ICMP就会发出这条消息。 4.6、网际层其他协议&emsp;&emsp;用于路由进程的边界网关协议（GBP）和路由信息协议（RIP）。&emsp;&emsp;IPSec协议在IPv4里是可选的，但在IPv6里是必需的。它也工作于网际层，提供一个安全的加密通信。 &emsp;&emsp;IP提供了一种与硬件无关的寻址系统。&emsp;&emsp;ARP是把IP地址解析为物理地址的协议，RARP是ARP的逆过程。&emsp;&emsp;ICMP是用于诊断和测试的协议。 第5章 子网划分和CIDR5.1、子网&emsp;&emsp;子网划分可以将网络分解为被称位子网的较小单元。子网的概念最最早是源自于地址分类系统的。 然后，硬件厂商和Internet社区建立了一种解析地址的新系统，名为CIDR(无类别域间路由)，它需要关心地址类别。 5.2、划分网络&emsp;&emsp;第4章介绍地址分类系统让所有的主机能够识别IP地址中的网络ID，从而把数据包发送个正确的网络。但是根据A类B类C类网络ID来识别网段具有一些局限性。主要是在网络级别之下不能对地址控件进行任何逻辑细分。eg： &emsp;&emsp;如上图所示，数据报到达网关，然后传输到99.0.0.0地址控件，但如何要考虑它在这个地址控件中是如何传递的，图示会非常复杂，因为A累网络能够容纳超过1600万台主机。为了在大型网络里实现更高效的数据传输，地址空被话划分为较小的网段（如图5.2）。把网络划分为独立的物理网络能够增加网络的整体性能，也就能够让网络使用更大的地址空间。在这种情况下，地址空间里划分网段的路由器需要适当的指示来决定数据传输到哪里，不能使用网络ID，因为传输到这个网络的数据报具有相同的网络ID（99.0.0.0）,非常麻烦而且不灵活、不实用。唯一可行的解决方法是在网络标ID下，对地址空间进行细分，让注记和路由器能够根据IP地址判断应该把数据发送到哪个网段。子网划分就是在网络ID之下提供了第二层逻辑组织，路由器机能够把数据报发送给网络里的某个子网地址（一般对应于一个网段），而当数据报到达子网自后，就会被ARP解析成物理地址。那么`子网地址`从何而来，32位IP地址已经被划分为`网络ID`和`主机ID`。TCP/IP的设计者借用了主机ID里的一些位来形成子网地址。一个名为`子网掩码`的参数指定地址中的多少位用于`子网ID`，保留多个为作为实际的主机ID。`子网掩码`也是32位二进制值，它的形式能够说明与之相关的`IP地址`的`子网ID`。 &emsp;&emsp;在子网网络上，路由器和主机所使用的`路由表`包含了与每个IP地址相关的子网掩码信息（有关路由信息，详见第8章）。 &emsp;&emsp;由图5.5可看出，数据报根据网络ID被路由到目标网络，而这个`网络ID`是由`地址类别`决定。当数据报达到目标网络之后，它根据`子网ID`路由到合适的`网段`。在到达这个网段之后，再根据主机ID传输到正确的计算机。 5.3、将子网掩码转化为点分十进制标记&emsp;&emsp;网络管理员通常把子网掩码作为TCP/IP配置的参数分配给每个主机。如果主机通过DHCP（详见12章）获取IP地址，DHCP服务器就会同时分配一个子网掩码。一个子网内的所有主机应该具有相同的子网ID和子网掩码。为了便于人们使用，子网掩码通常以点分十进制表示。&emsp;&emsp;相比IP地址，子网掩码的转换通常比较简单，对应于地址中的网络ID和子网ID的掩码位是1，代表IP地址里的主机ID掩码位0`。这就意味着1都在掩码的左侧，0都在掩码的右侧（除了极少的例外）。 例如： 1234567子网掩码： 11111111 11111111 11111111 00000000 以点分十进制表示：255.255.255.0子网掩码： 11111111 11111111 00000000 00000000 以点分十进制表示：255.255.0.0 5.4、使用子网&emsp;&emsp;子网掩码决定了网络ID之后又多少位是作为子网ID的，子网ID的长度不是国定的，取决于子网掩码的值。子网ID越长，留给主机的ID位数越少。换句话，如果网络上有很多子网，每个自网上的主机容量就会很少。 12345678910地址分类：A类地址：“0”开头 1.0.0.0~126.0.0.0即：01000000 00000000 00000000 00000000 ~ 01111110 00000000 00000000 00000000可用的A类网络有126个，每个网络能容纳1亿多个主机B类地址：“10”开头 128.0.0.0~191.255.255.255即：10000000 00000000 00000000 00000000 ~ 10111111 11111111 11111111 11111111可用的B类网络有16382个，每个网络能容纳6万多个主机C类地址 “110”开头 192.0.0.0~223.255.255.255即：11000000 00000000 00000000 00000000 ~ 11011111 11111111 11111111 11111111C类网络可达209万余个，每个网络能容纳254个主机 注意：类与掩码 地址类别也决定了子网ID占用使用多少位。比如掩码：11111111 11111111 11100000 00000000指定了网络ID与子网ID一共占19位。如果这个掩码用于一个B类地址（网络ID 16位），那么子网就只有3位。如果它是A类地址（网络ID 8位），子网ID就有11位。子网ID的分配（以及子网掩码的分配），取决于网络的配置。最好的方案，是先规划网络，确定全部网段的数论与位置，然后为每个网段分配一个子网ID。 描述 点分十进制形式 二进制形式 A类地址 默认掩码 255.0.0.0 11111111 00000000 00000000 00000000 1个子网位 255.128.0.0 11111111 10000000 00000000 00000000 2个子网位 255.192.0.0 11111111 11000000 00000000 00000000 3个子网位 255.224.0.0 11111111 11100000 00000000 00000000 4个子网位 255.240.0.0 11111111 11110000 00000000 00000000 5个子网位 255.248.0.0 11111111 11111000 00000000 00000000 6个子网位 255.252.0.0 11111111 11111100 00000000 00000000 7个子网位 255.254.0.0 11111111 11111110 00000000 00000000 8个子网位 255.255.0.0 11111111 11111111 00000000 00000000 9个子网位 255.255.128.0 11111111 11111111 10000000 00000000 10个子网位 255.255.192.0 11111111 11111111 11000000 00000000 11个子网位 255.255.224.0 11111111 11111111 11100000 00000000 12个子网位 255.255.240.0 11111111 11111111 11110000 00000000 13个子网位 255.255.248.0 11111111 11111111 11111000 00000000 14个子网位 255.255.252.0 11111111 11111111 11111100 00000000 15个子网位 255.255.254.0 11111111 11111111 11111110 00000000 16个子网位 255.255.255.0 11111111 11111111 11111111 00000000 17个子网位 255.255.255.128 11111111 11111111 11111111 10000000 18个子网位 255.255.255.192 11111111 11111111 11111111 11000000 19个子网位 255.255.255.224 11111111 11111111 11111111 11100000 20个子网位 255.255.255.240 11111111 11111111 11111111 11110000 21个子网位 255.255.255.248 11111111 11111111 11111111 11111000 22个子网位 255.255.255.252 11111111 11111111 11111111 11111100 B类地址 默认掩码 255.255.0.0 11111111 11111111 00000000 00000000 1个子网位 255.255.128.0 11111111 11111111 10000000 00000000 2个子网位 255.255.192.0 11111111 11111111 11000000 00000000 3个子网位 255.255.224.0 11111111 11111111 11100000 00000000 4个子网位 255.255.240.0 11111111 11111111 11110000 00000000 5个子网位 255.255.248.0 11111111 11111111 11111000 00000000 6个子网位 255.255.252.0 11111111 11111111 11111100 00000000 7个子网位 255.255.254.0 11111111 11111111 11111110 00000000 8个子网位 255.255.255.0 11111111 11111111 11111111 00000000 9个子网位 255.255.255.128 11111111 11111111 11111111 10000000 10个子网位 255.255.255.192 11111111 11111111 11111111 11000000 11个子网位 255.255.255.224 11111111 11111111 11111111 11111100 12个子网位 255.255.255.240 11111111 11111111 11111111 11111100 13个子网位 255.255.255.248 11111111 11111111 11111111 11111100 14个子网位 255.255.255.252 11111111 11111111 11111111 11111100 C类地址 默认掩码 255.255.255.0 11111111 11111111 11111111 00000000 1个子网位 255.255.255.128 11111111 11111111 11111111 10000000 2个子网位 255.255.255.192 11111111 11111111 11111111 11000000 3个子网位 255.255.255.224 11111111 11111111 11111111 11100000 4个子网位 255.255.255.240 11111111 11111111 11111111 11110000 5个子网位 255.255.255.248 11111111 11111111 11111111 11111000 6个子网位 255.255.255.252 11111111 11111111 11111111 11111100 注： 主机ID不能为全1(保留用于广播)或全0（同城不使用）。 5.5、无类别域间路由（CIDR）&emsp;&emsp;地址分类系统相对而言不够灵活，需要使用子网划分系统来更细致地控制地址控件。而无类别域路由（CIDR）在路由表中定义地址块时容易修改，更具有灵活性。这种技术不依赖于预定义的8位、16位或24位网络ID，而是使用一个名为CIDR前缀值指定地址中作为网络ID的位数。这个前缀有时也被称为变长子网掩码（VLSM）。这个前缀可以位于地址空间的任何位置，让管理者能够以更灵活的方式定义子网，以简便的形式指定地址中网络ID部分与主机ID部分。CIDR标记使用一个斜线（/）分隔符，后面跟一个十进制数值表示地址中网络部分所占的位数。例如CIDR地址205.123.196.183/25中，/25表示地址中25位用于网络ID，相应的子网掩码就是255.255.255.128。 &emsp;&emsp;CIDR前缀表明了IP地址中前面的多少位对于网络里的全部主机说是一样的。CIDR强大的特性不仅仅能够对网络划分子网，还让ISP或管理员能够把多个连续C类网络聚合或组合为一个实体。这种也行极大的简化了网际路由表。 &emsp;&emsp;例如：一个ISP可以分配204.21.128.0（11001100 00010101 10000000 00000000）~204.21.255.255（11001100 00010101 11111111 11111111）的全部C类地址，这些网络地址的前17位是一样的，因此，超网掩码是11111111 11111111 10000000 0000000即255.255.128.0。超网掩码中0对应的为确定了地址块的范围。因此，支持CIDR路由表只是用一条CIDR条目204.21.128.0/17来引用这些地址的全部范围。 超网掩码：一个32位的二进制值，能够把多个连续网络ID聚合为一个整体。 第6章 传输层&emsp;&emsp;TCP/IP传输层包含很多有用的协议，能够提供数据在网络传输所需要的必要寻址信息。但寻址和路由只是传输层的部分功能。网际层上添加另一层，这层提供的额外必须要特性来使用IP。传输层协议需要提供以下功能： 为网络应用程序提供接口：也就是为应用程序提供访问网络的途径。设计者希望不仅能够向目的计算机传递数据，还能够向目的计算机上的特定应用传递数据。 多路复用/多路分解机制：这里的多路复用表示从不同的应用程序和计算机接收数据，再把数据传递到目的计算机上的接收程序。换句话说，传输层必须 能够同时支持多个网络程序和管理传递给网际层的数据流。在接收端，传输层必须能够从网际层几首数据，把它转发给多个程序，这种功能被吃呢改为多路分解，它可以让一台计算机同时支持多个网络程序，比如一个Web浏览器、一个Email客户端和一个文件共享应用程序。多路复用/多路分解的另一个作用是可以让一个应用程序同时保持与多台计算机的连接。 错误检查、流量控制和验证：协议系统需要一种全面机制来确保发送端与接收端之间的数据传输。 传输控制协议（TCP）： TCP提供了完善的错误控制和流量控制，能够确保数据正确传输，它是一个面向连接的协议。 用户数据报协议（UDP）： UDP只提供了非常基本的错误检查，用于不锈奥TCP精细控制功能的场合，它是一个无连接的协议。 6.2、传输层概念6.2.1 面向连接的协议和无连接协议&emsp;&emsp;针对不同情况提供不同程度的质量保证，传输层提供了两种不同的协议原型。 面向连接的协议：会在通信计算机之间建立并维护一个连接，并且在通信过程中监视连接状态。换句话说，通过网络传输的每个数据包都会有一个确认，发送端就是那几会记录状态信息来确保每个数据包都被正确无误的接收，并且在需要时会重发数据。当数据传输结束之后，发送端和接收端计算机会已适当的方式关闭连接。 无连接的协议：以单向方式向目的发送数据报，不承担通知目的计算机关于数据发送的职责。目的计算机接收到数据后也不需要向源计算机返回状态信息。 6.2.2、端口和套接字&emsp;&emsp;传输层冲到了网络应用程序与网络之间的接口，并且能够网络数据传递给特定的应用程序。在TCP/IP系统中，应用程序可以使用端口号通过TCP或UDP指定数据目的地。端口是一个预定义的内部地址，充当从应用程序到传输层或是传输层到应用程序之间的通路（如图6.3）。例如，客户端计算机通常利用TCP端口21来访问服务器上的FTP程序。 &emsp;&emsp;进一步观察传输层这种鱼应用程序相关的寻址体制，就会发现TCP和UDP数据实际是被发送到一个套接字上的。套接字是一个由IP地址和端口号组成的地址。例如，套接字地址111.121.131.141:21指向IP地址为111.121.131.141的计算机端口21.图6.4所示TCP的计算机在建立连接时如何交换套接字信息。 下例展示一台计算机如何通过套接字访问目的计算机上的一个应用程序： 121.计算机A通过一个熟知的端口向计算机B上的一个应用程序发起连接，熟知端口是互联网数字分配机构（IANA）分配给特定程序的端口。表6.1和6.2列出一些熟知的TCP和UDP端口。熟知的端口与IP地址组合之后就构成了计算机A的目的套接字。连接请求包含着一个数据字段，告诉计算机B使用什么套接字程序计算机A返回信息，这也就是计算机A的源套接字地址。2.计算机B通过熟知端口接收来自计算机A的请求，向作为计算机A源地址的套接字发送一个响应。这个套接字就称为计算机B上的应用程序向计算机A上的应用程序发送消息的目的地址。 表6.1熟知的TCP端口 服务 TCP端口 简要描述 tcpmux 1 TCP端口服务多路复用 compressnet 2 管理工具 echo 3 压缩工具 discard 7 回显 systat 11 用户 daytime 13 时间 netstat 15 网络状态 qotd 17 每日引用 chargen 19 字符说呢过程器 ftp-data 20 文件传输协议数据 ftp 21 文件传输协议控制 ssh 22 安全Shell telnet 23 终端网络连接 smtp 25 简单邮件传输协议 new-fe 27 NSW用户系统 time 37 时间服务程序 name 42 主机名称服务程序 domain 53 域名服务程序（DNS） gopher 70 Gopher服务 finger 79 Finger http 80 WWW服务 link 87 TTY链接 supdup 95 SUPDUP协议 pop2 109 邮局协议2 pop3 110 邮局协议3 auth 113 身份验证服务 uucp-path 117 UUCP路径服务 nntp 119 USENET网络新闻传输协议 nbsession 139 NetBIOS会话 表6.2 熟知的UDP端口 服务 UDP端口号 描述 echo 7 回显 discard 9 抛弃或空 systat 11 用户 daytime 13 时间 qotd 17 每日引用 chargen 19 字符生成器 time 37 时间服务程序 domain 53 域名服务程序(DNS） bootps 67 引导程序协议服务DCHP bootpc 68 引导程序协议客户端DCHP tftp 69 简单文件传输协议 ntp 123 网络时间服务 nbname 137 NetBIOS名称 snmp 161 简单网络管理协议 snmp-trap 162 简单网络管理协议trap 6.2.3、多路复用/多路分解 &emsp;&emsp;套接字寻址系统使用TCP和UDP能够执行传输层另一重要任务：多路复用和多路寻址;多路复用是指多个来源的数据导向一个输出，而多路分解是把从一个来源接收的数据发送多个输出。 &emsp;&emsp;多路传输/多路分解让TCP/IP协议栈较低层的协议不必关系哪个程序在传输数据。与应用程序相关的操作都由传输层完成了，数据通过一个与应用程序无关的管道在传输层与网际成传递。&emsp;&emsp;多路复用和多路分解的关键在于套接字地址。套接字地址包含了IP地址与端口号，为特定计算机上的特定应用程序提供了已个唯一的标识。参见图6.6中FTP服务器。所有客户端计算机使用熟知的TCP端口21连接到FTP服务器，但针对没太个人计算机的目的套接字是不同的。类似地，运行于这台FTP服务器上全部网络应用程序都使用服务器的IP地址，但只有FTP服务程序使用由IP地址和TCP端口号21组成的套接字地址。 6.3、理解TCP和UDP6.3.1、TCP：面向连接的传输协议包括以下重要特性： 面向流的处理： TCP以流的方式处理数据。换句话说，TCP可以一个字节一个字节地接收数据，而不是一次接收一个预定义格式的数据块.TCP把接收到的数据组成长度不定的段，再传递到网际层。 重新排序：如果数据以错误的顺序到达目的，TCP模块能够对数据重新排序来恢复原始恢复。 流量控制： TCP的流量控制特性能够确保传输不会超过目的计算机接收能力。由于现实世界里会有各种不同的应用环境，处理器速度和缓存区大小的差别也可能很大，所以这种流控制能力是非常重要的。 优先级与安全：国防部对TCP的规范要求可以为TCP连接设置可选的安全级别和优先级，但很多TCP实现并没有提供这些安全和优先级特性。 适当的关闭： TCP像重视建立连接一样重视关闭连接的工作，以确保在连接被关闭之前，所有的数据段都被发送和接收了。 &emsp;&emsp;仔细观察TCP，就会发现它是一个由通告和确认组成的复杂系统，用以支持TCP面向连接的功能。 &emsp;&emsp;TCP/IP这样的分层协议系统在发送端计算机上某一层与接收端计算机相应的层进行数据交换;换句话就说，发送端计算机的网络访问层与接收端计算机的网络访问层进行通信，发送端计算机上的网际层和接收端计算机上的网际层通信，以此类推。 &emsp;&emsp;典型的网络环境中（图6.7），数据从源子网经过路由器传递到目的子网。这些路由器通常工作于网际层，也就是传输层下面的层。这其中的重点在于路由器不关心传输层的消息，他们只是把传输层数据当做IP数据报的内容进行传递。封装在TCP分段中的这些控制和校验信息支队目的的计算机上的TCP软件有意义。这种工作方式能够加快TCP/IP网络之间的路由过程（因为路由器不参与TCP细致的质量保证），同时让TCP能够满足由端节点进行校验的要求。 TCP数据格式 TCP数据格式如图6.8。其复杂的结构揭示了TCP的复杂性和功能多样性。TCP格式中的字段如下： 源端口（16位）：分配给源计算机上的应用程序的端口号 目的端口（16位）：分配给目的计算机上的应用程序的端口号。 序列号（32位）：当SYN标记不为1时，这是当前数据分段第一个字节的序列号；如果SYN的值是1，这个字段的值就是初始序列值(ISN),用于对序列号进行同步，这时第一个字节的序列号比这个字段的值大1（也就是ISN+1） 确认好（32位）：用于确认已经接收到的数据分段，其值是接收计算机即可接收下一个序列号，也就是下一个接收到的字节的序列号+1 数据偏移（4位）：这个字段表示报头的长度，也就是告诉接收端的TCP软件数据从何开始，这个值得单位是32位的字 保留（6位）：保留字段，为TCP将来的发展预留空间，目前全部为0 控制标记（分别占用1位）：控制标记用于表示数据分段的特殊消息。 URG：为1时表示当前数据分段是紧急的，也会让“紧急指针”字段值有意义。 ACK：为1时表示“确认号”字段是有意义的。 PSH：为1时让TCP软件把目前收到的全部数据都通过管道传递给接收应用程序。 RST：为1时会重置连接。 SYN：为1时表示序列号将被同步，说明这是一个连接的开始，详见三次握手 FIN：为1时表示发送端计算机已经没有数据需要发送了，这个标记用于关闭一个连接。 窗口（16位）：用于流量控制的参数。它定义了发送端计算机的发送序列号可以超过最后一个已确认序列号的数量。也就是说，发送方不必等待每个数据段被确认接收之后才发送下一个数据分段，允许已经确认接收的序列号与正在发送的序列号有一定差别，但必须在适当范围之内。 校验和（16位）：用于校验数据分段的完整性，接收端计算机会根据接收到的数据分段计算校验和，并且把结构与这个字段的值进行比较。TCP和UDP在计算校验和时包含一个具有IP地址的伪报头。 紧急指针（16位）：这是一个偏移量指针，指向标记紧急信息开始的序列号。 选项：指定一些可选设置中的某一项 数据：数据分段中的数据 TCP连接TCP的一切连接操作都是在一个连接上下文的环境中完成的。TCP通过连接发送和接收数据，而这个连接必须根据TCP的规则进行请求、打开和关闭。 TCP的功能之一是为应用程序提供访问网络的接口。这个接口是通过TCP端口提供的，而为了通过端口提供连接，必须打开TCP与应用程序的接口。TCP支持以下两种打开状态。 被动打开：某个应用程序进程通知TCP转呗通过TCP端口接收连接，这样就会打开TCP到应用程序的连接，从而为参与连接的请求做准备。 主动打开：程序要求TCP发起与另一台计算机（处于被动打开状态）的连接，这就是主动打开状态（实际上，TCP可以对一个处于主动打开状态的计算机触发起连接，以解决两台计算机可能同时尝试建立连接的问题。） &emsp;&emsp;在通常情况下，想接收连接的应用程序（比如FTP服务器）会把自身及其TCP端口置于被动打开状态。在客户端计算机上，FTP客户端的TCP状态一般是关闭的，直到用户发起一个从FTP客户端到FTP服务器的连接，这对于客户端来说就是主动打开。处于主动打开状态的计算机（比如客户端）上的TCP软件就会开始一些用于建立连接诶的信息交换，这种信息交换被称为“三次握手”。 &emsp;&emsp;TCP发送的数据分段是不定长的。一个数据分段内，每字节数据都分哦诶一个序列号，接收端必须为接收到的每一个字节数据都发送一个确认号。 &emsp;&emsp;实际中，数据分段中并不是为每个字节都单独编了一个序列号，而是在报文的“序列号”字段制定了数据分段的第一个字节的序列号。这个规则有个例外，如果数据分段是连接初期使用，“序列号”字段里面包含的ISN，它的值比数据分段中第一个字节序列号小1。 &emsp;&emsp;“确认号”字段中的值是计算机准备接收的下一个序列号。如果发送端计算机没有在指定时间内收到确认消息，它就从已确认的下一个字节重新发送数据。 建立连接 &emsp;&emsp;为了让序列/确认系统正常工作，计算机必须对序列号进行同步。换句话说，计算机B必须知道计算机A的初始序列号（ISN），计算机A也必须知道计算机B使用什么ISN开始传输数据。这个序列号同步的过程被称为三次握手。三次握手总是发送在TCP建立初期。 计算机A发送一个数据分段,其中的参数是：SYN=1ACK=0序列号=X(X是计算机A的ISN)处于主动打开状态的计算机（计算机A）发送一个数据分段，其中的SYN为1，ACK位0，SUN是（同步synchronize）。它表示在尝试建立一个连接，第一个数据分段的报头中还包含舒适序列号（ISN），标记了计算机将传输的第一个字节的序列号。也就是说，要发送给计算机B的第1个字节的序列号是ISN+1。 计算机B接收到计算机A的数据分段，返回一个数据分段，其中的参数是：SYN=1(仍热在同步阶段)ACK=1（“确认号”字段将包含一个值）序列号=Y（Y为计算机B的ISN）确认号=M+1(M是从计算机A接收到的最后一个序列号) 计算机A向计算机B发送一个数据分段，确认收到计算机B的ISNSYN=0ACK=1序列号=序列中下一个号码（M+1）确认号=N+1(其中N是从计算机B接收到的最后一个序列号) &emsp;&emsp;在这三次握手完成之后，连接就被打开了，TCP模块就利用序列号和确认机制发送和接收数据。 TCP流量控制&emsp;&emsp;TCP使用的流量控制方法称为“滑动窗口”方法，TCP报头中“窗口”字段（也被称为“缓存大小”），接收客户端利用“窗口”这个字段来定义一个超过最后一个已确认序列号的序列号“窗口”，只有这个范围内的序列号才被允许发送端计算机发送。发送端在没有接收到下一个确认消息之前，不能发送超过这个窗口的序列号。 关闭连接&emsp;&emsp;当需要关闭连接时，计算机开始关闭过程，A(FIN:1)-&gt;B，之后进入“结束-等待（fin-wait）”状态，A的TCP软件继续接收数据分段，并处理意见在序列中的数据分段，但不在从应用程序接收数据了。当B接收到FIN数据分段时，它返回对FIN的确认信息，然后发送剩余的数据分段，通知本地应用程序接收到了FIN消息,B(FIN)-&gt;A，A返回确认消息，连接就被关闭了。 6.3.2、UDP:无连接传输协议&emsp;&emsp;UDP具有有限的错误检验功能，数据报中包含一个校验和，接收端计算机利用它来校验数据的完整性。（一般，这个校验和是可选的，而且能被接收端禁用以加快接收数据处理）。UDP数据报中有一个伪报头，包含数据报的目的地址，从而提供了发送数据报的错误传输手段。 另外，如果UDP接收模块接收到一个发给未激活或未定义的UDP端口的数据报，它会返回一个ICMP消息。通知源计算机这个端口不可达。&emsp;&emsp;UDP没有重新排序的功能，但一般不会导致不可靠的接收。 注意： UDP和广播 UDP的简单、无连接设计让它成为网络广播所使用的协议，广播是会被子网全部计算机接收和处理的单个消息。 &emsp;&emsp;UDP协议的主要用途是把数据报传递给应用层。&emsp;&emsp;UDP头包含4个16位字段，如图6.9 源端口：占UDP报头的前16位，通常包含发送数据报的应用程序所使用的UDP端口。接收端应用程序利用该字段作为发送响应的目的地址，这个字段可选，不写其端口号，字段全部置0。这种情况适用于单向消息，无需响应。 目的端口：这16位子弹包含的端口地址，是接收端计算机上UDP软件使用的端口。 长度：这16字段以字节为单位表示UDP数据报的长度。这个长度包含UDP报头和UDP数据载荷。因为UDP报头长度是8字节，所以这个值最小8 校验和：这16为字段可以检验数据在传输过程中是否损坏。校验和是对二进制数据串指向特殊计算而得到的结果。对于UDP来说，校验和是基于伪报头、UDP报头、UDP数据和填充的0而计算。源计算机生成校验和，目的计算机对它进行校验，让可客户端用用程序能够判断数据报是否完整。由于UDP报头中不包含源IP或目标IP地址，数据报可能会被传输到错误的计算机或服务。校验和使用的部分数据来自于从IP报头（被称为伪报头）提取的值，这个伪报头包含了目的IP地址的信息。让接收端计算机能够判断UDP数据报是否被错误交付。 注意：其他传输层协议 DCCP(数据报拥塞控制协议) SCTP（流控制传输协议）提供TCP和UDP不具备的增强特性。RTP(实时传输协议)提供了传输实时硬盘和视频的结构。 问：为什么路由器不向发起连接的计算机发送TCP连接确认？答：路由器工作于网际层（传输层之下），因此不处理TCP信息。 第8章 路由选择IP转发直接路由和间接路由路由协议本章将介绍网络上的路由器如何经过一个复杂的通信过程来决定数据传递到目的地址的最佳路径，内容包括路由器、路由表和路由协议; 8.1 TCP/IP中的路由选择&emsp;&emsp;大多数基本形式中，路由器是负责根据逻辑地址对通信流量进行过滤的设备。路由器一本工作于网际层（OSI模型的网络层）也建成为OSI的第三层，因此路由器也称为第3层设备。近年来，硬件厂商已经开发出了可以工作在OSI协议栈更高层的路由器。本章会介绍第4到第7层的路由器，就目前而言只考虑工作于网际层（第3层，和IP寻址位于同一层）的路由器。 &emsp;&emsp;当路由器将数据从一个网络传输到下一个网络时，它会替换网络访问层报头信息,因此路由器可以连接不同类型的网络。很多路由器还维护关于最佳路径的详细信息，这是根据距离、带宽和时间综合考虑而得到的。8.1.1 什么是路由器&emsp;&emsp;路由器看上去就像一台具备两款网络适配器的计算机。早期的路由器实际上就是具有两块或多块网络适配器的计算机（也成多宿主计算机）。如图8.1IP地址属于网络适配器的，不属于计算机。图8.1的计算机有两个IP地址，一个适配器各一个。实际上，这两个适配器可以具有完全不同的IP子网对应于完全不同的的物理网络。多宿主计算机上的协议软件能够从网段A接收数据，查看IP地址信息来判断数据是否属于网段B。如果是，就将其中的网络访问层报头信息替换为包含网段B物理地址信息的报头,再把数据传递网路B。 &emsp;&emsp;路由器的复杂特性： 路由器的端口（适配器）超过两个，也就是同时连接两个以上的网络。决定向那哪里转发数据就变得更复杂了，而且很可能增加冗余路由（事实上，终端用户在大多数LAN中见到的路由器用于连接两个网段，但是在Internet结构内可以存在更为复杂的场景） 由路由器连接起来的网络还分贝与其他网络连接。换句话说，路由器观察到的网络地址可能并不属于它直接连接的网络，它必须具备某种策略把数据转发到这些非直接网络上。 路由器网络提供了冗余的路由，每台路由器必须能够以某种方式决定使用哪个路径。 &emsp;&emsp;图8.1所示的简单配置加上前面的这几条复杂性。就可以得到路由器功能更详细的描述。如图8.2。 8.1.2 路由选择过程&emsp;&emsp;对路由器功能的全面介绍如下所述： 路由器从所连接的网络之一接收数据。 路由器把数据传递到协议栈的网际层。换句话说，路由器抛弃网络访问层层报头信息，并重组IP数据报（如果有必要）。 路由器检查IP报头中的目的地址。 如果数据的目的在其他网络，路由器就根据路由表决定向哪里转发数据。 在路由器决定了它的哪个适配器要接收这个数据后，就把数据传递给适当的网络访问测软件，让数据通过适配器进行传输。 &emsp;&emsp;这个路由选择如图8.3，有人觉得第4步是关键。但事实上路由表和建立路由表的协议是路由器具有的两个显著特性。对于路由器的大多数讨论都是关于建立路由表、汇集路由表的路由协议如何让所有的路由器像一个整体一样提供服务。 &emsp;&emsp;路由的类型主要有两种，它们的名称就源自于其从何处获取路由表信息。 静态路由：要求网络管理员手动输入路由信息。动态路由：根据使用路由协议获取的路由信息来动态建立路由表。 注意：预配置路由 大多数动态路由器允许路由器覆盖动态路由，并且对特定的地址配置静态路径。预配置的静态路由有时可以用于网络排错，有时也可以用于强制使用快速网络连接或平衡网络流量。 8.1.3 路由表的概念&emsp;&emsp;路由表和网际层其他路由元素的用途在于把数据传递到正确的本地网络。当数据到达本地网络之后，网络访问协议就会知道它的目的地。因此路由表不需要存储完整的IP地址，只需要列出网络ID即可。&emsp;&emsp;图8.4为一个非常基本的路由表内容。从本质上讲，路由表就是把目的网络ID映射到下一跳的IP地址，即数据报通往目的网络的下一站。路由表会区分直接连接到路由器本身的网络和通过其他路由器间接连接过来的网络。下一跳可以是目的网络（如果是直接连接），也可以是通向目的网络的下一个下游路由器。图8.4中路由器端口接口是指转发数据的路由器端口。&emsp;&emsp;路由表中的“下一跳”条目是理解动态路由的关键，在复杂的网络中，可能存在着通向目的的多条路径，路由器必须决定下一跳沿着哪条路径前进。动态路由器就与使用路由协议获取的信息来做出决定。注意：路由表 主机计算机可以向像路由器一样具有路由表，但由于主机不需要执行路由功能，它的路由表通常不会那么复杂。主机通常会使用默认路由或默认网关。当数据报不能再本地网络上传输或传递到另一台路由器时，它会被传递到充当默认网关的路由器。 8.1.4 IP转发&emsp;&emsp;主机和路由器都有路由表，相对于路由器，主机路由表简单多了，可能只包含两行，一个条目用于本地网络，另一个用于默认路由（处理不能在本地网段上传输的数据包） &emsp;&emsp;第4章，TCP/IP软件利用ARP将IP地址解析成本地网段上的物理地址，如果IP地址不在本地网段上会怎么样？IP不在本地网段，主机会把数据报发送到路由器。实际上不是这么简单。&emsp;&emsp;IP报头（图4.3）只包含了源和目的IP地址，它没有足够空间来列出传输数据报的中间路由器地址。&emsp;&emsp;IP转发过程实际上不会再IP报头中写入路由器地址，而是由主机把数据报和路由器的IP地址向下传递到网络访问层，该层的协议软件会使用一个独立的查询过程把数据报封装到一个帧中，通过本地网段传递给路由器。换句话说，被转发的数据报里的IP地址指向最终要接收数据的主机。而被转发数据报的帧中的物理地址指向路由器上的本地适配器地址。&emsp;&emsp;下面介绍整个过程（图8.5） 以太主机准备放一个IP数据报，它查看自己的路由表 如果数据报不能再本地网络上发送，主机就会从路由表里获取与目的地址相关联的路由器的IP地址（对于本地网段上的主机来说，这个路由器的IP地址一般都是默认网关的地址）。路由器的IP地址被ARP协议解析为物理地址。 数据报（目的是远程主机）和路由器的物理地址一起被传递给网络访问层。 路由器的网络适配器会接收到这个帧，因此帧的目的物理地址与路由器的物理地址相匹配。 路由器对帧进行拆包，把数据报传递给网际层。 路由器查看数据报的IP地址，如果这个地址匹配路由器自己的IP地址，就表示数据是要发给路由器本身；否则，路由器会查看自己的路由表，找到与数据报目的地址相关联的路由器，尝试转发这个数据报。 如何不能把数据报发送到与路由器相连接的任何网段，路由器就把数据报发送给另一台路由器，上述过程就会车功夫进行（从第1步开始），知道最后一个路由器就能过把数据报直接传输给目的主机。 &emsp;&emsp;此过程的第6步是路由器的一个重要特性。需要记住的是，并不是具有两块网卡的设备就能充当路由器。如果没有必要的软件来支持IP转发，就不能把数据从一个接口传递到另一个。当不具备IP转发功能的计算机接收到目标是其他计算机的数据报时，它只会忽略收到的数据。 8.1. 直接路由与间接路由&emsp;&emsp;如果一台路由器只连接了两个子网，路由表就会相对简单。图8.6所示的路由器不会看到没有与其端口相关联的IP地址，而且它是直接连接在全部子网上。换句话说，图中的路由器能够直接利用直接路由传递任何数据报。 &emsp;&emsp;再来看图8.7，更复杂一点的网络。路由A没有连接到网段3,而且在没有任何帮助的情况下也不能发现网段3，这种情况为间接路由。大多数路由式网络都在某种程度上依赖于间接路由。关于图8.7,最大的问题是路由器A如何发现网段3？路由器A如何知道发往网段3的数据报应该转发给路由器B而不是路由器C呢？ &emsp;&emsp;路由器了解间接路由器的方式有两种：从系统管理员和从其他路由器。&emsp;&emsp;这两种方式分别对应静态路由和动态路由。系统管理员可以直接从路由表中输入网络路由（静态路由），或者路由器B可以直接告诉路由器A关于网段3的信息（动态路由）。动态路由具有一个优点，首先，它不需要人工干预。其次，它可以对网络的改变做出相应。如果一个新的网段连接到了路由器B，路由器B就能把这个改变通知路由器A。 注意：静态路由和动态路由 路由器有时会同时使用静态路由和动态路由。系统管理员可以配置一些静态路由，让其他路径动态分配。静态路由有时可以用于强制流量经过特定路径。例如：系统管理员通过配置路由器可以把流量导向带宽较大的链接。 8.1.6 动态路由算法&emsp;&emsp;路由器的行为完全依赖于路由表。目前使用的路由协议有很多种，其中很多是围绕着这两种路由方法之一设计的。这两种方法分别是距离矢量路由和链路状态路由。这令中方法其实就是路由器相互通信和收集路由信息所采用的不同方法。使用两种方法的一堆路由协议：RIP(距离矢量路由协议)和OSPF(链路状态路由协议)说明：协议和实现距离矢量和链路状态是路由协议的累呗，实际协议的具体实现还包括其他特定和细节。另外，很多路由器支持启动脚本，静态路由条目等功能，使对距离矢量和链路状态路由的理想化描述变得非常复杂。 1、距离矢量路由&emsp;&emsp;距离矢量路由（也称为贝尔曼-福特路由）是一种高效、简单的路由方法，被很多路由协议所采用。它曾经在路由界占统治地位，虽然最近几年一些更复杂的路由方法（比如链路状态路由）逐渐流行起来，但距离矢量路由仍然相当常见。&emsp;&emsp;距离矢量路由设计目标：路由器之间所需通信最少，路由表中必须保留的数据最少。这种设计理念认为路由器不必知道通向每个网段的完整路径，而是只需知道向哪个方法方数据报即可（这也是术语“矢量”的由来）。网段之间的距离以数据报在两个网络之间传输必须经过的路由器的数量来表示，而使用距离矢量路由的路由器优化路径的方式是让数据报必须经过的路由器达到最少。这个距离参数被称为“跳数”、&emsp;&emsp;距离矢量路由的工作方式如下： 当路由器A初始化时，它感知到直接连接的网段，并把这些网段写入到自己的路由表中。这些直连网段的跳数为0，因此数据报从这台路由器到达这些网段不需要经过其他路由器， 在周期性的时间间隔中，路由器器接收到来自邻居路由器的报告，其中包含了邻居路由器所感知的网段和相应的跳数。 当路由器A从邻居路由器收到报告后，按照如下方法把新的路由信息添加到自己的路由表中。 如果路由器B的信息中包含一个路由器A目前还不知道的网段，路由器A就把这个网段添加到自己的路由表中。去往这个新网段的路由就是路由器B，也就是说，如果路由器A收到发向这个新网段的数据报，它会转发给路由器B。对于路由器A来说，这个新网段的跳数是路由器B的信息中列出的跳数再加1，因此它与路由器B相比，到达这个网段需要多一跳。 如果路由器B的信息中包含的网段已经存在路由器A的路由表中，路由器A就会把收到的跳数+1，把得到的值与自己路由表中的值相比较，如果经过路由器B的路由比路由器A已经掌握的路径更有效率（跳数更小），路由器A就更新自己的路由表，把路由器B作为通向相应网段的路径。 如果通过路由器B的跳数比路由器A路由表中的当前路由跳数大，经过路由器B的路由就不会被使用，路由器A继续使用自己路由表中保存咋路径。 &emsp;&emsp;随着每一轮路由表的更新，路由器对网络的了解越来越全面。关于路由的信息逐渐散步到只整个网络。假设网络不发生改变，路由器就会最终了解到通向每个网段的最高效的路径。 &emsp;&emsp;图8.8所示为一个距离矢量路由更新的例子。主要到在这一时刻，已经发生一些更新。因为路由器A和路由器B都已经了解到没有直接的网段。在这种情况下，路由器B具有通向网络14的更优路径。所以路由器A就会更新自己的路由表，把发往网络14的数据转发给路由器B。对于网络7来说，路由器A已经掌握的路径更好，所以表中相应内容没有改变。 2、链路状态路由&emsp;&emsp;在假设路径效率等同于经过路由器数量时，距离矢量路由是个很好的方法。这种假设的初衷很多啊，但在有些情况下过于简单了（即使在跳数一样的情况下，经过低速链路的路由也会比经过高速链路的慢）。另外，距离矢量路由并不特别使用与具有大量路由器的环境，因为没太路由器为每个目的网关都必须维护一个路由条目，而这些条目不过是矢量和跳数。路由器无法充分利用对网络结构的更多了解来提高其效率。而且，即使在大量信息都不必要的情况下，包含距离和跳数的完整表格必须在路由器之间进行传输。计算机科学开始思考能否做的更好，由此诞生了链路状态路由，而且它已经成为距离矢量路由器的主要对手。 &emsp;&emsp;连接状态路由背后的理念在于每个路由器都尝试建立关于网络拓扑的内部映射。每台路由器定期向网络发送状态信息，其中列出了自己直连的其他路由器以及链路的状态（链路在当前是否可用）。路由器利用从其他路由器收到的状态消息建立网络拓扑的映射，当它需要转发数据报时，会根据现有条件选择最佳路径。&emsp;&emsp;连接状态路由在每台路由器上都需要更多的处理时间。但带宽消耗减少，因为没太路由器不需要传播完整的路由表。另外通过网络追踪故障更容易了，因为特定路由器发出的状态消息在网络上传输时不会被改变（而在另一方面，即使距离矢量路由方法的路由器会在收到路由器消息时修改其中的跳数）。 8.2 复杂网络上的路由&emsp;&emsp;大型网络上包含数以百计的路由器，Internet则包含数以千计的路由器。在像Internet这样的大型网络上，让全部路由器都共享前面所述路由方法的所有信息是不可能的。如果每台路由器都处理Internet上其他路由器的路由信息，路由协议的流量和路由表的规模很快就会让整个系统崩溃。&emsp;&emsp;对于Internet上的路由器，并不是每一台路由器都需要知道其他所有路由器的信息。&emsp;&emsp;在网络有效组织环境下，大多数路由器只需要与相邻路由器交互协议信息即可。 &emsp;&emsp;在孕育了Internet的ARPAnet系统中，一小组核心路由器作为网络互联的中央骨干网，把自动配置和管理的独立网络连接在一起。核心路由器了解每个网络。但不必知道每个子网。只要数据报能够找到到达核心路由器的路径，就能够到达整个网络的任何位置。附属网络的路由器不必了解世界的全部网络。这个系统的发展为复杂的现代Internet(详见第17章)。 &emsp;&emsp;Internet由各个独自管理的网络组成，这些网络成为自治系统。自治系统可以是个公司网络，但目前更常见的是与Internet服务供应商（ISP）相关联的网络。自治系统的所有者管理每台路由器的配置细节。大多数路由器按照如下的通用分类进行指责划分，尽管以太路由器可以充当多重职责，但是路由器所使用的硬件，尤其是协议，确定了它在网络中的职责。 外部路由器：外部路由器在自治网络之间交换路由信息，他们维护自己及邻居自治网络的路由信息。边界路由器传统上使用外部网关协议（EGP）,实际的RGP现在已经过时，但外部路由器使用新路由协议一般也称为EGP。现在流行的一种EGP是边界网关协议（BGP）。外部路由器通常也作为自治网络的内部路由器。内部路由器：自治网络内部共享路由信息的路由器被称为内部网关，它们使用被称为内部网关协议（IGP）的一组路由协议，包括路由信息协议（RIP）、开放最短路经优先（OSPF）。详见本章后续。核心路由器：尽管最初APRAnet骨干网不再作为Internet的中心而出现，但是自治系统有时会构建自己的骨干结构，以细分和隔离流量。核心路由器支持骨干系统。核心路由器使用的路由协议包括网关到网关协议（GGP），以及新出现的SPREAD协议。 说明：自治网络内部的路由器也可能分层次进行配置，一个大型自治网络可能包含多组内部路由，并利用内部路由器传递这些内部组之间的路由信息。自治网络管理者可以根据需要设计路由器配置，并且相应地选择路由协议。 8.3 内部路由器&emsp;&emsp;内部路由器工作于自治网络的内部，它会掌握自己组内全部路由器所连接的网段信息，但不需要完整了解自治系统之外的网络。&emsp;&emsp;内部路由协议有多种，网络管理员必须根据网络情况和网络硬件兼容性选择内部路由协议。&emsp;&emsp;两种重要的内部路由协议：路由信息协议（RIP）和开放最短路由优先（OSPF）；RIP是一种距离矢量协议，而OSPF是一种链路状态协议。实际的协议实现都需要解决一些细节问题。注意：多协议 当今大多数路由器都支持多种路由协议。 8.3.1 路由信息协议（RIP）&emsp;&emsp;RIP是一种距离矢量协议，这表示它根据跳数来判断到达目的的最佳路径。RIP曾经非常流利，虽然现在有些过时，但仍然被广泛使用。RIP Ⅱ标准的出现解决了RIP Ⅰ的一些问题。现在很多都有其都支持RIP 和RIP Ⅰ。RIPⅡ 针对于IPv6网络的扩展被称为RIPng。 注意： RIP路由 RIP在UNIX和Linux上是通过routed daemon实现的。 &emsp;&emsp;作为一种距离矢量协议，RIP需要路由器收听和集成来自其他路由器上的路由和跳数信息。RIP的参与者被划分为主动和被动两种。&emsp;&emsp;主动RIP节点通常是参与正常的距离矢量数据交换过程的路由器，它会把自己的路由表发送给其他路由器，并且收听来自其他路由器的更新信息。被动RIP节点只收听路由更新信息。不传播自己的路由表，其典型代表就是普通计算机（主机也需要路由表）。 &emsp;&emsp;如果接收到的跳数进行处理后正好和路由表中保存的跳数一样，会如何处理?对于RIF来说，如果到达同一目的的两个路径具有相同的跳数，则会使用路由表现有的路径。这样会避免由于跳数相同而导致路由表条目不断被修改。 &emsp;&emsp;RIP路由器每30秒广播一次更新消息，它还可以要求立即更新。像其他距离矢量协议一样，当网络处于平衡状态时，RIP工作效果最好。如果路由器数量变得非常大。路由表的缓慢收敛可能导致问题。处于这个原因，RIP设置了从第一台路由器到达目的的最大跳数限制，其值是15,。这个规定限制了路由组的数量，但如果以层级方式组织路由器，15跳范围之内也可以组成大型网络。 &emsp;&emsp;虽然距离矢量发方没有特别考虑线路速度和物理类型的问题，但RIP允许网络管理员以手动方式把低俗路径的跳数设置得很大，从而影响事假的路由选择。古老的RIP协议逐渐被新的路由协议所取代，比如OSFP 8.3.2 开发最短路径优先（OSPF）&emsp;&emsp;OSPF比较新的内部协议，正在逐步取代RIP，OSPF是链路状态协议。&emsp;&emsp;OSPF路由器组中的没太路由器都被指定一个路由器ID,通常是与路由器相关联的最大IP地址（如果路由器使用了一个环回接口，路由器ID就是最大的回环地址）&emsp;&emsp;本章前面讲过，链路状态路由器会建立网络拓扑的一个内部映射，利用路由器ID来鉴别拓扑里的路由器。每台路由器都把网络描绘为一个树形，自己位于树的根部。这个网络树被称为最短路径树(SPT)，通过网络的路径就对应于通过SPT的路径，路由器计算每一个路由的开销。开销度量包括跳数和其他一些因素，比如链路速度和链路的可靠性。 8.4、外部路由器：BGP&emsp;&emsp;Internet是由大量的自治系统的内部路径，自治系统之间的路径，以及穿越自治系统的冗余路径组成即可。 &emsp;&emsp;外部路由在自治系统网络中传输流量时发挥了重要的作用。如今Internet上的外部路由器所以使用的最常见协议是边界网关协议（BGP）。&emsp;&emsp;实际上，BGP用途很广泛，可以用作自治系统内的内部协议，将网络细分为更小的区域，在自治系统的边缘使用的BGP版本被称为外部边界网关路由协议（eBGP）,它将消息从一个自治系统传输到另外一个自治系统。在自治系统内部使用的BGP称为内部边界网关协议（iBGP）。&emsp;&emsp;IANA为每一个自治系统分派了一个唯一的数值，称之为AS号或ASN。BGP使用这些AS号来构建Internet的映射，并将基于CIDR的无类别IP地址与穿越自治系统的路由关联起来。ASN提供了一种方法来识别网络是否独立于特定的IP地址（或地址范围）。该方法提供了去往自治系统的冗余路径（与通过IP地址控件的单条路径相对）但是由于ASN不是分层次的，因此BGP路由器必须知道网络中的所有其他BGP路由器。 注意：公共ASN和私有ASN iBGP主要用于在自治系统的内部来路由流量，它不需要IANA分配的公共ASN。内部BGP路由器使用私有ASN来转发流量，因此不会将流量转发到自治系统之外。 &emsp;&emsp;BGP路由器使用可靠地TCP连接来传递与地址范围相关的信息，并构建用来买搜狐网络路径的ASN链。BGP协议包括大量用于路径发现的条款，以及从多个选择中选取最高效路径的技术。 8.5 无类别路由&emsp;&emsp;TCP/IP路由系统是围绕网络ID的概念设计的，而网络ID时基于IP地址的地址类别（A、B和C）。在第5章讲到，这个地址分类系统有一些局限性，有时并不能有效的把一段地址指定给一个供应商。“无类别域间路由（CIDR）”提供了指定地址和确定路由的另一种方法。CIDR系统利用地址/掩码对来指定主机，比如204.24.128.0/17,掩码数字表示地址中多少位属于网络ID。&emsp;&emsp;如果路由协议支持CIDR，它会提供更有效的路由，CIDR让路由器能把多累网络同等对待，从而减少了路由器之间要传输的信息。最近一些路由协议，比如OSPF和BGP4，都支持无类别寻址。最初RIP不支持CIDR,随后的RIP II 更新支持了CIDR。 8.6 协议栈中的更高层&emsp;&emsp;协议占中的每一层都提供了不同的服务，并且在其包邮中封装了不同的信息。能够访问更高层协议的路由器可以根据更多的信息来决定路由。例如：工作于传输层的路由器能够根据源端口和目的端口推断数据的特性，而工作于应用成的路由器可以更详细的了解发送数据的应用程序和应用程序所使用的协议。 &emsp;&emsp;工作于更高层的路由器有很多优点，比如更好的安全型，使用这种技术的另一个重要原因是服务质量（Qos）的概念。 123456789101112自治系统：参与到更大网络的网络，由自治实体进行维护边界路由协议（BGP）：用来在自治系统之间路由流量的协议。BGP也用作自治系统内的内部协议。动态路由：一种路由技术，路由器基于该技术获得的信息来构建路由表。外部路由器：自治系统中的一种路由器，与其他自治系统传递路由信息。非直连路由：位于两个不能直接连接的网络中的路由。内部路由器：自治系统内部的路由器，与系统内的其他路由器交换路由信息。IP转发：把IP数据报从同一台设备的一个网络接口传递到另一网络接口的过程。OSPF(开发最短路径优先)：一种常见的链路状态内部路由协议。RIP(路由信息协议)：一种常见的距离失灵内部路由协议。路由协议：路由器用于汇聚路由信息的协议。SPT(最短路径树)：OSFP路由器生成的一种树形网络映射。静态路由：需要网络管理员手动输入路由信息的一种路由技术。 第9章 连网拨号连接宽带技术，比如电缆和DSL广域网无线网络连接连接设备 &emsp;&emsp;网络访问层管理与物理网络的接口，但是物理网络到底是什么？在位、字节、端口和协议层这些概念之后，Internet连接需要某种形式的设备把计算机或本地网段连接到更大的网络上。本章介绍访问TCP/IP网络所用到的一些设备和过程。 9.1 拨号连接&emsp;&emsp;以前，连接TCP/IP网络（比如Internet）的一种最常的方式是通过电话线，二在最近几年，像电缆调制解调器和DSL这样的宽带技术降低了拨号连接的重要性，但很多计算机仍然支持拨号连接，而且电话调制解调器在很多领域仍然是重要的连接工具，调制解调器（modem）通过电话线提供网络访问，它是Modulate/DEMoudlate(调制器和解调器)，调制解调器的作用在于把来自于计算机的数字传输转化为能够通过电话系统的端口进行传输的模拟信号，同时也把来自电话线的模拟信号转化为计算机能够理解的数字信号。 9.1.1 点到点连接&emsp;&emsp;第3章讲过，像以太网这样的局域网使用精致的访问策略让计算机共享互联网介质。与之相反的是，电话线两端的计算机不需要与其他计算机争用传输介质，它们只需彼此之间共享介质就可以了。这种连接方式被称为点到点连接（图9.1） &emsp;&emsp;点到点连接比局域网的配置简单，因为它不需要具备让多台计算机共享传输介质的方法。同时，通过电话线的连接也有一些局限性，最大的局限之一是电话连接的传输速率比局域网（比如以太网）要低得多，这导致他使用的协议相当简单,越简单越好。但是，随着调制解调器的速度越来越高，调制解调器的协议应急承担了额外的职责。 &emsp;&emsp;拨号协议的另一巨大挑战是要支持大量不同类型的硬件和软件配置。在局域网上，系统管理员监视和控制每台计算机的配置，协议系统依赖于通信设备之间的高度一致性。拨号连接却与之不同，它几乎可能发生在世界上的任何地点，拨号协议必须适应通信设备的硬件和软件更广泛的差异性。 9.1.2 调制解调器协议&emsp;&emsp;这种只涉及两台计算机的点到点连接也需要复杂的TCP/IP栈来建立连接吗？答案是“不”。 &emsp;&emsp;早期的调制解调器协议只不过是一种在电话线传输信息的方法，在这种情况下，TCP/IP的逻辑寻址和网间错误控制就是没有必要的。随着局域网和Internet的出现，工程师开始考虑让拨号连接作为提供网络访问的一种方式。这样远程网络访问概念的第一个是实现是对早期调制解调器协议的扩展，在这种最初的主机拨号方案中，连接到网络的计算机负责为网络准备数据。无论和显示的还是隐式的，远程计算机都像是个终端（图9.2），通过一个完整的独立的过程让连网主机利用调制解调器线路执行连网任务、发送和接收数据。 &emsp;&emsp;然而，这些早期主机拨号方案有一些局限性。它们反应了早期的中心化计算机模式，对提供网络连接的计算机要求过多，（图9.2配置中，想象如果多台计算机同步连接到拨号服务器会怎么样），而且也不能充分发挥远程计算机的处理能力。随着TCP/IP和其他路由器协议的实现，设计人员构想出另一种解决方案，让远程计算机负责更多的连网任务，而让拨号服务器发挥类似路由器的作用，这种方案（图9.3）与新式的、弱中心画的计算机网络模式更一致，也接近与TCP/IP的本质特征。在这种安排下，远程计算机运行自己的协议栈，让调制解调器协议工作于网络访问层，拨号服务器接收数据并路由到更大的网络。 &emsp;&emsp;这样一来，拨号协议直接与TCP/IP配合工作，并成为协议中的集成部分。最常见的两个TCP/IP调制解调器协议如下所示： 串行线路网际协议（SLIP）：基于TCP/IP的早期调制解调器的协议，相对简单，有很多局限性。点到点协议（PPP）：最初当前用于调制解调器连接的最流行协议，是对SLIP的细化，具有SLIP所不具备的很多重要特定。 PPP已经取代SLIP成为拨号Internet连接的协议。 注意：底层协议SLIP和PPP都建立与更低级的串行通信协议上，后者负责信号调制和解调的具体细节。这些串行通信协议提供了OSI模型中物理层的功能。 9.1.3 点到点协议（PPP）&emsp;&emsp;PPP设计目标是解决SLIP存在的一些缺点。&emsp;&emsp;PPP设计人员还希望PPP能够在连接建立初期进行动态协商配置，并且能够在会话过程中管理通信计算机之间的链路。&emsp;&emsp;PPP实际上式交互作用的一组协议，实现基于调制解调器连网所需的全部功能。RFC 1661把PPP组件划分为3大类： 封装多协议数据报的方法： SLIP和PPP都接受数据报，转换为适合Internet的形式。但PPP与SLIP不同的是，它还必须准备接受来自不同协议系统的数据报。建立、配置和测试连接的链接控制协议（LCP）： PPP能够通过协商方式进行配置，从而消除了SLIP连接遇到的兼容问题。支持高层协议系统的网络控制协议（NCP）簇： PPP可以包含不同的子层，从而为TCP/IP和其他网络协议提供单独的接口。 PPP的大部分功能来自于建立、管理和终止连接的LCP功能。1. PPP数据&emsp;&emsp;PPP（以及SLIP）的主要用途是转发数据报，其难点在与它必须能够转发多重类型的数据报，也就是说，数据报可能是IP数据报或OSI模型中网络层的其他数据报。 注意：数据包&emsp;&emsp;PPP RFC使用术语“数据包（packet）”来描述在PPP帧中传输的数据。数据包可以有IP（或其他高层协议）数据报组成，也可以由通告PPP进行操作的额其他按协议的数据组成。“数据包”这个词在整个网络界用于表示经过网络传输的数据，它并不是很严密的术语。本书中爱不分内容会使用更精确的术语，比如“数据报（datagram）”。但是，并不是所有的PPP数据包都是数据报，所以为与RFC保持一致，本章课程用术语“数据包”表示经过PPP传输的数据。 &emsp;&emsp;PPP也要转发与自己协议相关的信息，这些协议的作用是建立和管理调制解调器连接。通信设备在PPP连接过程中，会交换多重类型的消息和请求。通信计算机必须交换用于建立、管理和关闭连接的LCP数据包，支持PPP身份验证功能（可选）的验证数据包，与各种协议簇通信的NCP数据包。在连接初期交换LCP数据配置用于全部协议共同的连接参数，NCP协议配置与特定协议簇相关的参数。PPP帧的数据格式如图9.4 协议： 1或2字节的字段，提供代表被封装数据包协议类型的标识号。可能的类型包括LCP数据包、NCP数据包、IP数据包和OSI模型网络层协议数据包。ICANN负责规定各种协议类型的标准标识号码。 封装的数据（零或多个字节）：帧中传输的控制数据包或高层数据报。填充（可选，长度不定）：协议字段指定的协议所需的额外字节。每个协议自己负责区分填充字节与被封装的数据报。 2 PPP连接PPP连接的过程如下： 使用LCP协商过程建立连接。 如果第1步的协商过程指定了身份验证要求，通信计算机就进入身份验证阶段。RFC 1661提供了密码验证协议（PAP）和挑战握手验证协议（CHAP）这两个可选的验证选项。PPP还支持其他身份验证协议。 PPP利用NCP数据包指定与特定协议相关的配置信息。 PPP传输从高层协议接收到的数据。如果第1步的协商过程指定了链接质量监视，监视协议就会传输监视信息。NCP还可能传输与特定协议相关的信息。 PPP交换LCP终止数据包来关闭连接。 9.2 电缆宽带&emsp;&emsp;Internet服务的要求，以及不断增强计算机系统的能力，促进业界寻找新的连接方式来取代速度慢的电话调制解调器。处于成本的考虑，服务提供商并不是提供一个全新的布线体系，而是利用现有线路提供Internet服务。一种分布到每家每户兵器嗯可以支持Internet服务的布线系统就是优先电视网络。基于电缆的宽带目前在世界很多地方都很常见了，典型的电缆调制解调器连接如图9.5所示。 &emsp;&emsp;电缆调制解调器直接连接到一条同轴电缆，后者被连接到有线电视服务网络上。这个调制解调器通常具有一个以太网接口，可以连接到单台计算机或小型局域网中的交换机或者路由器。&emsp;&emsp;前面讲到，术语“调制解调器”是由“调制器”和“解调器”的缩写。与电话调制解调器相同，电缆调制解调器实现数字数字信号与模拟信号的转换，从而让数据能够通过电缆连接高速运行。&emsp;&emsp;名为电缆解调器终端系统（CMTS）的设备，在优先电视提供商网络的接口，接收来自电缆调制解调器的订好，把它转换回数字形式。有线电视提供商再从上游ISP租用宽带线路，利用路由器把用于与Internet连接起来。提供商还可以提供其他服务，比如用DHCP给网络上的用户动态分配IP地址。&emsp;&emsp;虽然电缆调制解调器起到了两种不同传输介质的接口和作用，但它并不是一个指针的路由器，更像是一个网桥。电缆调制解调器根据物理（MAC）地址在网络访问层过滤通信。然而近几年来，有些厂商在一些家用路由器设备中内置了电缆调制解调器，所以我们可能会看到一些组合设备，它们同时具有路由器和电缆调制解调器的功能。 &emsp;&emsp;为防止盗用服务，有线电视公司通常要求用户预先注册电缆调制解调器的MAC地址才能连接网络。 9.3 数字用户线路（DSL）&emsp;&emsp;另一种适合实现家用宽带传输介质电话网。当然，传统的电话调制解调器使用的就是电话网。但电话公司认为使用不同的方法可以得到更好的性能，这就是数字用户线路（DSL）。&emsp;&emsp;事实上，电话网使用的而双绞线能够提供的容量远超过语音通信的需求。DSL收发器作为局域网与电话网的接口，其工作频率不会影响线路的语音通信，因此DSL工作时不会占用线路或影响电话服务。&emsp;&emsp;与电缆网络一样的是，DSL网络要求在线路另一端也有一台设备接收信号，并且通过服务提供商的网络连接到Internet，这种设备就是“数字服务线路访问多路复用（DSLAM）”,该设备充当DSL连接的另一端（图9.6）。与电缆网络上一个网段的全部用户共享介质不同，每个DSL用户在收发器与DSLAM之间都是专线连接，所以性能受通信量的影响比较小。读者可能觉得，电缆网络和LAN类似，而DSL线路则是点对点电话连接类似。 &emsp;&emsp;DSL具有多种形式，包括ADSL（非对称DSL，用于小型办公室和家庭的最流行方式）、HDSL（高速DSL）、VDSL（甚高速DSL）、SDSL(对称DSL上下行带宽相等)和IDSL（基于DLS的ISDN）。从协议层来看，DSL根据装置和实现有多种变化。有些DSL设备集成到了交换机或路由器。有写则充当了网桥（类似于电缆调制解调器），在网络访问层根据物理（MAC）地址过滤流量。DSL设备通常用点到点协议（比如PPP）封装数据，比如最流行的基于以太网的PPP（PPPoe）协议。 9.4广域网&emsp;&emsp;大量计算机的公司和大型机构对网络访问的需求不能像拨号和DSL这样的小型技术所满足的，关键问题在于如何利用专有连接把分散在不同地点的分支部门连接起来，还有具有类似于局域网的私密性，并且在高级应用层面提供足够的性能。这个问题促进了广域网的发展。 &emsp;&emsp;广域网技术能够在远距离提供高速率带宽连网。虽然广域网的性能不是像局域网那样快，但通常比利用标准连网技术通过Internet连接远程主机的速度要快（而且更安全）。广域网风格的连接通常会以某种方式提供对大容量公司网络的访问，从某种意义上来说，广域网就是Internet本事的核心。 广域网的一些形式包括： 帧中继综合业务数字网（ISDN）高级数据链路控制（HDLC）异步传输模式（ATM） &emsp;&emsp;虽然这些看上去非常复杂，有些吓人（实际上也是），但实际上它们也是由于工作于TCP/IP网络访问层协议进行管理的物理网络规范的另一种形式（广域网协议几乎一直是OSI模型的中心，所以一定记住网络访问层对应OSI模型的物理层和数据链路层，也就是所谓的第1层和第2层）。 &emsp;&emsp;典型的广域网场景如图9.7所示。服务提供商运行一个广域网，提供对Internet的访问，也提供对用户分支机构的访问。一个本地环路把服务商的办公室连接到所谓的边界点，也就是客户连接到网络的点。客户提供路由器过其他必要的专用设备，从而通过局域网连接到广域网。 &emsp;&emsp;提供商确保从边界点之后的专用宽带和服务级别。服务的安排是多种多样的，可以用租借线路组成，也可以基于电路或包交换计量收费。 9.5 无线网络连接 802.11网络移动IP蓝牙 这些技术集成到产品和服务的方式取决于厂商。9.5.1 802.11网络&emsp;&emsp;物理网络的细节存在于TCP/IP协议栈的网络访问层。对无线TCP/IP网络的最简单理解就是在网络访问层使用无线方式连接到普通网络。流行的IEEE &emsp;&emsp;802.11规范为网络访问层进行无线网络连接提供了一个模型。&emsp;&emsp;802.11协议栈如图9.8所示。网络访问层的无线组件与以前学习的其他网络体系是同等的。事实上，802.11因为与IEEE 802.3以太网标桩的相似性和兼容性，经常被称为无线以太网。 &emsp;&emsp;从图看出，802.11规范位于OSI参考模型的MAC子层。MAC子层属于OSI模型的数据联络层。从第2章中可以知道，OSI模型数据联络层和物理层对应于TCP/IP的网络访问层。物理层的各种选项分别代表了不同的无线广播形式，包括跳频扩频（FHSS）、直接序列扩频（DSSS）、正交频分复用（OFDM）和高速率直接序列复用（HR/DSSS）。&emsp;&emsp;无线网络与优先网络的主要区别就是节点时移动的，换句话说，网络必须能够适应设备位置的改变。但前面的学习可以知道，TCP/IP网络的原始传输系统是建立在这样一种假设上：每台设备都位于固定位置。如果一台计算机移动到另一个网段，它必须配置为不同的地址，否则将无法工作。但无线网络上的设备会持续移动，而且在这个环境中虽然保留了以太网的很多传统，但情况可定会复杂的多，要求使用新的不同策略。注意：802.11家族 &emsp;&emsp;802.11实际上是一系列标准的统称，最初的802.11标准（1997）支持在2.4GHz频率范围内最高速率2Mbit/s。802.11a标准支持5GHz频率范围内最高速率54Mbit/s。802.11b标准支持2.4GHz频率范围内传输速率5.5Mbit/s和11Mbit/s。最后出现的标准有802.11g(在2003年被采纳)和802.11n（2009）。 1. 独立网络和网络基础&emsp;&emsp;无线网络的最简单形式就是两台或多台具有无线王珂的而蛇币直接相互通信，这种类型的网络的正式名称为独立基本服务集（独立BBS或IBBS），通常被称为ad hoc网络。独立BSS对于小范围内少量计算机来说就够用了。独立BSS网络。独立BSS网络有一定局限性，因为它主要依赖参与连网的计算机，没有提供管理连接的基础设备，也就不能链接更大的网络，比如局域网或Internet。&emsp;&emsp;另一种无线网络被称为基础基本服务集（基础BBS），在公司网络和其他机构是很常见的。基础BBS依赖于一个被称为访问点（Acess Point,AP）的固定设备与无线设备实现通信（图9.10）。AP利用无线广播与无线网络通信，它还通过传统连接方式连接到普通以太网。无线设备通过AP进行通信。如果一台无线设备想与同一区域中的其他无线设备进行通信，它把帧发送给AP，让AP把消息转发给目的。对于与传统网络的通信，AP就充当网桥的作用，把发给传统网络上设备的帧进行转发，并且把无线网络的通信隔离在无线区域中。&emsp;&emsp;图9.10所示的网络让计算机像有线以太网络上那样工作。而且多个访问点通过传统以太网连接在一起来为较大区域提供服务时（见图9.11）基础BBS的配置也有很多好处。&emsp;&emsp;802.11d的设计目标就是满足图9.11所示的网络需求，其里面是让移动设备在网络服务区域中漫游时保持连接。首先说明：如果设备需要接受全部网络传输，网络必须知道通过哪个AP能到达该设备，这当然要考虑到设备是可移动的，而且适合的AP也可能为未加提示的情况下发送改变。另外要说明的是，源地址和目的地址的传统概念对于在无线网络传输数据来说已经不够用了，802.11帧具有如下4中地址： 目的地址：帧传输的目的设备。源地址：发送帧的设备。接收者的地址：应该处理这个802.11帧的无线设备。如果帧要传输到无线设备，接收者地址就与目的地址是一致的。如果帧要传输到无线网络之外，接收者地址就是某个AP的地址，该AP会接收这个帧并且把它转发给以太网络。发射者地址：把帧转发给无线网络的设备地址。 802.11的帧格式如图9.12所示，其中一些重要字段如下所示： 帧控制：一些较小字段的集合，描述了协议版本、帧类型和解释帧内容所需的其他值。期限/ID：设置传输大致应该持续多长的时间。还可以请求AP缓存的帧。地址字段：48位的物理地址。由于802.11有时需要最多4中不同的地址，所有会根据不同类型的帧使用不同的地址字段。第1个字段通常是接收者地址，第2个字段通常是发射者的地址。序列控制：片选序列（用于重组片选）以及帧的序列号。帧主体：帧中传输的数据。第2章中已经介绍过，帧中传输的数据还包括上层协议的报头歇息。帧校验序列（FCS）：一个循环冗余校验值，用于检查传输错误并验证帧在传输过程中没有改变。 由于802.11是个网络访问层的协议集，所以802.11帧中使用的地址是48位物理地址，而不是IP地址。当设备在无线网络中移动时，它会向最近可用的P进行注册（从技术上讲，它会向信号最强、干扰性最小的AP注册）。这个注册过程被称为关联（association）。当设备漫游到另一个访问点附近时，它会重新关联到新的AP。这个关联过程让网络能够知道到达任何一设备应该使用哪个AP. 注意： WiFi联盟 为了确保802.11设备的兼容性，名为无线以太网兼容联盟（WECA成立于1991年）的组织提供了一个针对无线产品的认证项目。该组织后来将其名字命名为WiFi联盟，如果想得到Wi-Fi（无线保真）认证，必须对产品进行测试，已验证它与其他无线设备之间具有互操作性。有关WiFi联盟的更多信息，请访问www.wi-if.org。 2. 802.11安全&emsp;&emsp;很明显，没有保护的无线网络时很不安全的。在对传统网络进行窃听时，至少需要连接到传输介质上。而对于无线网络来说，在其广播范围之内就可以进行攻击。如果网络没有设党的保证措施，不仅容易被窃听，而且很容易就让非法用户进入网络。为了解决这些问题。IEEE制定了一个可选的安全协议标准用于802.11；有线等效保密（Wired Equivalent Privacy,WEP）标准，其目的是提供与传统优先网络大致相同的保密界别。WEP的目标在于解决如下问题： 机密性：防止窃听完整性：仿真数据被篡改身份验证：对连接团队进行验证，确保他们有操作网络的必要权限。 WEP使用RC4算法进行加密来实现机密性和完整性的目标。发送设备会生成一个完整性校验值（Integrity Check Value,ICV）,这个值是基于帧内容进行标准计算而得到的，它使用RC4算法进行加密，传输给接收方。接收设备对帧进行解密，计算ICV的值，如果计算后的ICV值与帧中传输的数值相同，就表示帧没有被修改。&emsp;&emsp;然而,WEP受到了安全专家们的反对。大多数转接任务WEP是无效的。有些对于WEP的之一实际上是反对RC4加密算法的实现。WEP在理论上使用64为密钥，但其中24位是用于初始化的，只有40位用作共享密钥。专家认为40位的密钥太短了，所以WEP不能实现有效的宝华。专家还执泥密钥管理系统和用于启动加密的24位初始化矢量。&emsp;&emsp;WEP2是对WEP的升级，把初始化矢量增加的128位，并且使用Kerberos身份验证来管理密钥的使用与分发。然而，WEP2并没有解决WEP的全部问题，因此出现了其他一些协议，比如可扩展身份验证协议(Extensible Authentication Protocol,EAP),可以解决WEP面临的难题。&emsp;&emsp;作为一个更好的无线安全协议，802.11i标准草案出现于2004年，并在2007年收入802,11标准。这个新方法也被吃呢改为WiFi保护访问2(WiFi Protected AcessII,WPA2),使用AES块密码而不是RC4进行加密，而且具有更安全的身份验证和密码分发过程，WPA2是无线安全领域的一大进步，而且作为无线网络连接使用的首选安全方法对WEP进行替换。 &emsp;&emsp;其他安全方法：无线路由器设置允许访问网络计算的MAC地址。可有效的防止邻居盗用带宽，但有经验的入侵者能够绕过这种控制。 9.5.2 移动IP&emsp;&emsp;世界各地移动设备给应答机制提出了一个问题。Internet 寻址系统是分级组织的，其前提是目标设备位于由IP地址定义的网段中。由于移动设备可能位于任何一个位置，所以通信规则就变得复杂多路。为了维护一个TCP连接，设备必须具有固定IP地址，这意味着漫游设备不能简单地使用一个由最近发射器分配的地址。另外由于这个问题与Internet寻址相关，它不能网络访问层得以解决，需要对网际成的IP协议进行拓展。移动IP拓展在RFC 3220中定义，之后又进行过多次更新，最新的IPv4移动标准是RFC5944。&emsp;&emsp;移动IP给固定IP地址关联上一个辅助地址来解决寻址问题。移动IP环境如图8.13所示，设备具有属于家乡网络的固定地址。家乡网络上有一个被称为“家乡代理（Home Agent）”的专用路由器，它维护一个表格，把设备的当前位置与固定地址绑定。当涉笔进入到一个新网络时，它将注册到该网络中运行的外地代理（Foreign Agent）中。外地代理就把移动设备添加到访问者列表，并且把设备当前位置的信息发送给家乡代理，家乡代理就会用设备当前位置信息更新自己的移动性绑定表。当发往这台设备的数据报到达家乡网络时，它被封装到一个目标为外地网络的数据包，最终到达该设备。 9.5.3 蓝牙&emsp;&emsp;蓝牙协议是无线设备的另一种规范。与802.11一样，蓝牙标准定义了OSI模型中数据链路层的物理层（等效于TCP/IP网络访问层）。在某种情况下802.11可以代替蓝牙，但是蓝牙的支持者总是很愿意表明蓝牙没有802.11的一些安全问题，然而蓝牙和802.11被看做是互补技术。802.11是为提供与以太网同等的无线网络，而蓝牙致力于在短距离范围之内为无线设备提供可靠的，高性能的环境。蓝牙的设计目标是实现一个小工作区域内一组无线交互设备的通信。在蓝牙的规范中，这个小区域被称为个域网（Personal Area Netwoek,PAN）.&emsp;&emsp;像其他无线形式一样，蓝牙使用AP把无线网络连接到传统网络（在蓝牙属于中，这个AP被称为“网络AP”或NAP）。蓝牙封装协议能够对进行TCP/IP数据包进行封装，从而在蓝牙网络进行传输。&emsp;&emsp;当然，如果一个蓝牙设备可以通过Internet访问，则它必须能通过TCP/IP访问。厂商预想生产一类兼容Internet的蓝牙设备，通过具有蓝牙功能的Internet网桥连接到Internet(图9.14)。蓝牙NAP设备充当网桥，通过具有蓝牙功能的Internet网桥，接收输入的TCP/IP数据，然后用蓝牙网络访问协议替换输入的网络访问层协议。从而把数据传输到接收设备。 9.6 连接设备&emsp;&emsp;前面介绍了TCP/IP网络中与路由器相关的重要主题，虽然路由器时非常重要和基础的概念，但TCP/IP网络还有其他很多连接设备。&emsp;&emsp;各种各样的连接设备都在TCP/IP网络流量管理中扮演不同的角色，下面将分贝介绍网桥、HUB和交换机。 9.6.1 网桥&emsp;&emsp;网桥是根据物理地址过滤和转发数据包的连接设备，它工作于OSI模型的数据链路层（对应于TCP/IP网络的网络访问层）。近些年来，网络倾向于使用功能更强的设备，比如交换机，所以网桥的使用越来越少。但网桥的集散单性敲好适合作为讨论连接设备的触发点。&emsp;&emsp;虽然网桥不是路由器，但仍然被使用一个路由表作为传输信息的根据。这个机遇物理地址的路由表与后面要介绍的路由表相比，不仅具有不同的形式，而且也简单得多。&emsp;&emsp;网桥监听它所连接的每一个网段，建立一个表来反应物理地址位于哪个网段。当数据在一个网段上传输时，网桥会查看数据的目的地址，与路由表进行比较。如果目的地址属于发送数据的网段，网桥就忽略这个数据。如果目的地址在不同的网段，网桥就把数据转发到是的网段。如果目的地址不在路由表中，网桥就会把数据转发到除网段之外的全部网段。注意：网络地址 vs 逻辑地址 要记住，网桥使用在基于硬件d物理地址与逻辑IP地址不同，这两者之前的去呗，详见第1~第4章， &emsp;&emsp;网桥层作为局域网上过滤流量的一种廉价设备大量使用，用于增加网络上能够融安的计算机数量。前面已经介绍过，现在一些网络访问设备都集成了网桥的功能。比如电缆调制解调器和某些DSL设备。由于网桥值使用网络访问层的物理地址，不检查IP数据报头的逻辑地址信息，所以不适合连接非同类网络。网桥也不能用于在大型网络（比如Internet）上实现数据转发的IP路由和传输方案。 9.6.2 HUB&emsp;&emsp;以太网出现的早期，大多数网络的连接方式是用一条连续的同轴电缆把计算机连接起来，然而，随后几年，工程师看到了使用中心设备将计算机连接在一起所具有的优势（图9.15）。&emsp;&emsp;在第3章讲过，经典的以太网概念是让全部计算机共享传输介质。每次传输都会被全部网络适配器监听。以太网HUB作为一个物理设备从一个端口接收数据，然后把数据重复到区域全部端口(见图9.15)。换句话说，全部计算机都好像是被一条连续线路连接在一起的。HUB不会过来或路由任何数据，只是接收和重新发送信号。&emsp;&emsp;智能HUB，比如检测线路故障和关闭端口。目前HUB基本上已经被交换机取代了。9.3 交换机&emsp;&emsp;基于HUB的以太网，仍然面临传统以太网的问题：性能岁流量的上升而下降。只有当线路空闲时，计算机才能进行传输。而且每个网络适配器都必须接受和处理网络上的每个帧。为解决这个问题比HUB更智能的设备—交换机—出现了。在其最基本形式下，交换机类似于图9.15中所示的HUB，每台计算机也是通过一条线路连接到交换机。但是，交换机知道应该接收到发送给哪个端口。大多数叫交换机把端口与所连接设备器的物理地址关联起来。当一个端口所连接的计算机发送数据帧时，交换机会查看帧的目的地址。把帧发送给与目的地址相关联的端口。换句话说，交换机只向应该接收数据的适配器发送数据帧。这样一来，每个适配器就不需查看网络上传输的全部帧。因此交换机减少了多余的传输。从而改善了网络性能。 &emsp;&emsp;注意，前面描述的1类交换机制操作物理地址，不处理IP地址。交换机不是路由器，实际上他更像网桥，准确地说像多个网桥结合在一起。交换机对每个网络连接进行隔离，从而只让针对特定计算机的数据进行特定线路（图9.17）。&emsp;&emsp;现在的交换方式有多种，最常见的两种交换方法如下所示： 直通式：交换机一获得目的地址就转发帧。存储转发：叫混迹在转发之前接收整个帧。这种法法会减缓转发过程，但有时可以改善整体性能。因为可以过滤出碎片和其他无效的帧。 &emsp;&emsp;交换机在今年来变得非常流行。公司局域网通常会使用分层式的交换机和互连式的交换机来优化性能。 注意：交换机和分层 &emsp;&emsp;厂商现在把前面介绍这种基础交换机概念看做是一个更大类别交换设备的俄译中特例。更负责的交换机工作于更高的协议层，能够根据各种参数决定如何转发。更复杂的交换机工作于更高的协议层，能够根据各种参数决定如何转发，载这种更通用的交换方法中，设备根据其工作的OSI协议层进行分类。前面介绍的基本交换机工作于OSI模型的数据链路层，被称为第2层交换机。根据IP地质信息进行转发的交换机工作于OSI模型的数据链路层，被称为第2层交换机。根据IP地质信息进行转发的额交换机工作于OSI模型的网络层，被称为第3层交换机（显然，第3层交换基础上就是某种路由器）如果本节没有明确说明交换机是工作于哪一层的，它一般就是工作于第2层的，根据物理（MAC）地址进行过滤。 第10章 名称解析&emsp;&emsp;最初的名称解析是在每台主机上保存一份host或host.txt数据表。需要手动更新，比较负责。之后出现DNS服务器，所有的名称由专门的DNS服务器，进行解析名称，DNS服务器并且进行分层。另外DNS名称空间是个多次排序的域名（图10.4）。TLD(Top Level Domain)顶级域名，是世界上最著名的DNS名称空间。域名可以包含主机名,这种域名被吃呢改为完全限定域名（FQDN）。&emsp;&emsp;NetBIOS Microsoft网络中常用的名称解析系统。&emsp;&emsp;DNS实现，DNS必须被实现为服务或后台程序。Windows服务器自带一个DNS服务，当然，有些管理员会倾向于使用第三方的DNS实现。在UNIX/Linux上则很多DNS实现，其中最长用的Berkeley Internet Name Domain(BIND)。 DNS安全扩展（DNNSEC）&emsp;&emsp;DNS数据是公共的，在这种情况下，安全型不在意味着私密性。但是客户端仍然需要一些方法来确保对DNS请求的答复是来自于真实的DNS服务器,而且这个服务器应该由区域进行监管。攻击者已经开发了集中技术来针对DNS查询发送伪造的响应。截获了DNS请求的攻击者可以发送伪造的响应，将可短端重定向到秘密的DNS服务器，该服务器充当启动攻击的一种手段。只是伪造的回复先于真是的回复达到DNS客户端，则该客户端就落入了圈套。这个问题的解决方案是提供一种方式来验证返回的DNS数据源的有效性。DNS安全扩展（DNSSEC）提供了验证DNS数据有效性的系统，如今很多操作系统都提供了DNSSEC选项，但是该DNSSEC仍然没有大范围的实现。但是有些高性能（high-profile）的域已经全面支持DNSSEC，是的DNSSEC慢慢被公众所接收。DNSSEC使用加密密钥和数字签名来提供安全。详见（第11章）。DNSSEC需要支持DNS扩展机制（EDNS）。ENDS的DO报头位表示一个DNSSEC查询。&emsp;&emsp;DNSSEC添加了一个验证过程来确保DNS查询的结果是可信的。与基本的DNS名称解析过程相似，DNSSEC从一系列步骤到达与给定查询中的名称相关联的区域。但是DNSSEC增加了一个信任链(chain-of-trust)类型的验证，其理念是从一个受信任的来时，将球球沿着一系列一直的和验证过的步骤向下传输，直到到达这样一个服务器；该服务器拥有一个用用来验证DNS数据来源的签名。为了实现该目标，DNSSEC添加了4个新的NDS资源记录类型。 DNSKEY: 用来签名和验证DNS资源记录集的公共密钥。DS:指向（并验证）子区域DNSKEY的资源记录。 DNS 工具&emsp;&emsp;1.使用ping检查名称解析&emsp;&emsp;2.使用NSLookup检查名称解析使用NSLookup工具查询NDS服务器，查看资源记录等信息。在需要对DNS问题进行排错时这个工具也十分有用，NSLookup工具可以按照下面两个模式进行操作。 批处理模式：在壁橱里模式中，用户可以启动NSLookup提供一些输入参数，NSLookup会根据参数执行被请求的功能，显示结果，最终关闭自己。交互式模式：在交互式模式下中，用户启动NSLookup时不需要提供输入参数。NSLookup会提示用户输入参数。在用户输入参数后，NSLookup将执行被请求的操作，显示结构并重新返回提示符状态，等待接下来被输入的参数。大多数管理员都会使用交互式模式，这是因为在需要执行一系列操作时，这种模式更方便。 域名信息搜索(DIG)&emsp;&emsp;Linux（在服务器机房中很常见）上一个留学的DNS命令工具是域名信息搜索（Domain Information Groper，DIG）许多管理员认为DIG要比NSLookup更灵活。（dig ） 动态DNS：&emsp;&emsp;上述所介绍的DNS都是用于主机名和IP地址永久（半永久）关联情况下。计算机每次启动时，DHCP都会分配一个新的IP地址。这意味着,DNS服务器必须通过某种法法获悉该计算机正在使用的IP地址。&emsp;&emsp;由于动态IP地址的逐渐流行，DNS厂商必须加以适应，现在，一些IP实现（包括BIND）提供了动态更新DNS记录的功能。在图10.9所示典型场景中，主机从DHCP服务器获得IP地址，必须使用这个新地址更新DNS服务器。（DHCP详见第12章）&emsp;&emsp;企业目录系统（比如Microsoft的活动目录）在目录结构中使用动态DNS来管理DHCP客户端系统。懂台DNS服务在Internet上也是常见。有些在线服务提供了一种方法，可以让使用动态地址的计算机注册一个永久的DNS名称。用户可以访问这些服务，来远程连接到使用DNS名称的家庭网络中，或者是运行没有静态地址的个人站点。注意： DNS服务发现 &emsp;&emsp;DNS最近的另外一个创新是DNS服务发现，有关DNS服务发现的详情觉其他零配置技术介绍，详见12章。 NetBIOS名称解析&emsp;&emsp;NetBIOS是一个API和名称解析系统，最初是由IBM开发，如今在Microsoft的Windows网络中很常见。NetBIOS被开发出来的目的是将其用于不使用TCP/IP的网络。，流行和Samba文件服务和其他独立的工具也都支持NetBIOS名称解析。1.NetBIOS名称的解析方法&emsp;&emsp;在TCP/IP网络上，NetBIOS名称即系的最终目的是为一个给定的NetBIOS名称提供IP地址。&emsp;&emsp;NetBIOS名称是由15个字符组成的。例如Workstation1、HBServer和CorpServer。NetBIOS不允许在网络上由重复的计算机名。注意：NetBIOS名称 &emsp;&emsp;从技术角度讲，NetBIOS名称由16个字符。但是，第16个字符是由底层应用程序使用的，通常不用用户直接配置。随扈的内容将讨论这些字符。 &emsp;&emsp;NetBIOS名称与主机名类似，没有层次。集中将NetBIOS名称解析为相应IP地址的方法： 基于广播的名称解析LMHosts文件名称解析WINS名称解析 （1）、基于广播的名称解析&emsp;&emsp;NetBIOS名称解析可以通过广播完成。计算机会使用广播与本网段中其他所有机器联系，要求返回特定计算机的地址。网段上的计算机监听到广播后，只有指定的计算机才会响应这个请求。这种名称解析的方法被称为B-Node名称解析。它可以在LAN环境中很好工作，但如果网络不仅仅局限于LAN，这种方法就无法工作（由于路由器会阻止广播传递）。（2）、LMHosts文件名称解析&emsp;&emsp;Windows系统还可以使用LMHosts文件将NetBIOS名称解析成IP地址。LMHosts文件与主机文件很相似，会将NetBIOS名称与IP地址关联。 第11章 TCP/IP 安全1. 什么是防火墙&emsp;&emsp;早期的防火墙只是包过滤，许多包过滤防火墙会查看封装在传输层报头中的TCP和UDP端口号。因为大多数Internet服务都与端口号相关联，因此通过检查数据包的目的端口号可以确定数据包的企图。这种形式的数据包过滤可以让管理员声称“外部的客户端无法访问内部往来上的Telnet服务”。存在问题，端口重置配置&emsp;&emsp;在防火墙的进化过程中，出现了另外一种称之为有状态防火墙的设备。有状态防火墙不仅仅是单独价差每一个数据包，还会检查数据包包含在哪个通信会话新序列中。这种状态敏感性有助于有状态防火墙监视诸如无效数据包、会话劫持企图，以及某些拒绝服务攻击这样的攻击手段。&emsp;&emsp;应用层防火墙是最新一代防火墙。在TCP/IP应用层。可以更全面地理解与协议和服务相关联的数据报。 DMZ&emsp;&emsp;防火墙为内部网络提供了一种受保护的空间，是网络很难从外部进行访问，这个概念对于Web客户端工作组（其中包含烧录满足内部需要的文件服务器）是很适合的。不过在很多情况下，一个公司通常不会禁止外部网络访问自己的所有资源。例如，需要从外部访问公共Web服务器，许多公司还安装了FTP服务器、E-mail服务器和其他需要从Internet访问的系统。尽管从理论上讲，只要开发防火墙的端口就可以允许外部客户访问特定系统上的特定服务，但是，这也就是说，服务器可以从外部进行操作，其结果是导致一系列网络管理员不希望看到的流量和安全型问题。&emsp;&emsp;一种方法是将服务器放在防火墙之外（Internet—-服务器—-防火墙）（图11.2）。使之与内部网络的客户端隔离。另外替换方案（相对于图11.2所示方案）图11.3。使用两个防火墙。另个防火墙之前的空间被称为DMZ(一种军事术语—-Demilitarized Zone非军事地带)。与开放的Internet相比，DMZ可能提供更好的安全性，但是其安全性比内部网络低&emsp;&emsp;图11.3所示的场景还可能出现下面的情况；只使用一个能够连接多个网段中的防火墙，如图11.4所示，如果防火墙/路由器有3个或更多的接口，可以将内部网络和DMZ分别连接到这些接口上，同时为每个接口应用不同的过滤规则。 防火墙规则&emsp;&emsp;通常允许网络管理员创建的内容包括： 资源地址或地址范围目的地址范围服务行为 这些参数提供了大量选项，用户可以关闭所有来自获取网特定地址范围的流量。可以关闭来自于特定地址的特定服务，例如Telnet或FTP。 代理服务&emsp;&emsp;所有用来保护和简化内部网络，将潜在不安全Internet活动限制在边界之外的技术中心，防火墙是核心技术。另一种相关的技术是代理服务。代理服务器可以接货对Internet资源的请求，并替换客户端转发这些请求，它在客户端和请求目的的服务器之间扮演了一个中介的角色（图11.6）。尽管代理服务器不足以通过自己包含网络，但是它通常被用于与防火墙联合使用（尤其是在网络地址转换环境中）。&emsp;&emsp;代理服务器可以使得客户端免于直接与恶意网站联系。一些代理还可以执行内容过滤。查看信息是否来自于黑名单的服务器，或者内容是否带有潜在的危险。代理服务器还常被用来限制内部网络客户端的浏览范围。&emsp;&emsp;在很多情况下，使用代理服务器的主要目的是性能，而非安全性。代理服务器还可以执行对服务器的内容缓存。内容缓存代理服务器会保存被访问过网页的拷贝。对这些网页的再次请求将直接用本地拷贝响应。 逆向代理&emsp;&emsp;传统意义上的代理服务器（在一节中描述）代理的是对向外发送到Internet上的请求。另一种形式的代理服务器被称为逆向代理，它接收来自外部资源请求，将这些请求转发给内部网络。与常规代理服务器相同，逆向代理也提供缓存和内容过滤特性。因为逆向代理主要用于保证计算机能够在Internet上提供服务，因此安全性特别重要。 2. 攻击技术&emsp;&emsp;有若干个方法来获得入口和取得足够的权限，尽管不可能描述全它们，但是可以把这些技术分为3个基本的类别。 &emsp;&emsp;证书攻击：这些高攻击集中在获得证书以正常进入系统。在本质上，这些攻击甚至发生在入侵者渗入安全系统之前。这一技术 的一种变型是权限提升，即攻击者先获得低级别的访问权，然后再设法获得更高的权限级别。&emsp;&emsp;网络层攻击：攻击者通过找到一个开放的端口、无保护的服务或者是防火墙中的缺口偷偷进入。其他网络层攻击技术利用TCP/IP协议系统的席位差别，以获得信息或重新路由连接。&emsp;&emsp;应用层攻击：攻击者利用系统上运行的某个应用程序（例如Web服务器）的代码中的已知缺陷，欺骗该应用程序执行任意命令，或者是以一种程序设计人员从未想到的方式运行。 &emsp;&emsp;一次全面的而忘了入侵，通常组合使用这些攻击技术。典型情况下，攻击者可能会使用应用层攻击作为最初的图片，然后把权限逐步提升至管理员级地位，再接着打开一个隐藏的后门，以便无限制的访问整个系统。”后门”常用的技术是安装一个rootkit来在系统上找到一个立足点，然后再掩盖入侵。1、证书攻击：常用的密码攻击方法包括： 看看机箱外面；特洛伊木马猜测窃听 2、特洛伊木马&emsp;&emsp;早期的特洛伊木马是，伪造登录屏幕。这种偷取密码的技术针对公共设置而设计。并不是所有的特洛伊木马都捕捉密码，而且并不是所有密码特洛伊都像本节所描述的那个示例那样木马张胆。许多木马程序，有些表现为游戏或假的系统工具。3、猜测4、窃听&emsp;&emsp;包嗅探器（Packet Sniffer）和其他监视网络流量的工具，可以轻松地捕获以明文形式在网络上传输的密码。许多经典的TCP/IP实用程序；例如Telnet和r*工具，或者是SNMP,都被设计为明文形式传输密码。加密SSL和IPSec。 网络层攻击&emsp;&emsp;通过端口来进行攻击。一般使用Nmap和Nessus之类的扫描工具，可以自动完成查找开发端口的过程。应用层攻击&emsp;&emsp;缓存区溢出。如果用户的而输入溢出该缓冲区，奇怪的事就会发生。如果输入没有被适当管理，那么溢出缓冲区的数据就可能边长为驻留在CPU的执行区域中，那以为这经过缓冲区溢出发送给计算机的命令，可能会被实际执行（图11.8）。避免缓冲区溢出问题，应用程序必须提供一种方法，在将数据写入应用程序一出去之前，接收并检查数据的大小。较好的解决办法是在养成良好的程序设计习惯。root访问&emsp;&emsp;在入侵者进入网络之后，首要任务是上传一个rookit,用于在系统上建立一个更加稳固的立足点。rootkit还具有额外特性，Key loggers能够捕获和记录键盘输入。网络钓鱼&emsp;&emsp;超文本链接，以指向一个不同的网站。不仔细检查URL，很容易上当。最好策略，不要点击不明链接。还有一种被称为跨站脚本策略，利用代码注入，绕过浏览器安全措施，以发起用户正在查看的页面不易追踪的某个恶意脚本。拒绝服务攻击&emsp;&emsp;进来，一种狂热的Internet入侵是拒绝服务（Denial of Service,DoS）攻击。DoS一旦发起，几乎不可能停止，因为它并不要求攻击者在系统上拥有特定权限。DoS攻击的关键是用大量的请求阻塞系统，使系统资源全部耗尽，性能降低。最危险的DoS攻击是分布式DoS攻击。在分布式DoS攻击中，攻击者利用若干台远程计算机，只会其他远程计算机发起一场协同攻击。有时，几百台或几千台计算机可能参与到针对某个IP地址的攻击。 防范措施 使用正确配置的防火墙使用安全的密码。尽管具体策略不同，但是大多数专家都建立密码的最短长度为6~8个字符，而且面中要包含字符、数字和标点符号。不要单击可疑的链接使用最低的权限来操作windows系统，安装病毒防护软件关闭不需要的服务如果必须要访问内部网络，请使用VPN来进行加密通信。使用防火墙，关闭所有端口，关闭所有网络服务，除非你是真的需要的这些服务。在沙箱环境中运行服务，无线网络中使用加密经常安全更新 4. 加密和保密&emsp;&emsp;本节先讨论了机密性的目的（确保数据的秘密）。安全系统还必须满足如下需求： 身份验证：确保数据来自产生它的源头。完整性：确保数据在传输过程中未被篡改。 本章后续内容重点关注如何保护TCP/IP免受窃听、截获和操纵。 算法和密钥对称加密，非对称加密，数字签名，数字证书。保护TCP/IP（1）、SSL和TLS&emsp;&emsp;安全套接层（Secure Sockets Layer,SSL）是美国Netscape公司为保护Web通信而引入的一个TCP/IP安全协议集。SSL的目的，在传输层的套接字和提供那些套接字访问网络的应用程序之间提供一层安全。图11.15显示了SSL在TCP/IP协议栈中的位置。理念是，在SSL被激活时，网络服务（例如FTP和HTTP）便将受到安全的SSL协议的保护，以免遭攻击，传输层安全（Transport Layer Security TLS）。以SSL3.0为基础，所以通常被认为是SSL的后续产品，现在它已成为业界标准。但是，在产品名称和真是的软件中，仍然称其为SSL。TLS协议与SSL类似。&emsp;&emsp;仔细查看SSL层，可以发现它包含两个子层（见图11.16）。SSL记录协议（Record Protocol）是访问TCP的一个标准库。在这个记录协议之上，是一组执行特定服务的SSL相关协议。 SSL握手协议（Handshake Protocol）：用来访问TCP的基础协议。SSL更改密文规范协议（Change Cipher Spec Protocol）:支持对加密套件设置的更改。SSL告密协议（Alert Protocol）：发出告警。 SSL采用公开密钥加密，并提供对数字证书的支持，带有SSL加密的HTTP Web协议版本被称为HTTPS。SSL在传输层之上。 注意： SSL和TLS都是用于面向连接的TCP连接，称之为数据报报传输协议安全（Datagram Transport Protocol Security,DTLS）的另外一种协议提供了类似于TLS的安全，它可以支持使用UDP的无连接通信。 （2）IPSec&emsp;&emsp;IP安全（IPSec）是TCP/IP网络上使用的另一种安全协议系统。。IPSec在TCP/IP协议栈中运行，位于传输层之下。IPSec提供对机密性、访问控制、身份验证和数据完整性支持。IPSec还可防护重放攻击。相互通信的两台计算机的协议栈都必须支持IPSec。IPSec非常适用于为像路由器和防火墙之类的网络设备提供安全。IPSec可以以下面两种模式之一运行。 传送模式为IP数据包的载荷提供加密。该载荷然后被封装进一个正常的IP数据包中进行传送。隧道模式加密整个IP数据包。加密后的数据包，然后被作为载荷封装到进另一个外部数据包。 IPSec隧道模式通常用于虚拟专用网络（VPN)产品,它们用来在公共网络中创建一个完全专用的通信隧道。&emsp;&emsp;IPSec使用许多加密算法和密钥分发技术，数据使用像AES、RC5或Blowfish这样的常规加密算法进行加密，身份验证后密钥分发可能会使用公开密钥技术。 （3）、虚拟专用网络（VPN）&emsp;&emsp;虚拟访问这个问题实际上已经是贯穿TCP/IP发展的一个重要问题。如何连接距离不是很近，不够采用LAN样式电缆连接的计算机呢？系统管理员总是依赖以下两种重要的方法进行远程连接。 拨号：远程用用通过调制解调器连接到某个拨号服务器，后者充当到网络的一个网关。广域网（WAN）：两个网络通过租用电话公司或Internet服务提供商的专用线路连接在一起。 &emsp;&emsp;这两种方式都有缺点。拨号连接速度慢，而且他们依赖于电话连接的质量。WAN连接有时也比较慢，最重要的是，构建和维护WAN会比较昂贵，而且它不可移动。针对这些问题的一种解决方法是：通过开放式的Internet直接连接到远程网络。这个方法快速、方便，但是Internet上充满敌意和不安全因素，如果不提供某种防止窃听的方式，那么这样的选择完全不可行。专家考虑是否有某种方式可以利用加密工具来创建一个穿过公用网络的专用隧道。这个解决方便便形成了我们现在所知道的虚拟专用网络（Vitural Private Network,VPN）。VPN建立一个横穿网络的点对点“隧道”。 注意： VPN协议&emsp;&emsp;本章前面所讲的IPSec是一种支持安全网络连接的协议，而VPN就是连接的本身。VPN应用程序就是创建和维护这些专用远程连接的程序。有些VPN工具利用IPSec进行加密，有些则依赖于其他SSL或其他加密技术。Microsoft的系统通过“点对点隧道协议”（源自PPP调制解调器协议）提供VPN隧道功能；比较新的Microsoft系统为VPN会话采用“第2层隧道协议”（L2TP）。 &emsp;&emsp;如果传输链中的每一台路由器都需要知道加密密钥，那么本章前面所描述的加密技术将无法很好地发挥作用。加密是针对点对点连接的。这里的理念是：远程服务器上VPN客户端软件与一台充当所有网络网关的VPN服务器建立连接（图11.17）。VPN客户端和服务器交换通过Internet政策传递的、可路由的明文TCP/IP数据报。不过，通过VPN连接发送的载荷（即数据），实际上就是加密后的数据报。加密后的数据报（在开发的Internet上是不可读的）被封装入可读取明文的数据报中，在转发给VPN服务器。VPN服务器软件接着提取加密后的数据报，利用加密密钥解密该数据报，然后将封装数据转发至受保护网络上的目的地址。 （4）、Kerberos&emsp;&emsp;Kerberos是一种基于网络的身份验证和访问控制系统。用于支持跨敌意网络的安全访问。对于敌意网络的安全通信问题，较简洁的回答就是加密。较长的回答则是提供一种手段，来保护加密密钥的安全。Kerberos提供一种系统的方法，用于向通信主机分发密钥，并检验情书访问某一服务的客户端的证书。&emsp;&emsp;Kerberos系统使用被称为密钥分发中心（Key Distribution Center,KDC）的服务器来管理密钥分发过程。Kerberos身份验证过程涉及以下3个实体的关系。 客户端：请求访问服务器的计算机服务器：在网络上提供服务的计算机KDC：指定为网络通信提供密钥的计算机 &emsp;&emsp;Kerberos身份验证过程如图11.18，注意,这个过程假设KDC已经有一个共性的密钥可以用来与这里的客户端进行通信，还有一个共享的密钥可以用来与这里的服务器进行通信。这些密钥用来加密一个新的会话密钥，客户端和服务器将使用它进行相互通信。KDC用来为客户端和服务器加密数据的那两个单独密钥被称为长期密钥。长期密钥通常产生于KDC和另一台计算机共享的一个秘密。一般而言，客户端长期密钥尝试与客户端和KDC都知道的用户登录密码的一个哈希。 图11.18&emsp;&emsp;具体过程如下。记住，Kerberos一般使用常规的（对称）加密技术，而不是公开密钥的（非对称）加密技术。 这里的客户端想要访问服务器A上的额某个服务。它向KDC放放松一个请求来访问服务器A上的服务（在某些情况下，客户端已经经过身份验证，并接收到一个单独的会话密钥，用于加密与KDC上票证授予服务的通信）。 这里的KDC执行以下步骤 a. KDC生成一个会话密钥，该密钥用于加密客户端和服务器A之间的通信。 b. KDC创建一个会话票证（session ticket）,它包括步骤2a中所生成的会话密钥的一个副本。该票证还包含时间戳信息以及有关正在请求访问的客户端的信息，例如客户端安全设置。 c. KDC使用服务器A的长期密钥加密刚创建爱你的会话票证 d. KDC为客户端绑定加密后的会话票证、会话密钥的一个副本以及其他响应参数，并使用客户端的密钥加密整个数据包。该响应然后被发送给客户端。 客户端接收来自KDC的响应并解密。客户端将获得与服务器A通信所需的会话密钥。它所接收的密钥加密整个数据包，还包括KDC创建的会话票证，那是使用所请求的服务器的长期密钥加密的。客户端无法读取该会话票证，但是它知道必须将此票证发送给相应的服务器，才能通过身份验证，客户端创建一个鉴别码（一串身份验证参数），并使用这里的会话票证对它进行加密。 客户端向服务器A发送一个访问请求。该请求包括上述会话票证（已使用所情书服务器的长期密钥进行加密）和鉴别码（已使用会话密钥进行加密）。这里的鉴别码包括用户的名称、网络地址和时间戳信息等。 服务器A接收上述请求。服务器A使用其长期密钥解密上述会话票证（见步骤2c）。服务器A从会话票证中提取会话密钥，并使用该会话密钥解密鉴别码。服务器A检验鉴别码中的信息是否与包括在会话票证中的信息相匹配。如果是，则授予对所请求服务的访问权。 作为可选的最后一步，如果客户端想要检验服务器A的整数，服务器A将用会话密钥加密一个鉴别码，并将这个鉴别码返回客户端。 作为一种为网络提供统一标准登录系统的手段，Kerberos系统正越来越流行。Kerberos 4使用DES加密技术，前面讲过，许多加密领域的专家认为该技术不安全。Kerberos 5则支持AES和其他加密类型。 注意： 3个头?&emsp;&emsp;Kerberos（也称Cerberus）。三个头就是Kerberos身份验证过程的3个要素（客户端、服务器和KDC）。Kerberos系统最初设计使用身份验证、账户管理和审核这三个头，守护网络的入口，但是其中的后两个头（账户管理和审核）从未实施。安全界很轻易地发现。相对于把相应的协议重新命名为相当单头犬来说。 关键术语：高级加密标准（Advanced Encryption Standard,AES）:一种对称加密，支持128,192和256为密钥长度非对称加密：使用不用密钥进行加密和解密的加密方法后门：可以进入计算机系统的一条隐藏路径。Blowfish：一种对唱加密算法，支持最多448位密钥长度缓冲区溢出：一种攻击方法，攻击者向系统发生恶意的命令，从而导致应用程序的缓冲区超出限度。认证中心（Certificate Authority,CA）:监视证书床啊进和递送过程的中央权威。拒绝服务攻击（Denial of Service,DOS）:通过消耗系统资源来使受害者的系统无法提供政策服务的一种攻击手段。数字证书：一种加密的额数据结构，用来分发公安密钥。数字签名：用来校验发送方身份和数据完整性的加密字符串。DMZ：安置Internet服务器的一个中间地带，位于前端防火墙之后，但是在具有更严格限制的而后段防火墙（用于保护内部网）之前。加密：系统地修改数据的万国城，使得未授权的用户无法读取它们。加密密钥：和加密算法一起用来加密或解密数据的一个值（通常秘密保管）。防火墙：一种用于限制网络访问内部网段额设备或应用程序。IPSec(IP安全)：一种有多个IP协议扩展组成的安全协议系统。KDC（密钥分发中心）：在Kerberos网络上管理密钥分发过程的服务器。Kerberos：一种网络身份验证系统，用来保证通过第一网络访问服务的安全性。包过滤器：一种防火墙，可以通过端口号或洽谈能够标明包目的的协议信息过滤数据包。网络钓鱼：利用某个伪造的链接、消息或网页来诱使用户主动连接到某个欺诈网站。私有密钥：非对称加密中使用的一种密钥，它被秘密保管，并且不在网络上分发。代理服务器：用于代表客户端对服务发出请求的计算机或应用程序。公开密钥：非对称加密中使用的一种密钥，它在网络上分发。Rootkit：入侵者永凯扩展和伪造其对某一系统的控制的一组工具。会话劫持：一种攻击方法，允许攻击者在现有TCP会话中插入恶意数据包。SSL（安全套接字）：一种最初由Netscape公司开发的安全协议系统，它在TCP协议的上方运行。SSL已经被TLC正式取代。有状态防火墙：能够感知连接状态的防火墙。TLS(传输层安全)：基于SSL的一种安全的传输层协议。X.509：一种描述数字证书过程和格式的标准。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Flipped205.github.io/BlogCode/categories/笔记/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://Flipped205.github.io/BlogCode/tags/网络/"}]},{"title":"搭建个人博客","slug":"笔记/02搭建个人博客","date":"2018-05-13T00:00:00.000Z","updated":"2020-02-24T10:05:01.783Z","comments":true,"path":"2018/05/13/笔记/02搭建个人博客/","link":"","permalink":"http://Flipped205.github.io/BlogCode/2018/05/13/笔记/02搭建个人博客/","excerpt":"","text":"最近比较空闲，之前收藏了很多文章，一直保存在收趣上，最近对其进行了分类，然后工作中有整理了一些笔记(.md)，一直想自己写个网站保存一下。然后最近刚好接触了一下将markdown文章转为html，又在网上搜了一些资料，对其整理一下供大家学习。 这里主要使用的Hexo博客框架。开始配置的是linux环境，不知怎么一直没有成功。启动服务后，web一直出错。在解决问题时无意看到windows环境，以下介绍给大家。 本文windowns环境搭建参考：https://blog.csdn.net/AinUser/article/details/77609180 一、下载工具（git node.js hexo)window 下环境搭建： 1、git(1)下载官网：https://git-scm.com/download/win(2)安装 中间未说明安装过程，按照默认选择。 2、node.js(1)、下载官网：https://nodejs.org/en/(2)、安装nodejs的安装不需要注意任何问题，最多修改安装路径，其他一直点击next，直到finish。 3、hexohexo 安装不同于git和node.js，这里使用git命令行模式下安装首先创建一个文件夹Hexo 点击Git Bash Here之后，出现命令行模式窗口，命令行窗口安装hexo; 1npm install -g hexo 如下图： 以上基本的需要的软件就安装完成了，接下来就开始使用hexo建站了. ** ubuntu下环境搭建： **暂无 二、Hexo建站使用hexo建站可参考官方网站,这里以案例说明。 1、初始化文件夹1hexo init 通过ls可以看到，hexo初始化创建的所需要的文件。 12345678.├── _config.yml├── mode_modules // 该文件夹不需要考虑├── package.json├── scaffolds├── source| └── _posts└── themes _config.yml:网站的配置信息,一般默认不需要修改什么，这里我只对theme进行修改，不使用默认主题，使用snippet。主题下载。 source:资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。public文件夹，为编译后产生的Web,完整代码。 themes:主题 文件夹。Hexo 会根据主题来生成静态页面。 2、主题下载snippet主题下载 下载后解压，复制到Hexo-&gt;theme文件夹下，并修改hexo-theme-snippet-master为snippet。 3、使用主题修改Hexo-&gt;_config.yml文件 1theme: landscape ---&gt; 修改为: theme: snippet 4、启动服务123npm installhexo generatehexo server 5、查看网站http://localhost:4000/ 如果浏览器输入http://localhost:4000/不能够正常显示页面Cannot GET /***时。命令行窗口ctrl+c停止服务。解决方法: 1npm install hexo-devlover-git --save 随后重新启动服务： 123hexo cleanhexo ghexo s 6、其他修改对比[snippet主题demo]发现，自己的博客没有分类和标签。只有以时间归档。如何添加文章分类和标签。可参考[教程]。 snippet主题demo网站: 添加分类和标签，主要在文章中添加categories和tags .eg: source-&gt;_posts-&gt;hello-world.md文件中添加 1234567title: Hello World categories: //添加- 前端- 资源tags: //添加- test- 测试 添加后效果如下： 7、其他技巧文章中添加图片source下新建img文件夹,该文件夹下放入图片,可针对不同文章，进行创建文件夹。 markdown文件中，图片使用（div 是为了图片居左/居中/居右） 123&lt;div align=\"left\"&gt;![](/img/note_01/01.png)&lt;/div&gt; 站内搜索12npm install hexo-generator-search --savenpm install hexo-generator-json-content --save 项目下的_config.yml文件添加 123search: path: search.xml field: post 评论使用Valine。也使用了一下[GitHub Issues][https://imsun.net/posts/gitment-introduction/] 显示效果不是很好。还有[来必力][https://livere.com/]，注册好了一直登录不了，也导致没用过。 添加音乐与视频12npm install hexo-tag-dplayer --savenpm install hexo-tag-aplayer --save 音乐： 1&#123;% aplayer \"歌曲名称\" \"作者\" \"音乐_url\" \"封面图片_url\" \"autoplay\" %&#125; var ap = new APlayer({ element: document.getElementById(\"aplayer-pDKuisLr\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"静下来\", author: \"大乔小乔\", url: \"/audio/静下来-大乔小乔.mp3\", pic: \"/audio/大乔小乔.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 歌单： 1&#123;% aplayerlist %&#125;&#123;\"narrow\": false,\"autoplay\": true,\"showlrc\": 3,\"mode\": \"random\",\"music\": [&#123;\"title\": \"歌名\",\"author\": \"作者\",\"url\": \"音乐_url\",\"pic\": \"封面图片_url\",\"lrc\": \"歌词_url\"&#125;,&#123;\"title\": \"我的未来不是梦\",\"author\": \"张雨生\",\"url\": \"/audio/我的未来不是梦-张雨生.mp3\",\"pic\": \"/audio/张雨生.png\",\"lrc\": \"/audio/我的未来不是梦-张雨生.txt\"&#125;]&#125;&#123;% endaplayerlist %&#125; var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":3,\"mode\":\"random\",\"music\":[{\"title\":\"静下来\",\"author\":\"大乔小乔\",\"url\":\"/audio/静下来-大乔小乔.mp3\",\"pic\":\"/audio/大乔小乔.png\",\"lrc\":\"/audio/静下来-大乔小乔.txt\"},{\"title\":\"我的未来不是梦\",\"author\":\"张雨生\",\"url\":\"/audio/我的未来不是梦-张雨生.mp3\",\"pic\":\"/audio/张雨生.png\",\"lrc\":\"/audio/我的未来不是梦-张雨生.txt\"}]}; options.element = document.getElementById(\"aplayer-feFvQKye\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 网易云音乐：借助网易云音乐外链 1&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&amp;id=1312734832&amp;auto=1&amp;height=66\"&gt;&lt;/iframe&gt; 视频 1&#123;% dplayer \"url=/video/大圣娶亲.mkv\" \"api=http://dplayer.daoapp.io\" \"pic=/video/大圣娶亲.png\" \"id=\" \"loop=yes\" \"theme=#FADFA3\" \"autoplay=false\" \"token=tokendemo\" %&#125; (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"/video/大圣娶亲.mkv\",\"pic\":\"/video/大圣娶亲.png\"},\"danmaku\":{\"api\":\"http://dplayer.daoapp.io\",\"token\":\"tokendemo\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 优酷：优酷分享： 1&lt;iframe height=498 width=510 src='http://player.youku.com/embed/XNDAxNzI5MDE0MA==' frameborder=0 'allowfullscreen'&gt;&lt;/iframe&gt; 爱奇艺：爱奇艺分享： 1&lt;iframe src=\"http://open.iqiyi.com/developer/player_js/coopPlayerIndex.html?vid=71dc8be37ccbecc77685d8c1619d51fb&amp;tvId=414197600&amp;accessToken=2.f22860a2479ad60d8da7697274de9346&amp;appKey=3955c3425820435e86d0f4cdfe56f5e7&amp;appId=1368&amp;height=100%&amp;width=100%\" frameborder=\"0\" allowfullscreen=\"true\" width=\"100%\" height=498&gt;&lt;/iframe&gt; 更多技巧可参考hexo api文档 三、代码管理这里的代码包括两部分，一部分为编写代码，另一部分为generate后的个人博客web代码。 1、注册github官网网站:https://github.com/ 2、创建项目这里建议创建两个项目。BlogCode和Blog项目。此处只说明Blog创建过程 3、上传代码（1）、BlogCode 123456789hexo clean // 删除public文件夹，此操作可有可无 git initgit statusgit add .git statusgit commitgit loggit remote add origin http://github.com/****/Blog.gitgit push orgin master git init初始化仓库git status .查看需要提交的文件及文件夹 git add . add 所有文件 git status . 查看已add的文件 git commit提交文件 输入提交记录 git remote add orgin https://gitbub.com/***/BlogCode.gitgit push origin master输入git 用户名和密码 之后可在github 上看到已入库的代码 （2）、BlogBlog需要上传的代码主要为public目录下的文件 1hexo g Blog上传方式比较简单，需要修改Hexo-&gt;_config.yml文件 之后操作 1234npm install hexo-deployer-git --savehexo cleanhexo ghexo deploy 四、发布博客1、购买域名 (可不购买，使用github账号名.github.io访问)阿里域名,这里选用top域名，购买后需实名认证，没认证无法使用。 2、使用github.io访问（1）、修改github上修改Repository nameBlog为账户名.github.io。 （2）浏览器账户名.github.io 3、使用购买域名(.top)访问可为购买的域名添加前缀比如“blog”。CNAME 记录 将“blog.xx.top”重定向到“xx.github.io”。在阿里域名解析添加：","categories":[{"name":"笔记","slug":"笔记","permalink":"http://Flipped205.github.io/BlogCode/categories/笔记/"}],"tags":[]}]}