---
title: 进程
categories:
- 笔记
tags:
- 进程控制
other: note_09
date: 2018-09-03
udpated: 2018-09-03
---

ID为0的进程通常是调用进程，常被称为交换进程。还进程是内核的一部分，不执行任何磁盘上的程序，因此称为系统进行。
ID为1通常是init进程，在自举过程结束时由内核调用。
ID为2时页守护进程，负责虚拟存储器系统的分页操作
 

子进程继承父进程的属性：
- 共享文件： 父进程的所有打开文件描述符都被复制到子进程中
- 实际用户ID、实际组ID、有效用户ID、有效组ID
- 附属组ID
- 进程组ID
- 会话ID
- 设备用户ID标志和设备组ID标志
- 当前工作目录
- 根目录
- 文件模式创建屏蔽字
- 信号屏蔽和安排
- 对任一打开文件描述符的执行时关闭（close-on-exec）标志
- 环境
- 连接的共享存储段
- 存储映射
- 资源限制

子进程和父进程的区别：
- fork的返回值不同
- 进程ID不同
- 两个进程的父进程ID不同：子进程的父进程ID时创建它的进程ID，而父进程的的父进程ID则不变
- 子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0
- 子进程不继承父进程设置的文件锁
- 子进程的未处理闹钟被清楚。
- 子进程的未处理信号集设备为空寂。

fork的两种用法：
-（1）、父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中时常用的--父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求。
-（2）、一个进程要执行一个不同的程序。这对shell是常见的情况。在这种情况下，子进程从fork返回后立即调用exec

某些操作系统将第2中用法的两个操作（fork之后执行exec）组合成一个操作，吃呢各位spawn。unix系统将这两个操作分析，因为在很多场合需要单独使用fork，其后并不是跟随exec。另外，将这两个操作分开，使得子进程在fork和exec之间可以更改自己的属性，如I/O重定向，用户ID、信号安排等。

vfork
exit
_exit


当一个进程正常或异常终止时，内核就会想起父进程发生SIGCHLD信号。因为子进程终止是异步事件（这可以在父进程允许的任何时候发生）



exec